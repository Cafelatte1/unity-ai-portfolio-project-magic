# Unity C# ì½”ë“œ í’ˆì§ˆ í‰ê°€ ë³´ê³ ì„œ

**í‰ê°€ ì¼ì‹œ**: 2025-12-16 15:30  
**í”„ë¡œì íŠ¸**: project-magic  
**í‰ê°€ ë²”ìœ„**: Assets/Scripts ì „ì²´ ì½”ë“œë² ì´ìŠ¤

---

## ğŸ“Œ 1. Architecture & Unity Component Design

### í‰ê°€ (7.5/10)

**ê°•ì :**
- FSMê³¼ BehaviorTreeë¥¼ í™œìš©í•œ ì²´ê³„ì ì¸ ìƒíƒœ ê´€ë¦¬ êµ¬ì¡°
- Core í´ë”ì— ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œìŠ¤í…œ í´ë˜ìŠ¤ ë¶„ë¦¬ (HealthSystem, AttackSystem, FiniteStateMachine, BehaviorTree)
- ScriptableObject ê¸°ë°˜ ë°ì´í„° ì„¤ê³„ (CharacterStats, SkillData, ActionData)
- ObjectPool íŒ¨í„´ì„ í†µí•œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ê°ì²´ ê´€ë¦¬

**ë¬¸ì œì :**
1. **SRP ìœ„ë°˜**: `PlayerBehavior`ì™€ `EnemyBehavior`ê°€ ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°€ì§ (ì…ë ¥ ì²˜ë¦¬, ìƒíƒœ ê´€ë¦¬, ë¬¼ë¦¬ ì²˜ë¦¬, ì• ë‹ˆë©”ì´ì…˜ ì œì–´ ë“±)
2. **Unity ìƒëª…ì£¼ê¸° í˜¼ì¬**: `FixedUpdate`, `Update`, `LateUpdate`ê°€ í˜¼ì¬ë˜ì–´ ì‹¤í–‰ ìˆœì„œ ì˜ˆì¸¡ ì–´ë ¤ì›€
3. **Composition vs Inheritance**: ëŒ€ë¶€ë¶„ ìƒì† ê¸°ë°˜ì´ë‚˜ ì¼ë¶€ ê¸°ëŠ¥ì€ ì»´í¬ì§€ì…˜ì´ ë” ì í•© (ì˜ˆ: ì…ë ¥ ì²˜ë¦¬)

**ê°œì„ ì•ˆ:**
```csharp
// ì…ë ¥ ì²˜ë¦¬ë¥¼ ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ë¶„ë¦¬
public class PlayerInputHandler : MonoBehaviour
{
    public UnityEvent<float> OnMoveInput;
    public UnityEvent OnJumpInput;
    public UnityEvent OnAttackInput;
    
    public void OnMove(InputValue value) => OnMoveInput?.Invoke(value.Get<float>());
    public void OnJump(InputValue value) => OnJumpInput?.Invoke();
}

// PlayerBehaviorëŠ” ìƒíƒœ ê´€ë¦¬ë§Œ ë‹´ë‹¹
public class PlayerBehavior : MonoBehaviour
{
    PlayerInputHandler inputHandler;
    PlayerMovement movement;
    PlayerStateMachine stateMachine;
}
```

---

## ğŸ“Œ 2. Code Readability & Maintainability

### í‰ê°€ (6.5/10)

**ê°•ì :**
- ì¼ê´€ëœ ë„¤ì´ë° ì»¨ë²¤ì…˜ (PascalCase for public, camelCase with underscore for private)
- Enumì„ í™œìš©í•œ ëª…í™•í•œ ìƒíƒœ ì •ì˜
- Loggerë¥¼ í†µí•œ ë””ë²„ê¹… ì§€ì›

**ë¬¸ì œì :**
1. **ì£¼ì„ ë¶€ì¬**: XML ë¬¸ì„œí™” ì£¼ì„ì´ ê±°ì˜ ì—†ìŒ (public APIì— ì„¤ëª… ì—†ìŒ)
2. **Magic Number**: í•˜ë“œì½”ë”©ëœ ìˆ«ì ë‹¤ìˆ˜ (`1e-1`, `0.2f`, `Mathf.Epsilon`)
3. **ê¸´ ë©”ì„œë“œ**: `PlayerBehavior.UpdateXState()`, `EnemyBehavior.BuildStateController()` ë“±ì´ 50ì¤„ ì´ìƒ
4. **ë³€ìˆ˜ëª… ëª¨í˜¸í•¨**: `_snapShotMoveInput`, `_attackRes` ë“±ì˜ ì¶•ì•½í˜• ì‚¬ìš©

**ê°œì„ ì•ˆ:**
```csharp
/// <summary>
/// ìºë¦­í„°ì˜ ì²´ë ¥ ì‹œìŠ¤í…œì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
/// ë°ë¯¸ì§€ ê³„ì‚°, ë¬´ì  ì‹œê°„, ì‚¬ë§ ì²˜ë¦¬ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤.
/// </summary>
public abstract class HealthSystem : MonoBehaviour
{
    // Magic numberë¥¼ ìƒìˆ˜ë¡œ ì •ì˜
    private const float MIN_DAMAGE = 1f;
    private const float DISTANCE_THRESHOLD = 0.1f; // 1e-1 ëŒ€ì‹ 
    
    /// <summary>
    /// ìºë¦­í„°ê°€ ë°ë¯¸ì§€ë¥¼ ë°›ìŠµë‹ˆë‹¤.
    /// </summary>
    /// <param name="rawDamage">ë°©ì–´ë ¥ ì ìš© ì „ ì›ì‹œ ë°ë¯¸ì§€</param>
    /// <param name="knockbackDirection">ë„‰ë°± ë°©í–¥ ë²¡í„°</param>
    public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
    {
        // ê¸°ì¡´ ì½”ë“œ
    }
}
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

### í‰ê°€ (7/10)

**ê°•ì :**
- ObjectPool íŒ¨í„´ìœ¼ë¡œ GC ì••ë ¥ ê°ì†Œ
- GetComponent ìºì‹± (Awakeì—ì„œ ë¯¸ë¦¬ ì €ì¥)
- ì¡°ê±´ë¶€ ì‹¤í–‰ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ê³„ì‚° íšŒí”¼

**ë¬¸ì œì :**
1. **Update/FixedUpdate í˜¼ì¬**: ë¬¼ë¦¬ ì—°ì‚°ê³¼ ë¡œì§ì´ ë¶„ë¦¬ë˜ì§€ ì•ŠìŒ
```csharp
// PlayerBehavior.cs
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput;
    UpdateYState();  // ë¬¼ë¦¬ ê´€ë ¨
    UpdateXState();  // ë¡œì§ ê´€ë ¨ - Updateì— ìˆì–´ì•¼ í•¨
}
```

2. **String ì—°ì‚° ê³¼ë‹¤**: Loggerì—ì„œ string interpolation/concatenation ë¹ˆë²ˆ
```csharp
Logger.Write($"XState changed from={fromXState.ToString()} to={currentState.ToString()}");
// ToString()ì´ ë§¤ë²ˆ í˜¸ì¶œë˜ê³  string allocation ë°œìƒ
```

3. **Boxing ë°œìƒ**: Dictionaryì—ì„œ Enumì„ keyë¡œ ì‚¬ìš© ì‹œ
```csharp
Dictionary<PlayerState, FSMNode> stateContainer;  // PlayerStateê°€ boxingë  ìˆ˜ ìˆìŒ
```

4. **ë¶ˆí•„ìš”í•œ Queue í• ë‹¹**: `bufferXState`, `bufferYState`ê°€ ë§¤ í”„ë ˆì„ ì²´í¬ë˜ì§€ë§Œ ëŒ€ë¶€ë¶„ ë¹„ì–´ìˆìŒ

**ê°œì„ ì•ˆ:**
```csharp
// String builder ì‚¬ìš©ìœ¼ë¡œ GC ì••ë ¥ ê°ì†Œ
private StringBuilder _logBuilder = new StringBuilder(256);

void LogStateChange(PlayerState from, PlayerState to)
{
    _logBuilder.Clear();
    _logBuilder.Append("XState changed from=");
    _logBuilder.Append(from);
    _logBuilder.Append(" to=");
    _logBuilder.Append(to);
    Logger.Write(_logBuilder.ToString());
}

// EqualityComparerë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•˜ì—¬ boxing ë°©ì§€
Dictionary<PlayerState, FSMNode> stateContainer = 
    new Dictionary<PlayerState, FSMNode>(EqualityComparer<PlayerState>.Default);
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

### í‰ê°€ (6/10)

**ê°•ì :**
- Input System ì‚¬ìš©ìœ¼ë¡œ í˜„ëŒ€ì  ì…ë ¥ ì²˜ë¦¬
- ì¿¨ë‹¤ìš´ ì‹œìŠ¤í…œìœ¼ë¡œ ê³µê²© íƒ€ì´ë° ì œì–´
- ë¬´ì  ì‹œê°„ìœ¼ë¡œ ì—°ì† í”¼ê²© ë°©ì§€

**ë¬¸ì œì :**
1. **íƒ€ì´ë° ì´ìŠˆ**: Jump bufferê°€ ì—†ì–´ ì…ë ¥ ì†ì‹¤ ê°€ëŠ¥
```csharp
public void OnJump(InputValue value)
{ 
    if (!CanControll()) return;
    if (value.isPressed && currentYState != PlayerState.InFlight)
        _jumpInput = true;  // FixedUpdate ì „ì— ì´ˆê¸°í™”ë  ìˆ˜ ìˆìŒ
}
```

2. **Null ì²´í¬ ë¶€ì¡±**:
```csharp
// AttackSystem.cs - ExecuteMeleeAttack
if (targetHealthSystem == null)  // í•„ë“œ ì²´í¬
{
    if (hit.TryGetComponent<HealthSystem>(out HealthSystem targetHealthSystem))  // ì§€ì—­ ë³€ìˆ˜ì™€ í•„ë“œëª… ì¤‘ë³µ
    {
        // ë¡œì§
    }
}
else
{
    ApplyAttack(attack, origin.transform.position, hit.transform.position, targetHealthSystem);
    // targetHealthSystemì´ nullì¼ ìˆ˜ ìˆëŠ”ë° ì²´í¬ ì—†ìŒ
}
```

3. **Race Condition**: LLM ë¹„ë™ê¸° ì²˜ë¦¬ì—ì„œ Unity ìŠ¤ë ˆë“œ ë™ê¸°í™” ë¬¸ì œ ê°€ëŠ¥ì„±
```csharp
// LLMInferenceManager.cs
private readonly ConcurrentQueue<Action> _mainThreadActions = new ConcurrentQueue<Action>();
// Queueê°€ ê°€ë“ ì°° ê²½ìš° ì²˜ë¦¬ ì—†ìŒ
```

4. **FSM ìƒíƒœ ì „í™˜ ëˆ„ë½**: DAMAGED -> IDLEë¡œë§Œ ì „í™˜, ë‹¤ë¥¸ ìƒíƒœë¡œì˜ ì „í™˜ ê³ ë ¤ ì•ˆë¨

**ê°œì„ ì•ˆ:**
```csharp
// Jump buffer êµ¬í˜„
private const float JUMP_BUFFER_TIME = 0.2f;
private float _jumpBufferTimer;

public void OnJump(InputValue value)
{ 
    if (!CanControll()) return;
    if (value.isPressed)
        _jumpBufferTimer = JUMP_BUFFER_TIME;  // ë²„í¼ í™œì„±í™”
}

void UpdateYState()
{
    if (_jumpBufferTimer > 0)
    {
        _jumpBufferTimer -= Time.deltaTime;
        if (currentYState == PlayerState.ReadyToJump && CheckGrounded())
        {
            ChangeState(ref currentYState, PlayerState.InFlight);
            _jumpBufferTimer = 0;  // ë²„í¼ ì†Œë¹„
        }
    }
}
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

### í‰ê°€ (7/10)

**ê°•ì :**
- SerializeFieldì™€ Header/Tooltip ì ê·¹ í™œìš©
- Prefab ì¤‘ì‹¬ ê°œë°œ (ContainerControllerë¥¼ í†µí•œ ê´€ë¦¬)
- LayerMask í™œìš©í•œ ì¶©ëŒ í•„í„°ë§
- Time.deltaTime ê¸°ë°˜ í”„ë ˆì„ ë…ë¦½ì  ê³„ì‚°

**ë¬¸ì œì :**
1. **GetComponent ì¤‘ë³µ í˜¸ì¶œ**:
```csharp
// HealthSystem.cs
stats = GetComponentInChildren<StatsContainer>().stats;  // null ì²´í¬ ì—†ìŒ
```

2. **Transform ìˆ˜ì •ê³¼ Physics ì¶©ëŒ**:
```csharp
// APCBehavior - StateShield
ctx.transform.position = Vector3.Lerp(...);  // Rigidbody ìˆìœ¼ë©´ ì¶©ëŒ
```

3. **Magic Number ê³¼ë‹¤**:
```csharp
if (Vector3.Distance(GetFollowTargetPos(_snapShotFollowTarget), transform.position) <= 1e-1)
```

4. **Editor ì½”ë“œ í˜¼ì¬**:
```csharp
#if UNITY_EDITOR
    if (Logger.DEBUG)
    {
        if (fromXState != currentState)
            Logger.Write(...);
    }
#endif
```

**ê°œì„ ì•ˆ:**
```csharp
// Constants í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬
public static class GameConstants
{
    public const float POSITION_TOLERANCE = 0.1f;
    public const float RAYCAST_DETECTION_RADIUS = 0.2f;
    public const float MIN_DAMAGE = 1f;
}

// TryGetComponent ì‚¬ìš©
protected virtual void Awake()
{
    if (!TryGetComponent<StatsContainer>(out var container))
    {
        Logger.Write("StatsContainer not found", "ERROR");
        return;
    }
    stats = container.stats;
}

// Rigidbodyê°€ ìˆìœ¼ë©´ MovePosition ì‚¬ìš©
if (_rigidbody != null)
    _rigidbody.MovePosition(targetPosition);
else
    transform.position = targetPosition;
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

### í‰ê°€ (7.5/10)

**ê°•ì :**
- FSMê³¼ BehaviorTree êµ¬í˜„ì´ ëª…í™•í•˜ê³  í™•ì¥ ê°€ëŠ¥
- AnimationControllerë¥¼ í†µí•œ ì• ë‹ˆë©”ì´ì…˜ ì¶”ìƒí™”
- UnityEventë¥¼ í†µí•œ ëŠìŠ¨í•œ ê²°í•©

**ë¬¸ì œì :**
1. **Animatorì™€ State ë™ê¸°í™” ì´ìŠˆ**:
```csharp
// AnimationController.cs
public float PlayStateAnimation(PlayerState state, bool rebind = false)
{
    if (state != currentState)
    {
        // ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
    }
    return _prefabs.GetClipTime(currentState, currentIndex);
}
// ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚¬ëŠ”ì§€ ì²´í¬í•˜ëŠ” ë¡œì§ ì—†ìŒ
```

2. **FSM ì „í™˜ ì œì•½ ì—†ìŒ**: ëª¨ë“  ìƒíƒœì—ì„œ ëª¨ë“  ìƒíƒœë¡œ ì „í™˜ ê°€ëŠ¥ (ìœ íš¨í•˜ì§€ ì•Šì€ ì „í™˜ í—ˆìš©)

3. **BehaviorTree êµ¬ì¡° ë‹¨ìˆœí•¨**: Selectorì™€ Sequenceë§Œ ìˆê³ , Decorator, Parallel ë…¸ë“œ ì—†ìŒ

4. **Animation Event ì˜ì¡´ë„**: ì½”ë“œì—ì„œ í™•ì¸ ë¶ˆê°€ëŠ¥í•˜ì§€ë§Œ Animation Event ì‚¬ìš© ì‹œ ë””ë²„ê¹… ì–´ë ¤ì›€

**ê°œì„ ì•ˆ:**
```csharp
// FSMì— ìœ íš¨í•œ ì „í™˜ ì •ì˜
public class PlayerStateMachine
{
    private static readonly Dictionary<PlayerState, HashSet<PlayerState>> ValidTransitions = new()
    {
        { PlayerState.IDLE, new() { PlayerState.MOVE, PlayerState.ATTACK, PlayerState.DAMAGED, PlayerState.DEATH } },
        { PlayerState.MOVE, new() { PlayerState.IDLE, PlayerState.ATTACK, PlayerState.DAMAGED, PlayerState.DEATH } },
        { PlayerState.ATTACK, new() { PlayerState.IDLE, PlayerState.DAMAGED, PlayerState.DEATH } },
        // ...
    };
    
    public bool CanTransition(PlayerState from, PlayerState to)
    {
        return ValidTransitions.TryGetValue(from, out var validStates) && validStates.Contains(to);
    }
}

// Animator ìƒíƒœ ì²´í¬ ì¶”ê°€
public bool IsAnimationComplete()
{
    var stateInfo = animator.GetCurrentAnimatorStateInfo(0);
    return stateInfo.normalizedTime >= 1.0f;
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

### í‰ê°€ (5.5/10)

**ê°•ì :**
- Loggerë¥¼ í†µí•œ ì—ëŸ¬ ë¡œê¹…
- ì¼ë¶€ null ì²´í¬ ì¡´ì¬
- IsAlive ì†ì„±ìœ¼ë¡œ ì‚¬ë§ ìƒíƒœ ì²´í¬

**ë¬¸ì œì :**
1. **Null ì°¸ì¡° ìœ„í—˜ ë‹¤ìˆ˜**:
```csharp
// PlayerBehavior.cs
uiController = GetComponent<ChatDisposer>()?.uiController;  // uiControllerê°€ nullì¼ ìˆ˜ ìˆìŒ

// ì‚¬ìš©ì²˜ì—ì„œ null ì²´í¬ ì—†ìŒ
if (uiController.chatPanel.IsInteracting) return;  // NullReferenceException ê°€ëŠ¥
```

2. **TryGetComponent ë¯¸ì‚¬ìš©**:
```csharp
stats = GetComponentInChildren<StatsContainer>().stats;  // null ì²´í¬ ì—†ì´ ë°”ë¡œ ì ‘ê·¼
```

3. **Array/List ë²”ìœ„ ì²´í¬ ë¶€ì¡±**:
```csharp
public virtual bool ExecuteAttack(int attackIndex, ...)
{
    if (attackIndex >= attackContainer.Count)  // ìŒìˆ˜ ì²´í¬ ì—†ìŒ
    {
        Logger.Write($"Invalid attack index: {attackIndex}", "ERROR");
        return false;
    }
}
```

4. **LLM ë¹„ë™ê¸° ì—ëŸ¬ ì²˜ë¦¬ ë¯¸í¡**:
```csharp
async void Start()  // async voidëŠ” ì˜ˆì™¸ ì²˜ë¦¬ ì–´ë ¤ì›€
{
    try { await Setup(); }
    catch (Exception e) { Logger.Write($"llm inference manager setup failed / msg={e}", "ERROR"); }
}
```

5. **ì´ˆê¸°í™” ìˆœì„œ ë¬¸ì œ**:
```csharp
void Start()
{
    uiController = GetComponent<ChatDisposer>()?.uiController;
    // ChatDisposerì˜ Startê°€ ì‹¤í–‰ë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŒ
}
```

**ê°œì„ ì•ˆ:**
```csharp
// Null-safe íŒ¨í„´
public class PlayerBehavior : MonoBehaviour
{
    private UIController _uiController;
    
    void Awake()
    {
        if (!TryGetComponent<ChatDisposer>(out var chatDisposer))
        {
            Logger.Write("ChatDisposer component not found", "ERROR");
            enabled = false;  // ì»´í¬ë„ŒíŠ¸ ë¹„í™œì„±í™”
            return;
        }
        _uiController = chatDisposer.uiController;
    }
    
    bool CanControll()
    {
        if (!IsAlive) return false;
        if (_uiController == null) return true;  // null-safe
        if (_uiController.chatPanel == null) return true;  // null-safe
        return !_uiController.chatPanel.IsInteracting;
    }
}

// Array ë²”ìœ„ ì²´í¬
public virtual bool ExecuteAttack(int attackIndex, ...)
{
    if (attackIndex < 0 || attackIndex >= attackContainer.Count)
    {
        Logger.Write($"Invalid attack index: {attackIndex} (valid: 0-{attackContainer.Count - 1})", "ERROR");
        return false;
    }
    // ...
}

// async Taskë¡œ ë³€ê²½
async Task Start()  // async Taskë¡œ ë³€ê²½
{
    try { await Setup(); }
    catch (Exception e) 
    { 
        Logger.Write($"Setup failed: {e.Message}", "ERROR");
        throw;  // ì˜ˆì™¸ ì¬ë°œìƒìœ¼ë¡œ ë¬¸ì œ ì „íŒŒ
    }
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

### í‰ê°€ (8/10)

**ê°•ì :**
- ScriptableObject ê¸°ë°˜ ë°ì´í„° êµ¬ì¡°ë¡œ í™•ì¥ ìš©ì´
- AttackContainerë¡œ ê³µê²© ìœ í˜• ì¶”ê°€ ê°€ëŠ¥
- FSM/BT íŒ¨í„´ìœ¼ë¡œ ìƒˆë¡œìš´ ìƒíƒœ/í–‰ë™ ì¶”ê°€ ì‰¬ì›€
- ObjectPoolë¡œ ìŠ¤í‚¬ ì¢…ë¥˜ í™•ì¥ ê°€ëŠ¥

**ë¬¸ì œì :**
1. **í•˜ë“œì½”ë”©ëœ ìŠ¤í‚¬ ì¸ë±ìŠ¤**:
```csharp
public void OnSkillW(InputValue value)
{
    _attackRes = attackSystem.ExecuteAttack(1, this.transform, layerEnemy);  // ì¸ë±ìŠ¤ í•˜ë“œì½”ë”©
}
```

2. **Event ì¤‘ë³µ ì •ì˜**: ê° ì‹œìŠ¤í…œë§ˆë‹¤ UnityEvent ì„ ì–¸ (ì¤‘ì•™ ê´€ë¦¬ ì—†ìŒ)

3. **Layer/Tag ë¬¸ìì—´ ì˜ì¡´**:
```csharp
colliders.layer = LayerMask.NameToLayer(LayerName.Corpse.ToString());  // ToString() ë¶ˆí•„ìš”
```

**ê°œì„ ì•ˆ:**
```csharp
// ìŠ¤í‚¬ ë°”ì¸ë”© êµ¬ì¡°
[Serializable]
public class SkillBinding
{
    public string skillName;
    public int skillIndex;
    public KeyCode keyCode;
}

public class PlayerSkillController : MonoBehaviour
{
    [SerializeField] List<SkillBinding> skillBindings;
    
    void Update()
    {
        foreach (var binding in skillBindings)
        {
            if (Input.GetKeyDown(binding.keyCode))
            {
                attackSystem.ExecuteAttack(binding.skillIndex, transform, layerEnemy);
            }
        }
    }
}

// Event Aggregator íŒ¨í„´
public class GameEventBus : Singleton<GameEventBus>
{
    public UnityEvent<float, float, float> OnHealthChanged;
    public UnityEvent<Vector2> OnHit;
    public UnityEvent OnDeath;
    public UnityEvent<int> OnAttack;
}

// Layerë¥¼ const intë¡œ ê´€ë¦¬
public static class Layers
{
    public const int Ground = 6;
    public const int Player = 7;
    public const int Enemy = 8;
    public const int Corpse = 9;
}
```

---

## ğŸ“Œ 9. Clean Code Practices

### í‰ê°€ (6.5/10)

**ê°•ì :**
- ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì™€ í´ë” êµ¬ì¡°ê°€ ë…¼ë¦¬ì 
- Singleton íŒ¨í„´ ì¼ê´€ì  ì‚¬ìš©
- ìƒìˆ˜ë¥¼ Enumìœ¼ë¡œ ì •ì˜

**ë¬¸ì œì :**
1. **SOLID ìœ„ë°˜**:
   - **SRP**: PlayerBehavior, EnemyBehaviorê°€ ë„ˆë¬´ ë§ì€ ì±…ì„
   - **OCP**: ìƒˆë¡œìš´ ê³µê²© íƒ€ì… ì¶”ê°€ ì‹œ AttackSystem ìˆ˜ì • í•„ìš”
   - **DIP**: êµ¬ì²´ í´ë˜ìŠ¤ì— ì§ì ‘ ì˜ì¡´ (ì˜ˆ: ChatDisposer)

2. **DRY ìœ„ë°˜**:
```csharp
// PlayerBehaviorì™€ EnemyBehaviorì— ì¤‘ë³µ ì½”ë“œ
void ListenerHit(Vector2 knockback)
{
    if (_hitRecoveryTimer > 0) return;
    _hitForce = knockback;
    // ...
}
```

3. **Public í•„ë“œ ê³¼ë‹¤**:
```csharp
public Animator animator;  // publicì´ì§€ë§Œ ì™¸ë¶€ì—ì„œ ì ‘ê·¼í•  í•„ìš” ì—†ìŒ
```

4. **Property vs Field í˜¼ì¬**:
```csharp
public float MaxHealth => stats.maxHealth;  // property
public bool IsAlive => currentHealth > 0;   // property
public UnityEvent<float, float, float> OnHealthChanged;  // field
```

**ê°œì„ ì•ˆ:**
```csharp
// SRP - ì±…ì„ ë¶„ë¦¬
public class PlayerBehavior : MonoBehaviour
{
    private PlayerStateMachine _stateMachine;
    private PlayerInputHandler _inputHandler;
    private PlayerMovement _movement;
    private PlayerCombat _combat;
}

// OCP - ì „ëµ íŒ¨í„´
public interface IAttackStrategy
{
    void Execute(AttackContainer attack, Transform origin, LayerMask targetLayer);
}

public class MeleeAttackStrategy : IAttackStrategy { }
public class ProjectileAttackStrategy : IAttackStrategy { }
public class AoeAttackStrategy : IAttackStrategy { }

public class AttackSystem : MonoBehaviour
{
    private Dictionary<AttackType, IAttackStrategy> _strategies;
    
    public bool ExecuteAttack(int attackIndex, Transform origin, LayerMask targetLayer)
    {
        var attack = attackContainer[attackIndex];
        _strategies[attack.attackType].Execute(attack, origin, targetLayer);
    }
}

// DIP - ì¸í„°í˜ì´ìŠ¤ ì˜ì¡´
public interface IUIController
{
    bool IsInteracting { get; }
}

public class PlayerBehavior : MonoBehaviour
{
    private IUIController _uiController;  // êµ¬ì²´ íƒ€ì…ì´ ì•„ë‹Œ ì¸í„°í˜ì´ìŠ¤ ì˜ì¡´
}
```

---

## ğŸ“Œ 10. Intel OpenVINO ê¸°ë°˜ AI ëª¨ë¸ ì¶”ë¡  í”„ë¡œì„¸ìŠ¤

### í‰ê°€ (7/10)

**ê°•ì :**
- DLL Importë¥¼ í†µí•œ Native ì—°ë™ êµ¬í˜„
- ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ Unity ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€
- ConcurrentQueueë¡œ ìŠ¤ë ˆë“œ ì•ˆì „ì„± í™•ë³´
- ì—ëŸ¬ í•¸ë“¤ë§ê³¼ ë¡œê¹… ì²´ê³„ì 

**ë¬¸ì œì :**
1. **ì´ˆê¸°í™” íƒ€ì´ë° ë¬¸ì œ**:
```csharp
async void Start()  // async voidëŠ” ì˜ˆì™¸ ì „íŒŒ ì•ˆë¨
{
    try { await Setup(); }
    catch (Exception e) { Logger.Write($"...", "ERROR"); }
}
```

2. **ë©”ëª¨ë¦¬ ê´€ë¦¬ ë¶ˆëª…í™•**:
```csharp
[DllImport("project-magic-localai-unity")]
private static extern void OV_Release(IntPtr pipelinePtr);

void OnDestroy()
{
    _worker?.Stop();
    if (_pipeline != IntPtr.Zero)
    {
        OV_Release(_pipeline);  // ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ í•´ì œ
        _pipeline = IntPtr.Zero;
    }
}
// í•˜ì§€ë§Œ _worker.Stop()ì´ ì™„ì „íˆ ì¢…ë£Œë˜ê¸° ì „ì— Release í˜¸ì¶œ ê°€ëŠ¥
```

3. **ì—ëŸ¬ ì²˜ë¦¬ ë¯¸í¡**:
```csharp
IntPtr InitInferencePipeline()
{
    var pipeline = OV_LoadModel(modelPath, device != "CPU" ? "CPU" : device);
    if (pipeline == IntPtr.Zero)
        Logger.Write("Failed to execute OV_LoadModel", "ERROR");
    return pipeline;  // IntPtr.Zero ë°˜í™˜ í›„ ì‚¬ìš© ì‹œ í¬ë˜ì‹œ ê°€ëŠ¥
}
```

4. **ë™ì‹œ ìš”ì²­ ì œí•œ ì—†ìŒ**: RequestInferenceê°€ ë¬´í•œì • Queueì— ì¶”ê°€ ê°€ëŠ¥

**ê°œì„ ì•ˆ:**
```csharp
// ì´ˆê¸°í™” ì™„ë£Œ ëŒ€ê¸°
public async Task InitializeAsync()
{
    IsInitializing = true;
    try
    {
        _pipeline = await Task.Run(() => InitInferencePipeline());
        if (_pipeline == IntPtr.Zero)
        {
            throw new Exception("Failed to initialize inference pipeline");
        }
        InitWorkerThread(_pipeline);
        EventModelReady?.Invoke();
    }
    finally
    {
        IsInitializing = false;
    }
}

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ì¢…ë£Œ
async void OnDestroy()
{
    if (_worker != null)
    {
        _worker.Stop();
        // ì›Œì»¤ ìŠ¤ë ˆë“œê°€ ì™„ì „íˆ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
        await Task.Run(() => _worker.WaitForCompletion());
    }
    
    if (_pipeline != IntPtr.Zero)
    {
        OV_Release(_pipeline);
        _pipeline = IntPtr.Zero;
    }
}

// ìš”ì²­ ìˆ˜ ì œí•œ
private const int MAX_QUEUE_SIZE = 10;

public void RequestInference(LLMRequest request)
{
    if (_requestQueue.Count >= MAX_QUEUE_SIZE)
    {
        Logger.Write("Request queue is full, rejecting request", "WARNING");
        return;
    }
    _requestQueue.Enqueue(request);
}
```

---

## ğŸ“Œ ì¢…í•© í‰ê°€

### ì´ì : **6.9 / 10**

| í•­ëª© | ì ìˆ˜ | ê°€ì¤‘ì¹˜ | ê°€ì¤‘ ì ìˆ˜ |
|------|------|--------|-----------|
| 1. Architecture & Unity Component Design | 7.5 | 15% | 1.13 |
| 2. Code Readability & Maintainability | 6.5 | 10% | 0.65 |
| 3. Performance & Memory Efficiency | 7.0 | 10% | 0.70 |
| 4. Gameplay Logic & Stability | 6.0 | 15% | 0.90 |
| 5. Unity-Engine Best Practices | 7.0 | 10% | 0.70 |
| 6. Animation, FSM/BT, Event Flow | 7.5 | 10% | 0.75 |
| 7. Safety & Error Handling | 5.5 | 10% | 0.55 |
| 8. Scalability / Extensibility | 8.0 | 10% | 0.80 |
| 9. Clean Code Practices | 6.5 | 5% | 0.33 |
| 10. Intel OpenVINO AI Integration | 7.0 | 5% | 0.35 |
| **ì´ì ** | | **100%** | **6.86** |

---

## ğŸ”´ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (Top 3)

### 1. **Null ì°¸ì¡° ì•ˆì •ì„± ê°•í™”** (ìš°ì„ ìˆœìœ„: ê¸´ê¸‰)
**ë¬¸ì œ**: ì „ì²´ ì½”ë“œë² ì´ìŠ¤ì— null ì²´í¬ ë¶€ì¡±ìœ¼ë¡œ ëŸ°íƒ€ì„ í¬ë˜ì‹œ ìœ„í—˜
- `uiController.chatPanel.IsInteracting` - NullReferenceException ê°€ëŠ¥
- `GetComponentInChildren<StatsContainer>().stats` - null ì²´í¬ ì—†ìŒ
- ì´ˆê¸°í™” ìˆœì„œ ë¬¸ì œë¡œ Start()ì—ì„œ ì»´í¬ë„ŒíŠ¸ ì°¸ì¡° ì‹¤íŒ¨ ê°€ëŠ¥

**í•´ê²° ë°©ì•ˆ**:
```csharp
// 1ë‹¨ê³„: ëª¨ë“  GetComponentë¥¼ TryGetComponentë¡œ ë³€ê²½
// 2ë‹¨ê³„: í•„ìˆ˜ ì»´í¬ë„ŒíŠ¸ëŠ” RequireComponent ì–´íŠ¸ë¦¬ë·°íŠ¸ ì‚¬ìš©
[RequireComponent(typeof(Rigidbody2D), typeof(HealthSystem))]
public class PlayerBehavior : MonoBehaviour

// 3ë‹¨ê³„: Null-conditional operator ì ê·¹ í™œìš©
if (_uiController?.chatPanel?.IsInteracting ?? false) return;
```

### 2. **Input Buffer ë° íƒ€ì´ë° ì‹œìŠ¤í…œ ê°œì„ ** (ìš°ì„ ìˆœìœ„: ë†’ìŒ)
**ë¬¸ì œ**: ì…ë ¥ ì†ì‹¤ë¡œ ì¸í•œ í”Œë ˆì´ í’ˆì§ˆ ì €í•˜
- Jump ì…ë ¥ì´ FixedUpdate íƒ€ì´ë° ë¬¸ì œë¡œ ë¬´ì‹œë  ìˆ˜ ìˆìŒ
- Attack ì¤‘ ì´ë™ ì…ë ¥ ì²˜ë¦¬ê°€ ë¶ˆëª…í™•
- ê³µê²© recovery timerì™€ ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™” ì•ˆë¨

**í•´ê²° ë°©ì•ˆ**:
```csharp
// Jump buffer êµ¬í˜„ (0.2ì´ˆ)
private const float JUMP_BUFFER_TIME = 0.2f;
private float _jumpBufferTimer;

// Attack recoveryë¥¼ ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê¸°ë°˜ìœ¼ë¡œ ìë™ ì„¤ì •
void ListenerAttack(int attackIndex)
{
    float animLength = animController.GetCurrentClipLength();
    _attackRecoveryTimer = animLength * 0.8f;  // 80% ì§€ì ì—ì„œ ìº”ìŠ¬ ê°€ëŠ¥
}
```

### 3. **PlayerBehavior/EnemyBehavior ì±…ì„ ë¶„ë¦¬** (ìš°ì„ ìˆœìœ„: ë†’ìŒ)
**ë¬¸ì œ**: ë‹¨ì¼ í´ë˜ìŠ¤ê°€ ì…ë ¥, ìƒíƒœ, ë¬¼ë¦¬, ì• ë‹ˆë©”ì´ì…˜ ëª¨ë‘ ê´€ë¦¬ (SRP ìœ„ë°˜)
- ì½”ë“œ ë³µì¡ë„ ì¦ê°€ (464ì¤„, 497ì¤„)
- í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€
- ìœ ì§€ë³´ìˆ˜ ë¶€ë‹´

**í•´ê²° ë°©ì•ˆ**:
```csharp
// ì±…ì„ë³„ ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬
PlayerBehavior.cs (300ì¤„ â†’ 100ì¤„)
  â†“ ë¶„ë¦¬
â”œâ”€â”€ PlayerInputHandler.cs (ì…ë ¥ ì²˜ë¦¬)
â”œâ”€â”€ PlayerStateMachine.cs (ìƒíƒœ ê´€ë¦¬)
â”œâ”€â”€ PlayerMovement.cs (ë¬¼ë¦¬ ì´ë™)
â””â”€â”€ PlayerAnimator.cs (ì• ë‹ˆë©”ì´ì…˜)
```

---

## ğŸŸ¡ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Top 3)

### 1. **Event-Driven Architecture ë„ì…**
í˜„ì¬ ê° ì‹œìŠ¤í…œë§ˆë‹¤ UnityEventë¥¼ ê°œë³„ ì„ ì–¸í•˜ê³  ìˆì–´ ê´€ë¦¬ê°€ ì–´ë ¤ì›€. ì¤‘ì•™ ì§‘ì¤‘ì‹ ì´ë²¤íŠ¸ ë²„ìŠ¤ ë„ì… ê¶Œì¥.

```csharp
public class GameEventBus : Singleton<GameEventBus>
{
    // Health Events
    public UnityEvent<GameObject, float> OnEntityDamaged;
    public UnityEvent<GameObject> OnEntityDeath;
    
    // Combat Events
    public UnityEvent<GameObject, int> OnAttackExecuted;
    public UnityEvent<GameObject, GameObject> OnHitLanded;
}
```

### 2. **ScriptableObject ê¸°ë°˜ ìŠ¤í‚¬ ì‹œìŠ¤í…œ í™•ì¥**
í˜„ì¬ ìŠ¤í‚¬ì´ indexë¡œë§Œ ê´€ë¦¬ë˜ê³  ìˆì–´ í™•ì¥ì„± ì œí•œ. ScriptableObjectë¡œ ì™„ì „í•œ ë°ì´í„° ì£¼ë„ ì„¤ê³„ë¡œ ì „í™˜.

```csharp
[CreateAssetMenu(fileName = "New Skill", menuName = "Skills/Skill")]
public class SkillDefinition : ScriptableObject
{
    public string skillName;
    public string description;
    public Sprite icon;
    public SkillType skillType;
    public List<SkillEffect> effects;
    public AnimationClip animationClip;
}

// ìŠ¤í‚¬ ì‹¤í–‰ì„ ì™„ì „íˆ ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ
public void ExecuteSkill(SkillDefinition skill) { }
```

### 3. **Unit Test ì¸í”„ë¼ êµ¬ì¶•**
í˜„ì¬ í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ ì „í˜€ ì—†ìŒ. Unity Test Frameworkë¥¼ ë„ì…í•˜ì—¬ í•µì‹¬ ë¡œì§ í…ŒìŠ¤íŠ¸.

```csharp
[Test]
public void HealthSystem_TakeDamage_ReducesHealth()
{
    // Arrange
    var healthSystem = CreateTestHealthSystem(maxHealth: 100);
    
    // Act
    healthSystem.TakeDamage(30);
    
    // Assert
    Assert.AreEqual(70, healthSystem.CurrentHealth);
}

[Test]
public void AttackSystem_ExecuteAttack_RespectsCoolddown()
{
    var attackSystem = CreateTestAttackSystem();
    Assert.IsTrue(attackSystem.ExecuteAttack(0, transform, layerMask));
    Assert.IsFalse(attackSystem.ExecuteAttack(0, transform, layerMask)); // ì¿¨ë‹¤ìš´ ì¤‘
}
```

---

## âœ… ì˜í•œ ì  (Best Parts - Top 3)

### 1. **ì²´ê³„ì ì¸ ì•„í‚¤í…ì²˜ ì„¤ê³„** â­â­â­â­â­
FSMê³¼ BehaviorTreeë¥¼ í™œìš©í•œ ìƒíƒœ ê´€ë¦¬ê°€ ë§¤ìš° ì¸ìƒì ì…ë‹ˆë‹¤. íŠ¹íˆ:
- `BehaviorTree.cs`ì˜ Selector/Sequence êµ¬ì¡°ê°€ ëª…í™•
- `EnemyBehavior`ì—ì„œ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í–‰ë™ ì„ íƒì´ ì§ê´€ì 
- ê° Stateë¥¼ ë³„ë„ í´ë˜ìŠ¤ë¡œ ìº¡ìŠí™”í•˜ì—¬ í™•ì¥ì„± í™•ë³´

```csharp
// ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í–‰ë™ ì„ íƒì´ ë§¤ìš° ê¹”ë”
selectorRoot = new SelectorNode(new List<SequenceNode>() {
    sequenceContainer[EnemyBehaviorState.DEATH],      // ìµœìš°ì„ 
    sequenceContainer[EnemyBehaviorState.DAMAGED],
    sequenceContainer[EnemyBehaviorState.DETECTION],
    sequenceContainer[EnemyBehaviorState.CHASE],
    sequenceContainer[EnemyBehaviorState.ATTACK],
    sequenceContainer[EnemyBehaviorState.PATROL],
    sequenceContainer[EnemyBehaviorState.IDLE],       // ìµœí›„ì„ 
}, "Root");
```

### 2. **ObjectPool íŒ¨í„´ì˜ íš¨ìœ¨ì  êµ¬í˜„** â­â­â­â­
ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±ì„ ê³ ë ¤í•œ ObjectPool êµ¬í˜„ì´ í›Œë¥­í•©ë‹ˆë‹¤:
- Genericìœ¼ë¡œ êµ¬í˜„ë˜ì–´ ì¬ì‚¬ìš©ì„± ë†’ìŒ
- AttackSystemì—ì„œ ìŠ¤í‚¬ë³„ Pool ê´€ë¦¬
- Get/Return ì¸í„°í˜ì´ìŠ¤ê°€ ê°„ë‹¨ëª…ë£Œ

```csharp
// ìŠ¤í‚¬ íƒ€ì…ë³„ Poolì„ Dictionaryë¡œ ê´€ë¦¬í•˜ëŠ” ì•„ì´ë””ì–´ ìš°ìˆ˜
poolContainer = new Dictionary<int, ObjectPool<SkillLogic>>();
for (int i=0; i<attackContainer.Count; i++)
{
    if (attackContainer[i].attackType == AttackType.Melee) continue;
    poolContainer[i] = new ObjectPool<SkillLogic>(skillLogic, ObjectPoolSize, goContainer);
}
```

### 3. **Intel OpenVINO í†µí•©ì˜ ë¹„ë™ê¸° ì²˜ë¦¬** â­â­â­â­
Unityì—ì„œ Native AI ëª¨ë¸ì„ í†µí•©í•˜ëŠ” ê²ƒ ìì²´ê°€ ê³ ë‚œì´ë„ ì‘ì—…ì¸ë°, ë¹„ë™ê¸° ì²˜ë¦¬ê¹Œì§€ ê³ ë ¤í•œ ì ì´ í›Œë¥­í•©ë‹ˆë‹¤:
- `ConcurrentQueue`ë¡œ ë©€í‹°ìŠ¤ë ˆë“œ ì•ˆì „ì„± í™•ë³´
- ë©”ì¸ ìŠ¤ë ˆë“œë¡œ ê²°ê³¼ ì „ë‹¬í•˜ëŠ” íŒ¨í„´ì´ ì •ì„ì 
- DLL Importë¥¼ í†µí•œ ë„¤ì´í‹°ë¸Œ ì—°ë™

```csharp
private readonly ConcurrentQueue<Action> _mainThreadActions = new ConcurrentQueue<Action>();

void LateUpdate()
{
    while (_mainThreadActions.TryDequeue(out var action))
    {
        try { action?.Invoke(); }
        catch (Exception e) { Logger.Write($"error: {e}", "ERROR"); }
    }
}
```

---

## ğŸ“Š ê°œì„  ë¡œë“œë§µ ì œì•ˆ

### Phase 1: ì•ˆì •ì„± ê°•í™” (1-2ì£¼)
- [ ] ì „ì²´ ì½”ë“œë² ì´ìŠ¤ Null ì•ˆì •ì„± íŒ¨ì¹˜
- [ ] Input Buffer ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] ì—ëŸ¬ í•¸ë“¤ë§ ê°•í™” (try-catch ì¶”ê°€)

### Phase 2: ë¦¬íŒ©í† ë§ (2-4ì£¼)
- [ ] PlayerBehavior/EnemyBehavior ì±…ì„ ë¶„ë¦¬
- [ ] Magic Number â†’ Constants ë§ˆì´ê·¸ë ˆì´ì…˜
- [ ] XML ë¬¸ì„œí™” ì£¼ì„ ì¶”ê°€

### Phase 3: í™•ì¥ì„± ê°œì„  (4-6ì£¼)
- [ ] Event-Driven Architecture ë„ì…
- [ ] ScriptableObject ê¸°ë°˜ ìŠ¤í‚¬ ì‹œìŠ¤í…œ í™•ì¥
- [ ] Unit Test ì¸í”„ë¼ êµ¬ì¶•

### Phase 4: ìµœì í™” (6-8ì£¼)
- [ ] String allocation ìµœì í™”
- [ ] Update/FixedUpdate ë¶„ë¦¬ ìµœì í™”
- [ ] Profiling ê¸°ë°˜ ë³‘ëª© ì œê±°

---

## ğŸ“ ìµœì¢… ì´í‰

ì´ í”„ë¡œì íŠ¸ëŠ” **ì¤‘ê¸‰~ê³ ê¸‰ ìˆ˜ì¤€ì˜ Unity ê°œë°œ ì—­ëŸ‰**ì„ ë³´ì—¬ì£¼ëŠ” ì½”ë“œë² ì´ìŠ¤ì…ë‹ˆë‹¤. íŠ¹íˆ FSM/BehaviorTreeë¥¼ í™œìš©í•œ ê²Œì„ ë¡œì§ ì„¤ê³„ì™€ Intel OpenVINOë¥¼ í†µí•©í•œ AI ì‹œìŠ¤í…œì€ ë§¤ìš° ì¸ìƒì ì…ë‹ˆë‹¤.

**ì¥ì **:
- ëª…í™•í•œ ì•„í‚¤í…ì²˜ ì„¤ê³„ (FSM/BT)
- ScriptableObject ê¸°ë°˜ ë°ì´í„° êµ¬ì¡°
- ObjectPoolì„ í†µí•œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±
- ë„¤ì´í‹°ë¸Œ AI ëª¨ë¸ í†µí•©

**ê°œì„  í•„ìš”**:
- Null ì•ˆì •ì„± ê°•í™” (í¬ë˜ì‹œ ìœ„í—˜ ì œê±°)
- SRP ì¤€ìˆ˜ (í´ë˜ìŠ¤ ì±…ì„ ë¶„ë¦¬)
- Input Buffer ì‹œìŠ¤í…œ (í”Œë ˆì´ í’ˆì§ˆ í–¥ìƒ)
- í…ŒìŠ¤íŠ¸ ì½”ë“œ ì¶”ê°€

**ê¶Œì¥ ì‚¬í•­**: 
ì¦‰ì‹œ ê°œì„  í•­ëª© 3ê°€ì§€ë¥¼ ìš°ì„  ì²˜ë¦¬í•œ í›„, ì¤‘ì¥ê¸° ë¦¬íŒ©í† ë§ì„ ë‹¨ê³„ì ìœ¼ë¡œ ì§„í–‰í•˜ë©´ ìƒìš© ìˆ˜ì¤€ì˜ ì½”ë“œ í’ˆì§ˆì— ë„ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

**í‰ê°€ì**: GitHub Copilot (Claude Sonnet 4.5)  
**í‰ê°€ ê¸°ì¤€**: Unity C# Code Evaluation Prompt v1.0  
**ì½”ë“œ ë¦¬ë·° ë²”ìœ„**: 56ê°œ C# íŒŒì¼ (Core, Player, Enemy, LLM, APC, Animation, Skills ë“±)
