# ğŸ® Unity C# ì½”ë“œ í’ˆì§ˆ í‰ê°€ ë³´ê³ ì„œ
**í‰ê°€ ë‚ ì§œ**: 2025-12-14 22:04  
**í”„ë¡œì íŠ¸**: project-magic  
**í‰ê°€ ëŒ€ìƒ**: Assets/Scripts ì „ì²´ ì½”ë“œë² ì´ìŠ¤  

---

## ğŸ“Œ 1. Architecture & Unity Component Design

### í‰ê°€: â­â­â­â­â˜† (8/10)

#### âœ… ì˜ëœ ì 

**1. ìš°ìˆ˜í•œ SRP (Single Responsibility Principle) ì¤€ìˆ˜**
```csharp
// Core ì‹œìŠ¤í…œë“¤ì´ ëª…í™•íˆ ë¶„ë¦¬ë¨
AttackSystem      // ê³µê²© ì²˜ë¦¬ ì „ë‹´
HealthSystem      // ì²´ë ¥ ê´€ë¦¬ ì „ë‹´
FSMNode          // í”Œë ˆì´ì–´ ìƒíƒœ ê´€ë¦¬
BTNode           // ì  AI í–‰ë™ íŠ¸ë¦¬
ObjectPool       // ê°ì²´ ì¬ì‚¬ìš© ì „ë‹´
```

**2. Composition over Inheritance ìš°ìˆ˜ ì‚¬ë¡€**
```csharp
public class PlayerBehavior : MonoBehaviour
{
    HealthSystem healthSystem;   // Composition
    AttackSystem attackSystem;   // Composition
    AnimationController animController;
}
```

**3. Unity ìƒëª…ì£¼ê¸° ì ì ˆí•œ í™œìš©**
```csharp
void Awake()    // ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ë° ì°¸ì¡° íšë“
void Start()    // ê°ì²´ í’€, ì´ˆê¸° ìƒíƒœ ì„¤ì •
void FixedUpdate()  // ë¬¼ë¦¬ ê¸°ë°˜ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì…ë ¥ ìŠ¤ëƒ…ìƒ·)
void Update()   // íƒ€ì´ë¨¸ ê°±ì‹  ë° BT í‰ê°€
```

**4. Event-driven Architecture**
```csharp
public UnityEvent<Vector2> EventHit;
public UnityEvent EventDeath;
public UnityEvent<int> EventAttack;

// ëª…í™•í•œ Event ë“±ë¡/í•´ì œ íŒ¨í„´
void OnEnable() => EventLoading();
void OnDisable() => EventUnloading();
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. ScriptableObject ê¸°ë°˜ ë°ì´í„° ë¶„ë¦¬ ë¶€ì¡±**
```csharp
// í˜„ì¬: MonoBehaviourì— ë°ì´í„°ì™€ ë¡œì§ì´ í˜¼ì¬
[SerializeField] float patrolRangeDistance;
[SerializeField] float flipCooldown;
[SerializeField] float hitRecoveryCooldown;

// ê°œì„ ì•ˆ: ScriptableObjectë¡œ ë¶„ë¦¬
[CreateAssetMenu(fileName = "EnemyConfig", menuName = "Config/Enemy")]
public class EnemyConfigSO : ScriptableObject
{
    public float patrolRangeDistance;
    public float flipCooldown;
    public float hitRecoveryCooldown;
    // ëŸ°íƒ€ì„ ì¤‘ ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ ì„¤ì •ê°’ë“¤
}

public class EnemyBehavior : MonoBehaviour
{
    [SerializeField] EnemyConfigSO config;
}
```

**2. DI(Dependency Injection) íŒ¨í„´ ë¶€ì¬**
```csharp
// í˜„ì¬: GetComponent ì˜ì¡´ì„±
void Awake()
{
    stats = GetComponentInChildren<StatsContainer>().stats;
    rb = GetComponentInChildren<Rigidbody2D>();
    healthSystem = GetComponentInChildren<HealthSystem>();
}

// ê°œì„ ì•ˆ: ëª…ì‹œì  ì˜ì¡´ì„± ì£¼ì…
public class PlayerBehavior : MonoBehaviour
{
    [SerializeField] private StatsContainer statsContainer;
    [SerializeField] private Rigidbody2D rb;
    [SerializeField] private HealthSystem healthSystem;
    
    // ë˜ëŠ” Constructor Injection (Zenject/VContainer ì‚¬ìš©)
}
```

**3. Singleton ë‚¨ìš© ê°€ëŠ¥ì„±**
```csharp
// LLMInferenceManager, ContainerControllerê°€ Singleton
// í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€, ê²°í•©ë„ ì¦ê°€ ë¬¸ì œ

// ê°œì„ ì•ˆ: Service Locator ë˜ëŠ” DI Container ë„ì…
public interface ILLMService
{
    void RequestInference(LLMRequest request);
}

public class GameContext
{
    public ILLMService LLMService { get; set; }
    public IContainerService ContainerService { get; set; }
}
```

---

## ğŸ“Œ 2. Code Readability & Maintainability

### í‰ê°€: â­â­â­â­â˜† (8/10)

#### âœ… ì˜ëœ ì 

**1. ë„¤ì´ë° ê·œì¹™ ì¼ê´€ì„± ìš°ìˆ˜**
```csharp
// PascalCase for public
public bool IsAlive { get; }
public UnityEvent EventDeath;

// camelCase for private with underscore
float _moveInput;
bool _jumpInput;
Transform _target;
```

**2. Header/Tooltip í™œìš©**
```csharp
[Header("Stats")]
[SerializeField] float patrolRangeDistance;
[SerializeField] Vector2 wallBoxSize;

[Tooltip("Model artifacts must be in Assets/Models/")]
[SerializeField] string model_id;
```

**3. ëª…í™•í•œ ë©”ì„œë“œ ëª…**
```csharp
void BuildStateController()
void EventLoading()
void EventUnloading()
bool CheckGrounded()
void TickUpdate()
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. XML ì£¼ì„ ë¶€ì¬**
```csharp
// í˜„ì¬: ì£¼ì„ ì—†ìŒ
public abstract class AttackSystem : MonoBehaviour
{
    public virtual bool ExecuteAttack(int attackIndex, Transform origin, LayerMask targetLayerMask)

// ê°œì„ ì•ˆ: XML ë¬¸ì„œí™”
/// <summary>
/// ê³µê²©ì„ ì‹¤í–‰í•˜ê³  ì¿¨ë‹¤ìš´ì„ ì ìš©í•©ë‹ˆë‹¤.
/// </summary>
/// <param name="attackIndex">ì‹¤í–‰í•  ê³µê²©ì˜ ì¸ë±ìŠ¤ (0=ê¸°ë³¸ê³µê²©)</param>
/// <param name="origin">ê³µê²© ë°œìƒ ìœ„ì¹˜ Transform</param>
/// <param name="targetLayerMask">í”¼ê²© ëŒ€ìƒ ë ˆì´ì–´ ë§ˆìŠ¤í¬</param>
/// <returns>ê³µê²© ì„±ê³µ ì—¬ë¶€ (ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ false)</returns>
public virtual bool ExecuteAttack(int attackIndex, Transform origin, LayerMask targetLayerMask)
```

**2. Magic Number ì”ì¡´**
```csharp
// PlayerBehavior.cs
origin.y += 0.2f;  // âŒ ì˜ë¯¸ ë¶ˆëª…í™•
RaycastHit2D hitArea = Physics2D.CircleCast(origin, 0.2f, direction, ...);

// ê°œì„ ì•ˆ
private const float DETECTION_RADIUS = 0.2f;
private const float Y_OFFSET_DETECTION = 0.2f;

origin.y += Y_OFFSET_DETECTION;
RaycastHit2D hitArea = Physics2D.CircleCast(origin, DETECTION_RADIUS, ...);
```

**3. ê¸´ ë©”ì„œë“œ ë¶„í•´ í•„ìš”**
```csharp
// EnemyBehavior.BuildStateController() - 140+ ë¼ì¸
void BuildStateController()
{
    sequenceContainer = new Dictionary<EnemyBehaviorState, SequenceNode>();
    sequenceContainer[EnemyBehaviorState.DEATH] = new SequenceNode(...);
    sequenceContainer[EnemyBehaviorState.DAMAGED] = new SequenceNode(...);
    // ... ë§ì€ ì½”ë“œ
}

// ê°œì„ ì•ˆ: Factory íŒ¨í„´ ì ìš©
class BehaviorTreeFactory
{
    public SequenceNode CreateDeathSequence(EnemyBehavior ctx) { ... }
    public SequenceNode CreateDamagedSequence(EnemyBehavior ctx) { ... }
}

void BuildStateController()
{
    var factory = new BehaviorTreeFactory();
    sequenceContainer[EnemyBehaviorState.DEATH] = factory.CreateDeathSequence(this);
    sequenceContainer[EnemyBehaviorState.DAMAGED] = factory.CreateDamagedSequence(this);
}
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

### í‰ê°€: â­â­â­â­â­ (9/10)

#### âœ… ì˜ëœ ì 

**1. ì…ë ¥ ìŠ¤ëƒ…ìƒ· íŒ¨í„´ìœ¼ë¡œ FixedUpdate ìµœì í™”**
```csharp
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput;  // Updateì—ì„œ ë³€ê²½ëœ ê°’ ê³ ì •
    _snapShotjumpInput = _jumpInput ? 1.0f : 0.0f;
    UpdateYState();
    UpdateXState();
}
```
â†’ **Updateì™€ FixedUpdate ê°„ íƒ€ì´ë° ì´ìŠˆ ë°©ì§€**

**2. Object Pooling ì™„ë²½ êµ¬í˜„**
```csharp
public class ObjectPool<T> where T : MonoBehaviour
{
    private readonly Queue<T> pool;
    
    public T Get()
    {
        if (pool.Count > 0)
            return pool.Dequeue();
        else
            return GameObject.Instantiate(prefab, ...);
    }
    
    public void Return(T obj)
    {
        pool.Enqueue(obj);
    }
}
```
â†’ **Projectile, VFX GC ì••ë ¥ ëŒ€í­ ê°ì†Œ**

**3. GetComponent ìºì‹± ì™„ë²½**
```csharp
void Awake()
{
    stats = GetComponentInChildren<StatsContainer>().stats;  // í•œ ë²ˆë§Œ í˜¸ì¶œ
    rb = GetComponentInChildren<Rigidbody2D>();
    healthSystem = GetComponentInChildren<HealthSystem>();
}
```

**4. ë¶ˆí•„ìš”í•œ Allocation ìµœì†Œí™”**
```csharp
// LINQ ì‚¬ìš© ì—†ìŒ âœ…
// foreach ì‚¬ìš© (yield return ì—†ìŒ) âœ…
// Dictionary/Queue ì ì ˆíˆ í™œìš© âœ…
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. ë§¤ í”„ë ˆì„ Logger í˜¸ì¶œ**
```csharp
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");  // âŒ ë§¤ í”„ë ˆì„!
}

// ê°œì„ ì•ˆ: ì¡°ê±´ë¶€ ë¡œê¹… + ë¹Œë“œ ì œê±°
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    #if UNITY_EDITOR
    if (Logger.DEBUG && Logger.IsVerbose)
        Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
    #endif
}
```

**2. string concatenation ìµœì í™” ì—¬ì§€**
```csharp
// AttackSystem.cs
Logger.Write($"Invalid attack index: {attackIndex}", "ERROR");  // âœ… ê´œì°®ìŒ

// í•˜ì§€ë§Œ ë§¤ í”„ë ˆì„ í˜¸ì¶œ ì‹œ
string actionName = this.GetType().ToString();  // âŒ ë§¤ë²ˆ allocation

// ê°œì„ ì•ˆ: ìºì‹±
class ActionNode
{
    protected readonly string cachedTypeName;
    
    protected ActionNode()
    {
        cachedTypeName = this.GetType().Name;
    }
}
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

### í‰ê°€: â­â­â­â­â˜† (8/10)

#### âœ… ì˜ëœ ì 

**1. ì…ë ¥ ë²„í¼ë§ìœ¼ë¡œ ë°˜ì‘ì„± í–¥ìƒ**
```csharp
Queue<PlayerState> bufferXState = new Queue<PlayerState>();

void ListenerAttack(int attackIndex)
{
    bufferXState.Enqueue(PlayerState.ATTACK);  // ë²„í¼ì— ì €ì¥
}

void UpdateXState()
{
    while (bufferXState.Count > 0)  // ìš°ì„  ì²˜ë¦¬
    {
        var newState = bufferXState.Dequeue();
        ChangeState(ref currentXState, newState);
    }
}
```

**2. ì¿¨ë‹¤ìš´ ê¸°ë°˜ ê³µê²© ë°©ì–´**
```csharp
public virtual bool ExecuteAttack(int attackIndex, ...)
{
    if (!attack.CheckTimer())  // âœ… ì¿¨ë‹¤ìš´ ê²€ì¦
    {
        Logger.Write($"Attack on cooldown: {attack.cooldownTimer:F2}s remaining");
        return false;
    }
}
```

**3. ë¬´ì  ì‹œê°„ êµ¬í˜„**
```csharp
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
{
    if (invincibleTimer > 0 || currentHealth <= 0) return;  // âœ… ì¤‘ë³µ í”¼ê²© ë°©ì§€
}
```

**4. Ground Check ì•ˆì •ì„±**
```csharp
bool CheckGrounded()
{
    return colliderGround.IsTouchingLayers(layerGround.value);
}

// Y State ì „í™˜
if ((rb.linearVelocity.y <= (Mathf.Epsilon + landingVelocityMargin)) && CheckGrounded())
    ChangeState(ref currentYState, PlayerState.ReadyToJump);
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Null Reference ë°©ì–´ ë¶€ì¡±**
```csharp
// AttackSystem.cs
protected virtual void Awake()
{
    stats = GetComponentInChildren<StatsContainer>().stats;  // âŒ null ì²´í¬ ì—†ìŒ
}

// ê°œì„ ì•ˆ
protected virtual void Awake()
{
    var container = GetComponentInChildren<StatsContainer>();
    if (container == null)
    {
        Logger.Write($"StatsContainer not found on {gameObject.name}", "ERROR");
        enabled = false;
        return;
    }
    stats = container.stats;
}
```

**2. Attack ì¤‘ ì´ë™ ì œí•œ ë¡œì§ ê°œì„  í•„ìš”**
```csharp
// í˜„ì¬: Attack Stateì¼ ë•Œë„ Move State Updateê°€ í˜¸ì¶œë¨
void UpdateXState()
{
    // ... state transition logic
    stateContainer[currentXState].Update();  // StateAttack.Update()ëŠ” ë¹„ì–´ìˆìŒ
}

// ë¬¸ì œ: StateMove.Update()ê°€ Yì¶• ìƒíƒœì—ì„œ ê³„ì† í˜¸ì¶œë˜ì–´ ë¯¸ì„¸í•œ ë–¨ë¦¼ ê°€ëŠ¥

// ê°œì„ ì•ˆ: StateAttackì—ì„œ ì´ë™ ëª…ì‹œì  ì°¨ë‹¨
class StateAttack : FSMNode
{
    public override void Update()
    {
        ctx.rb.linearVelocity = new Vector2(0, ctx.rb.linearVelocity.y);  // Xì¶• ê³ ì •
    }
}
```

**3. Edge Case - ë™ì‹œ ìƒíƒœ ì „ì´**
```csharp
void ListenerHit(Vector2 knockback)
{
    if (_hitRecoveryTimer > 0) return;
    _hitForce = knockback;
    bufferXState.Enqueue(PlayerState.DAMAGED);  // âŒ ê³µê²© ì¤‘ í”¼ê²© ì‹œ?
}

// ê°œì„ ì•ˆ: ìš°ì„ ìˆœìœ„ ëª…í™•í™”
void UpdateXState()
{
    // ìš°ì„ ìˆœìœ„: DEATH > DAMAGED > ATTACK > MOVE > IDLE
    if (bufferXState.Contains(PlayerState.DEATH))
    {
        bufferXState.Clear();
        bufferXState.Enqueue(PlayerState.DEATH);
    }
}
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

### í‰ê°€: â­â­â­â­â­ (9/10)

#### âœ… ì˜ëœ ì 

**1. SerializeField + Header/Tooltip ì™„ë²½ í™œìš©**
```csharp
[Header("Stats")]
[SerializeField] float patrolRangeDistance;
[SerializeField] LayerMask layerGround;
[SerializeField] LayerMask layerPlayer;

[Tooltip("Only supported device; CPU")]
[SerializeField] string device = "CPU";
```

**2. Time.deltaTime ë³´ì • ì¼ê´€ì„±**
```csharp
void TickUpdate()
{
    if (_flipTimer > 0) _flipTimer -= Time.deltaTime;
    if (_hitRecoveryTimer > 0) _hitRecoveryTimer -= Time.deltaTime;
}

attack.UpdateTimer(Time.deltaTime);
```

**3. Physicsì™€ Transform ë¶„ë¦¬ ìš°ìˆ˜**
```csharp
// Rigidbody ê¸°ë°˜ ì´ë™ (FixedUpdate)
rb.linearVelocity = new Vector2(xVel, rb.linearVelocity.y);

// AddForce ì‚¬ìš© (ë¬¼ë¦¬ ê¸°ë°˜)
rb.AddForce(ctx._hitForce, ForceMode2D.Impulse);
```

**4. Magic Number ì œê±° - Constant í™œìš©**
```csharp
// Constants í´ë”ì— ì²´ê³„ì  ê´€ë¦¬ ì¶”ì •
// LayerName enum, ContainerName enum ì‚¬ìš© í™•ì¸
colliders.layer = LayerMask.NameToLayer(LayerName.Corpse.ToString());
```

**5. Gizmosë¥¼ í†µí•œ ë””ë²„ê¹… ì§€ì›**
```csharp
#if UNITY_EDITOR
void OnDrawGizmosSelected()
{
    float direction = -Mathf.Sign(transform.localScale.x);
    Vector3 pos = transform.position;
    pos.y += YPosAdjust;
    pos.x += direction * attackRange;
    Gizmos.color = Color.red;
    Gizmos.DrawWireSphere(pos, hitAreaRadius);
}
#endif
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Property ì‚¬ìš© í™•ëŒ€ ì—¬ì§€**
```csharp
// í˜„ì¬: field + get property í˜¼ì¬
public bool IsAlive => currentHealth > 0;  // âœ… ì¢‹ìŒ
protected float currentHealth;  // ì§ì ‘ ì ‘ê·¼ ê°€ëŠ¥

// ê°œì„ ì•ˆ: backing field íŒ¨í„´
private float _currentHealth;
public float CurrentHealth 
{ 
    get => _currentHealth;
    private set => _currentHealth = Mathf.Max(0, value);
}
```

**2. Component Reference Validation**
```csharp
// ê°œì„ ì•ˆ: RequireComponent ì†ì„± ì¶”ê°€
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(AnimationController))]
public class PlayerBehavior : MonoBehaviour
{
    // ...
}
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

### í‰ê°€: â­â­â­â­â­ (10/10)

#### âœ… ì˜ëœ ì  - ê±°ì˜ ì™„ë²½í•œ êµ¬í˜„

**1. FSM ì™„ë²½í•œ êµ¬ì¡°**
```csharp
public abstract class FSMNode
{
    public abstract void OnEnter();
    public abstract void Update();
    public abstract void OnExit();
}

// Xì¶•, Yì¶• ë…ë¦½ FSM
PlayerState currentXState;  // IDLE, MOVE, ATTACK, DAMAGED, DEATH
PlayerState currentYState;  // ReadyToJump, InFlight

// ìš°ì•„í•œ ìƒíƒœ ì „í™˜
void ChangeState(ref PlayerState currentState, PlayerState newState)
{
    if (currentState == newState) return;
    stateContainer[currentState].OnExit();
    currentState = newState;
    stateContainer[currentState].OnEnter();
}
```

**2. Behavior Tree ì™„ë²½í•œ ìš°ì„ ìˆœìœ„ êµ¬ì¡°**
```csharp
selectorRoot = new SelectorNode(
    new List<SequenceNode>()
    {
        sequenceContainer[EnemyBehaviorState.DEATH],     // ìµœìš°ì„ 
        sequenceContainer[EnemyBehaviorState.DAMAGED],   // 2ìˆœìœ„
        sequenceContainer[EnemyBehaviorState.DETECTION], // 3ìˆœìœ„
        sequenceContainer[EnemyBehaviorState.CHASE],
        sequenceContainer[EnemyBehaviorState.ATTACK],
        sequenceContainer[EnemyBehaviorState.PATROL],
        sequenceContainer[EnemyBehaviorState.IDLE],      // ê¸°ë³¸
    }
);
```
â†’ **ëª…í™•í•œ í–‰ë™ ìš°ì„ ìˆœìœ„, í™•ì¥ì„± ìš°ìˆ˜**

**3. Animationê³¼ Code ì™„ë²½ ë™ê¸°í™”**
```csharp
// ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê¸°ë°˜ íƒ€ì´ë¨¸ ì„¤ì •
var clipTime = ctx.animController.PlayStateAnimation(PlayerState.ATTACK, rebind: true);
ctx._attackRecoveryTimer = clipTime;

// íƒ€ì´ë¨¸ ì™„ë£Œ í›„ ìƒíƒœ ì „í™˜
case PlayerState.ATTACK:
    if (_attackRecoveryTimer <= 0)
        ChangeState(ref currentXState, PlayerState.IDLE);
    break;
```

**4. Attack ì¤‘ ì´ë™ ì™„ë²½ ì°¨ë‹¨**
```csharp
// ATTACK ìƒíƒœì¼ ë•ŒëŠ” IDLEë¡œ ì§í–‰, MOVE ì§„ì… ë¶ˆê°€
case PlayerState.ATTACK:
    if (_attackRecoveryTimer <= 0)
        ChangeState(ref currentXState, PlayerState.IDLE);  // âœ…
    break;

case PlayerState.IDLE:
    if (Mathf.Abs(_snapShotMoveInput) > Mathf.Epsilon)
        ChangeState(ref currentXState, PlayerState.MOVE);  // ATTACK ì¤‘ì—” ì—¬ê¸° ì•ˆ ì˜´
    break;
```

**5. Event-driven Architecture ì™„ë²½**
```csharp
// UnityEvent ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©
healthSystem.EventHit.AddListener(ListenerHit);
attackSystem.EventAttack.AddListener(ListenerAttack);

// ì´ë²¤íŠ¸ ë°œìƒ ì‹œ ë²„í¼ì— ì €ì¥
void ListenerAttack(int attackIndex)
{
    if (_attackRecoveryTimer > 0) return;
    bufferXState.Enqueue(PlayerState.ATTACK);  // ë‹¤ìŒ í”„ë ˆì„ì— ì²˜ë¦¬
}
```

#### ğŸ’¡ ì¶”ê°€ ê°œì„  ì œì•ˆ

**1. State Patternìœ¼ë¡œ ì „í™˜ ê³ ë ¤**
```csharp
// í˜„ì¬ ë°©ì‹ë„ í›Œë¥­í•˜ì§€ë§Œ, ë” í™•ì¥ì„± ìˆëŠ” State Pattern
public interface IPlayerState
{
    void OnEnter(PlayerBehavior ctx);
    void Update(PlayerBehavior ctx);
    void OnExit(PlayerBehavior ctx);
    bool CanTransitionTo(IPlayerState newState);
}

public class AttackState : IPlayerState
{
    public bool CanTransitionTo(IPlayerState newState)
    {
        // ATTACK -> MOVE ì „í™˜ ì°¨ë‹¨ ëª…ì‹œí™”
        return newState is not MoveState;
    }
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

### í‰ê°€: â­â­â­â˜†â˜† (6/10)

#### âœ… ì˜ëœ ì 

**1. TryGetComponent í™œìš©**
```csharp
if (other.TryGetComponent<HealthSystem>(out HealthSystem targetHealthSystem))
{
    if (!targetHealthSystem.IsAlive) return;
    ApplyAttack(attack, ...);
}
```

**2. IsAlive ê²€ì¦**
```csharp
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
{
    if (invincibleTimer > 0 || currentHealth <= 0) return;  // âœ…
}
```

**3. Boundary Check**
```csharp
if (attackIndex >= attackContainer.Count)
{
    Logger.Write($"Invalid attack index: {attackIndex}", "ERROR");
    return false;
}
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Null Reference ë°©ì–´ ë¶€ì¡±**
```csharp
// LLMInferenceManager.cs
_pipeline = OV_LoadModel(modelPath, device);
if (_pipeline == IntPtr.Zero)
{
    Logger.Write("failed to load model", "ERROR");  // âŒ ê·¸ëƒ¥ ë¡œê·¸ë§Œ ì°ìŒ
}
// ì´í›„ _pipeline ì‚¬ìš© ì‹œ í¬ë˜ì‹œ ê°€ëŠ¥

// ê°œì„ ì•ˆ
if (_pipeline == IntPtr.Zero)
{
    Logger.Write("failed to load model", "ERROR");
    enabled = false;  // ì»´í¬ë„ŒíŠ¸ ë¹„í™œì„±í™”
    return;
}
```

**2. GetComponent ì‹¤íŒ¨ ì²˜ë¦¬ ì—†ìŒ**
```csharp
void Awake()
{
    stats = GetComponentInChildren<StatsContainer>().stats;  // âŒ null ê°€ëŠ¥
    rb = GetComponentInChildren<Rigidbody2D>();  // âŒ null ê°€ëŠ¥
}

// ê°œì„ ì•ˆ
void Awake()
{
    if (!TryGetComponentInChildren<StatsContainer>(out var container))
    {
        Logger.Write($"StatsContainer missing on {name}", "ERROR");
        enabled = false;
        return;
    }
    stats = container.stats;
}
```

**3. Array Index ê²€ì¦ ê°•í™”**
```csharp
// AttackSystem.cs
if (attackIndex >= attackContainer.Count)  // âœ… ìƒí•œ ì²´í¬
{
    return false;
}

// ê°œì„ ì•ˆ: í•˜í•œ ì²´í¬ ì¶”ê°€
if (attackIndex < 0 || attackIndex >= attackContainer.Count)
{
    Logger.Write($"Attack index out of range: {attackIndex}", "ERROR");
    return false;
}
```

**4. Exception Handling ë¶€ì¬**
```csharp
// LLMWorkerThread ë“±ì—ì„œ Exception ì²˜ë¦¬ í•„ìš”
public void RequestInference(LLMRequest request)
{
    _requestQueue.Enqueue(request);  // âŒ Queue ì˜¤ë¥˜ ì‹œ?
}

// ê°œì„ ì•ˆ
public void RequestInference(LLMRequest request)
{
    try
    {
        if (request == null)
        {
            Logger.Write("Null request", "ERROR");
            return;
        }
        _requestQueue.Enqueue(request);
    }
    catch (Exception e)
    {
        Logger.Write($"Failed to enqueue request: {e.Message}", "ERROR");
    }
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

### í‰ê°€: â­â­â­â­â˜† (8/10)

#### âœ… ì˜ëœ ì 

**1. Abstract Class ê¸°ë°˜ í™•ì¥ì„±**
```csharp
public abstract class AttackSystem : MonoBehaviour
public abstract class HealthSystem : MonoBehaviour
public abstract class FSMNode

// êµ¬í˜„ì²´
public class PlayerAttack : AttackSystem
public class EnemyAttack : AttackSystem
public class PlayerHealth : HealthSystem
public class EnemyHealth : HealthSystem
```

**2. ScriptableObject ë°ì´í„° ë¶„ë¦¬**
```csharp
// CharacterStats, SkillData ë“±ì´ SOë¡œ ê´€ë¦¬ë¨ (ì¶”ì •)
stats = GetComponentInChildren<StatsContainer>().stats;

// ìŠ¤í‚¬ ë°°ì—´ë¡œ í™•ì¥ ê°€ëŠ¥
for(int i = 0; i < stats.skillDatas.Length; i++)
{
    var skill = stats.skillDatas[i];
    attackContainer.Add(new AttackContainer(...));
}
```

**3. Behavior Tree í™•ì¥ ìš©ì´**
```csharp
// ìƒˆë¡œìš´ í–‰ë™ ì¶”ê°€ ì‹œ
sequenceContainer[EnemyBehaviorState.NEW_BEHAVIOR] = new SequenceNode(
    new List<ActionNode> { new ActionNewBehavior(this) }
);

// SelectorNodeì— ì¶”ê°€ë§Œ í•˜ë©´ ë¨
selectorRoot = new SelectorNode(
    new List<SequenceNode>() {
        // ... ê¸°ì¡´ í–‰ë™ë“¤
        sequenceContainer[EnemyBehaviorState.NEW_BEHAVIOR],
    }
);
```

**4. Object Pool ì œë„¤ë¦­ êµ¬í˜„**
```csharp
public class ObjectPool<T> where T : MonoBehaviour  // âœ… ëª¨ë“  íƒ€ì… ì¬ì‚¬ìš© ê°€ëŠ¥
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Hard-coded Attack Index**
```csharp
// PlayerBehavior.cs
public void OnAttack(InputValue value)
{
    _attackRes = attackSystem.ExecuteAttack(0, this.transform, layerEnemy);  // âŒ 0 = ê¸°ë³¸ê³µê²©
}

public void OnSkillW(InputValue value)
{
    _attackRes = attackSystem.ExecuteAttack(1, this.transform, layerEnemy);  // âŒ 1 = WìŠ¤í‚¬
}

// ê°œì„ ì•ˆ: Enum ë˜ëŠ” ScriptableObject ê¸°ë°˜
public enum AttackSlot { BasicAttack, SkillW, SkillE, Ultimate }

public void OnAttack(InputValue value)
{
    _attackRes = attackSystem.ExecuteAttack(AttackSlot.BasicAttack, ...);
}
```

**2. ìºë¦­í„° ì¦ê°€ ì‹œ ì¤‘ë³µ ì½”ë“œ**
```csharp
// PlayerBehavior, EnemyBehavior, BossAlphaBehavior ëª¨ë‘ ìœ ì‚¬í•œ êµ¬ì¡°
// ê³µí†µ BaseCharacterBehavior ì¶”ì¶œ ê³ ë ¤

public abstract class BaseCharacterBehavior : MonoBehaviour
{
    protected CharacterStats stats;
    protected Rigidbody2D rb;
    protected HealthSystem healthSystem;
    protected AttackSystem attackSystem;
    
    protected virtual void Awake()
    {
        // ê³µí†µ ì´ˆê¸°í™” ë¡œì§
    }
    
    protected abstract void BuildStateController();
}

public class PlayerBehavior : BaseCharacterBehavior { }
public class EnemyBehavior : BaseCharacterBehavior { }
```

**3. Event System í™•ì¥ì„±**
```csharp
// í˜„ì¬: UnityEvent<T> ì‚¬ìš©
public UnityEvent<int> EventAttack;

// ê°œì„ ì•ˆ: Custom Event System (ë” ë§ì€ ì •ë³´ ì „ë‹¬)
public class AttackEventArgs
{
    public int AttackIndex { get; set; }
    public float Damage { get; set; }
    public Vector2 HitPoint { get; set; }
    public bool IsCritical { get; set; }
}

public UnityEvent<AttackEventArgs> EventAttack;
```

---

## ğŸ“Œ 9. Clean Code Practices

### í‰ê°€: â­â­â­â­â˜† (8/10)

#### âœ… ì˜ëœ ì 

**1. SOLID ì›ì¹™ ì¤€ìˆ˜**

**SRP (Single Responsibility)** âœ…
```csharp
AttackSystem  // ê³µê²©ë§Œ
HealthSystem  // ì²´ë ¥ë§Œ
ObjectPool    // í’€ë§ë§Œ
```

**OCP (Open/Closed)** âœ…
```csharp
public abstract class FSMNode { }
// í™•ì¥ì— ì—´ë ¤ìˆê³ , ìˆ˜ì •ì— ë‹«í˜€ìˆìŒ
class StateMove : FSMNode { }
class StateAttack : FSMNode { }
```

**LSP (Liskov Substitution)** âœ…
```csharp
HealthSystem healthSystem;
healthSystem = GetComponentInChildren<PlayerHealth>();  // âœ… ì¹˜í™˜ ê°€ëŠ¥
healthSystem = GetComponentInChildren<EnemyHealth>();   // âœ… ì¹˜í™˜ ê°€ëŠ¥
```

**ISP (Interface Segregation)** âœ…
```csharp
public abstract class FSMNode
{
    public abstract void OnEnter();
    public abstract void Update();
    public abstract void OnExit();
} // ìµœì†Œí•œì˜ ì¸í„°í˜ì´ìŠ¤
```

**DIP (Dependency Inversion)** âš ï¸
```csharp
// êµ¬ì²´ í´ë˜ìŠ¤ì— ì˜ì¡´ (ê°œì„  í•„ìš”)
HealthSystem healthSystem;  // ì¶”ìƒ í´ë˜ìŠ¤ì§€ë§Œ ì¸í„°í˜ì´ìŠ¤ ì•„ë‹˜
```

**2. DRY (Don't Repeat Yourself)** âœ…
```csharp
// ê³µí†µ ë¡œì§ì„ Core ì‹œìŠ¤í…œìœ¼ë¡œ ì¶”ìƒí™”
public abstract class AttackSystem : MonoBehaviour
{
    protected virtual void ExecuteMeleeAttack(...)  // ê³µí†µ ê·¼ì ‘ ê³µê²© ë¡œì§
    {
        // ...
    }
}
```

**3. KISS (Keep It Simple)** âœ…
```csharp
bool CheckGrounded()
{
    return colliderGround.IsTouchingLayers(layerGround.value);  // ê°„ê²°
}
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Namespace ë¶€ì¬**
```csharp
// í˜„ì¬: ì „ì—­ ë„¤ì„ìŠ¤í˜ì´ìŠ¤
public class PlayerBehavior : MonoBehaviour { }
public class EnemyBehavior : MonoBehaviour { }

// ê°œì„ ì•ˆ
namespace ProjectMagic.Player
{
    public class PlayerBehavior : MonoBehaviour { }
    public class PlayerAttack : AttackSystem { }
}

namespace ProjectMagic.Enemy
{
    public class EnemyBehavior : MonoBehaviour { }
    public class EnemyAttack : AttackSystem { }
}

namespace ProjectMagic.Core
{
    public abstract class FSMNode { }
    public interface BTNode { }
}
```

**2. Interface ë¶€ì¬**
```csharp
// í˜„ì¬: abstract classë§Œ ì‚¬ìš©
public abstract class HealthSystem : MonoBehaviour { }

// ê°œì„ ì•ˆ: ì¸í„°í˜ì´ìŠ¤ ë„ì…
public interface IHealth
{
    float MaxHealth { get; }
    float CurrentHealth { get; }
    bool IsAlive { get; }
}

public interface IDamageable
{
    void TakeDamage(float damage, Vector2 knockback);
}

public abstract class HealthSystem : MonoBehaviour, IHealth, IDamageable
{
    public float MaxHealth => stats.maxHealth;
    public float CurrentHealth => currentHealth;
    public bool IsAlive => currentHealth > 0;
    
    public virtual void TakeDamage(float damage, Vector2 knockback) { }
}
```

**3. í´ë” êµ¬ì¡° ê°œì„ **
```
í˜„ì¬:
Assets/Scripts/
  â”œâ”€ Player/
  â”œâ”€ Enemy/
  â”œâ”€ Core/
  â”œâ”€ Skills/
  â””â”€ LLM/

ê°œì„ ì•ˆ:
Assets/Scripts/
  â”œâ”€ Core/
  â”‚   â”œâ”€ Interfaces/      (IHealth, IDamageable, IAttacker)
  â”‚   â”œâ”€ Systems/         (FSM, BT, AttackSystem, HealthSystem)
  â”‚   â””â”€ Utilities/       (ObjectPool, Logger)
  â”œâ”€ Characters/
  â”‚   â”œâ”€ Player/
  â”‚   â”œâ”€ Enemy/
  â”‚   â””â”€ Boss/
  â”œâ”€ Combat/
  â”‚   â”œâ”€ Skills/
  â”‚   â””â”€ Attacks/
  â””â”€ AI/
      â”œâ”€ LLM/
      â””â”€ BehaviorTree/
```

---

## ğŸ“Œ 10. Intel OpenVINO ê¸°ë°˜ AI ëª¨ë¸ ì¶”ë¡  í”„ë¡œì„¸ìŠ¤

### í‰ê°€: â­â­â­â­â˜† (8/10)

#### âœ… ì˜ëœ ì 

**1. Thread-safe ë¹„ë™ê¸° ì²˜ë¦¬**
```csharp
private readonly ConcurrentQueue<Action> _mainThreadActions = new ConcurrentQueue<Action>();

void Update()
{
    // ì›Œì»¤ ìŠ¤ë ˆë“œ ê²°ê³¼ë¥¼ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
    while (_mainThreadActions.TryDequeue(out var action))
    {
        try
        {
            action?.Invoke();
        }
        catch (Exception e)
        {
            Debug.LogException(e);
        }
    }
}
```
â†’ **Unity ë©”ì¸ ìŠ¤ë ˆë“œ ì œì•½ ì™„ë²½ í•´ê²°**

**2. DLL ê²½ë¡œ ëª…ì‹œì  ì„¤ì •**
```csharp
[DllImport("kernel32", CharSet = CharSet.Unicode)]
public static extern bool SetDllDirectory(string lpPathName);

string dllDir = Application.dataPath + "/Plugins/x86_64";
SetDllDirectory(dllDir);
```
â†’ **ë°°í¬ í™˜ê²½ ì•ˆì •ì„± í™•ë³´**

**3. Native ë¦¬ì†ŒìŠ¤ ì •ë¦¬**
```csharp
void OnDestroy()
{
    _worker?.Stop();
    if (_pipeline != IntPtr.Zero)
    {
        OV_Release(_pipeline);
        _pipeline = IntPtr.Zero;
    }
}
```

**4. ìš”ì²­-ì‘ë‹µ íŒ¨í„´**
```csharp
public void RequestInference(LLMRequest request) 
    => _requestQueue.Enqueue(request);

public void OnWorkerCompleted(LLMRequest request, LLMOutput output)
{
    var response = new LLMResponse(request, output);
    request.onCompleted?.Invoke(response);
}
```

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ í›„ì† ì²˜ë¦¬ ë¶€ì¡±**
```csharp
void InitModel()
{
    _pipeline = OV_LoadModel(modelPath, device);
    if (_pipeline == IntPtr.Zero)
    {
        Logger.Write("failed to load model", "ERROR");  // âŒ ê³„ì† ì§„í–‰
    }
}

// ê°œì„ ì•ˆ: ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ ì•ˆì „ ëª¨ë“œ
void InitModel()
{
    _pipeline = OV_LoadModel(modelPath, device);
    if (_pipeline == IntPtr.Zero)
    {
        Logger.Write("failed to load model", "ERROR");
        _isModelLoaded = false;
        return;
    }
    _isModelLoaded = true;
}

public void RequestInference(LLMRequest request)
{
    if (!_isModelLoaded)
    {
        Logger.Write("Model not loaded, using fallback", "WARNING");
        // Fallback ë¡œì§ (rule-based AI ë“±)
        return;
    }
    _requestQueue.Enqueue(request);
}
```

**2. Exception Handling ê°•í™”**
```csharp
void Update()
{
    while (_mainThreadActions.TryDequeue(out var action))
    {
        try
        {
            action?.Invoke();
        }
        catch (Exception e)
        {
            Debug.LogException(e);  // âœ… ìˆìŒ
        }
    }
}

// ê°œì„ ì•ˆ: ë” ìƒì„¸í•œ ì—ëŸ¬ ì²˜ë¦¬
void Update()
{
    while (_mainThreadActions.TryDequeue(out var action))
    {
        try
        {
            action?.Invoke();
        }
        catch (NullReferenceException e)
        {
            Logger.Write($"Null action in queue: {e.Message}", "ERROR");
        }
        catch (Exception e)
        {
            Logger.Write($"Unexpected error in LLM callback: {e}", "ERROR");
            // í¬ë¦¬í‹°ì»¬ ì—ëŸ¬ ì‹œ ì›Œì»¤ ì¬ì‹œì‘?
        }
    }
}
```

**3. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥ì„±**
```csharp
// ConcurrentQueue ë¬´í•œ ì¦ê°€ ë°©ì§€ í•„ìš”
private readonly ConcurrentQueue<Action> _mainThreadActions = new ConcurrentQueue<Action>();

// ê°œì„ ì•ˆ: ìµœëŒ€ í í¬ê¸° ì œí•œ
private const int MAX_QUEUE_SIZE = 100;

void Update()
{
    if (_mainThreadActions.Count > MAX_QUEUE_SIZE)
    {
        Logger.Write($"Main thread action queue overflow: {_mainThreadActions.Count}", "WARNING");
        _mainThreadActions.Clear();  // ë˜ëŠ” ì˜¤ë˜ëœ ì‘ì—… ì œê±°
    }
    // ...
}
```

---

## ğŸ“Š ì¢…í•© í‰ê°€ (100ì  ë§Œì )

| í‰ê°€ í•­ëª© | ì ìˆ˜ | ê°€ì¤‘ì¹˜ | í™˜ì‚° ì ìˆ˜ |
|---------|------|--------|----------|
| 1. Architecture & Unity Component Design | 8/10 | 15% | 12.0 |
| 2. Code Readability & Maintainability | 8/10 | 10% | 8.0 |
| 3. Performance & Memory Efficiency | 9/10 | 15% | 13.5 |
| 4. Gameplay Logic & Stability | 8/10 | 10% | 8.0 |
| 5. Unity-Engine Best Practices | 9/10 | 10% | 9.0 |
| 6. Animation, FSM/BT, Event Flow | 10/10 | 15% | 15.0 |
| 7. Safety & Error Handling | 6/10 | 5% | 3.0 |
| 8. Scalability / Extensibility | 8/10 | 10% | 8.0 |
| 9. Clean Code Practices | 8/10 | 5% | 4.0 |
| 10. Intel OpenVINO AI í†µí•© | 8/10 | 5% | 4.0 |
| **ì´ì ** | **- -** | **100%** | **84.5 / 100** |

### ğŸ“ˆ ì´í‰

ì´ í”„ë¡œì íŠ¸ëŠ” **Unity C# ê°œë°œ Best Practiceë¥¼ ë§¤ìš° ë†’ì€ ìˆ˜ì¤€ìœ¼ë¡œ êµ¬í˜„**í•˜ê³  ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ ë‹¤ìŒ ì˜ì—­ì—ì„œ íƒì›”í•©ë‹ˆë‹¤:

1. **FSM/BT ì•„í‚¤í…ì²˜**: í”Œë ˆì´ì–´ì™€ ì  AIì˜ ìƒíƒœ ê´€ë¦¬ê°€ êµê³¼ì„œì ìœ¼ë¡œ ì™„ë²½í•©ë‹ˆë‹¤.
2. **Performance ìµœì í™”**: Object Pooling, GetComponent ìºì‹±, ì…ë ¥ ìŠ¤ëƒ…ìƒ· ë“± ëª¨ë“  ìµœì í™” ê¸°ë²•ì´ ì ìš©ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
3. **Event-driven êµ¬ì¡°**: UnityEvent ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©ìœ¼ë¡œ ìœ ì§€ë³´ìˆ˜ì„±ì´ ë†’ìŠµë‹ˆë‹¤.
4. **LLM í†µí•©**: Unityì—ì„œ Native C++ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì˜ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

ë‹¤ë§Œ, **ì•ˆì „ì„±(Safety & Error Handling)** ì˜ì—­ì—ì„œ ê°œì„ ì´ í•„ìš”í•˜ë©°, Namespace/Interface ë„ì…ìœ¼ë¡œ **Clean Code** ì ìˆ˜ë¥¼ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

## ğŸš¨ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (Top 3)

### 1ï¸âƒ£ **Null Reference ë°©ì–´ ì½”ë“œ ì¶”ê°€ (Critical)**

**ìœ„ì¹˜**: `AttackSystem.cs`, `PlayerBehavior.cs`, `EnemyBehavior.cs` - Awake()

**ë¬¸ì œ**:
```csharp
void Awake()
{
    stats = GetComponentInChildren<StatsContainer>().stats;  // ğŸ’¥ NullReferenceException ê°€ëŠ¥
    rb = GetComponentInChildren<Rigidbody2D>();
}
```

**í•´ê²°**:
```csharp
void Awake()
{
    if (!TryGetComponentInChildren<StatsContainer>(out var container))
    {
        Logger.Write($"[CRITICAL] StatsContainer missing on {name}", "ERROR");
        enabled = false;
        return;
    }
    stats = container.stats;
    
    if (!TryGetComponentInChildren<Rigidbody2D>(out rb))
    {
        Logger.Write($"[CRITICAL] Rigidbody2D missing on {name}", "ERROR");
        enabled = false;
        return;
    }
}
```

**ì˜í–¥ë„**: ğŸ’¥ğŸ’¥ğŸ’¥ (í¬ë¦¬í‹°ì»¬)  
**ì‘ì—… ì‹œê°„**: 1ì‹œê°„

---

### 2ï¸âƒ£ **LLM ì´ˆê¸°í™” ì‹¤íŒ¨ ì‹œ Fallback ë¡œì§ (High)**

**ìœ„ì¹˜**: `LLMInferenceManager.cs` - InitModel()

**ë¬¸ì œ**:
```csharp
if (_pipeline == IntPtr.Zero)
{
    Logger.Write("failed to load model", "ERROR");
    // âŒ ê·¸ëƒ¥ ì§„í–‰í•˜ì—¬ ë‚˜ì¤‘ì— í¬ë˜ì‹œ
}
```

**í•´ê²°**:
```csharp
private bool _isModelLoaded = false;

void InitModel()
{
    _pipeline = OV_LoadModel(modelPath, device);
    if (_pipeline == IntPtr.Zero)
    {
        Logger.Write("Failed to load LLM model, using rule-based fallback", "ERROR");
        _isModelLoaded = false;
        return;
    }
    _isModelLoaded = true;
}

public void RequestInference(LLMRequest request)
{
    if (!_isModelLoaded)
    {
        // Rule-based fallback AI
        var fallbackOutput = GenerateFallbackResponse(request);
        OnWorkerCompleted(request, fallbackOutput);
        return;
    }
    _requestQueue.Enqueue(request);
}
```

**ì˜í–¥ë„**: ğŸ’¥ğŸ’¥ (ë†’ìŒ)  
**ì‘ì—… ì‹œê°„**: 2ì‹œê°„

---

### 3ï¸âƒ£ **Logger í˜¸ì¶œ ìµœì í™” (Medium)**

**ìœ„ì¹˜**: `EnemyBehavior.cs` - FixedUpdate()

**ë¬¸ì œ**:
```csharp
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");  // ğŸ’¥ ë§¤ í”„ë ˆì„!
}
```

**í•´ê²°**:
```csharp
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    
    #if UNITY_EDITOR
    if (Logger.DEBUG && Logger.IsVerbose)  // ì¡°ê±´ë¶€ ë¡œê¹…
        Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
    #endif
}
```

**ì˜í–¥ë„**: ğŸ’¥ (ì¤‘ê°„ - ì„±ëŠ¥)  
**ì‘ì—… ì‹œê°„**: 30ë¶„

---

## ğŸ”§ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Top 3)

### 1ï¸âƒ£ **Namespace + Interface ë„ì…**

**ëª©í‘œ**: íƒ€ì… ì¶©ëŒ ë°©ì§€, í…ŒìŠ¤íŠ¸ ìš©ì´ì„± í–¥ìƒ

**êµ¬ì¡°**:
```csharp
namespace ProjectMagic.Core
{
    public interface IHealth
    {
        float MaxHealth { get; }
        float CurrentHealth { get; }
        bool IsAlive { get; }
        void TakeDamage(float damage, Vector2 knockback);
    }
    
    public abstract class HealthSystem : MonoBehaviour, IHealth
    {
        // ...
    }
}

namespace ProjectMagic.Player
{
    using ProjectMagic.Core;
    
    public class PlayerHealth : HealthSystem
    {
        // ...
    }
}
```

**ì˜í–¥ë„**: ğŸŒŸğŸŒŸğŸŒŸ (ì¥ê¸° ìœ ì§€ë³´ìˆ˜)  
**ì‘ì—… ì‹œê°„**: 4ì‹œê°„

---

### 2ï¸âƒ£ **ScriptableObject ê¸°ë°˜ Config ë¶„ë¦¬**

**ëª©í‘œ**: ë°ì´í„°ì™€ ë¡œì§ ì™„ì „ ë¶„ë¦¬, ë°¸ëŸ°ìŠ¤ ì¡°ì • ìš©ì´

**êµ¬ì¡°**:
```csharp
[CreateAssetMenu(fileName = "PlayerConfig", menuName = "Config/Player")]
public class PlayerConfigSO : ScriptableObject
{
    [Header("Movement")]
    public float moveSpeed = 5f;
    public float jumpForce = 10f;
    
    [Header("Combat")]
    public float hitRecoveryCooldown = 1f;
    public LayerMask enemyLayer;
}

public class PlayerBehavior : MonoBehaviour
{
    [SerializeField] PlayerConfigSO config;
    
    void ApplyConfig()
    {
        // config.moveSpeed ì‚¬ìš©
    }
}
```

**ì˜í–¥ë„**: ğŸŒŸğŸŒŸğŸŒŸ (ë°¸ëŸ°ìŠ¤ ì¡°ì •)  
**ì‘ì—… ì‹œê°„**: 6ì‹œê°„

---

### 3ï¸âƒ£ **Dependency Injection Container ë„ì… (Zenject/VContainer)**

**ëª©í‘œ**: Singleton ì œê±°, í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ëŒ€í­ í–¥ìƒ

**êµ¬ì¡°**:
```csharp
public class GameInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        Container.Bind<ILLMService>().To<LLMInferenceManager>().AsSingle();
        Container.Bind<IContainerService>().To<ContainerController>().AsSingle();
    }
}

public class PlayerBehavior : MonoBehaviour
{
    [Inject] private ILLMService _llmService;
    
    void Start()
    {
        _llmService.RequestInference(request);  // Singleton ëŒ€ì‹  ì£¼ì…ë°›ìŒ
    }
}
```

**ì˜í–¥ë„**: ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ (ì•„í‚¤í…ì²˜ í˜ì‹ )  
**ì‘ì—… ì‹œê°„**: 8ì‹œê°„

---

## âœ¨ Best Parts - ì˜í•œ ì  (Top 3)

### 1ï¸âƒ£ **FSM/BT ì´ì¤‘ êµ¬ì¡° ì™„ë²½ êµ¬í˜„**

**PlayerBehavior**: Xì¶•/Yì¶• ë…ë¦½ FSM  
**EnemyBehavior**: ìš°ì„ ìˆœìœ„ ê¸°ë°˜ Behavior Tree

```csharp
// Xì¶•: IDLE â†” MOVE â†” ATTACK
// Yì¶•: ReadyToJump â†” InFlight
// ì™„ë²½í•œ ë¶„ë¦¬ë¡œ ë³µì¡ë„ ì œê±°
```

â†’ **Unity ê²Œì„ ê°œë°œì˜ Best Practice ì¤‘ í•˜ë‚˜**

---

### 2ï¸âƒ£ **ì…ë ¥ ìŠ¤ëƒ…ìƒ· + FixedUpdate ë™ê¸°í™”**

```csharp
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput;  // Updateì—ì„œ ë³€ê²½ëœ ê°’ ê³ ì •
    UpdateYState();
    UpdateXState();
}
```

â†’ **ì…ë ¥ê³¼ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ íƒ€ì´ë° ì´ìŠˆ ì™„ë²½ í•´ê²°**  
â†’ **ëŒ€ë¶€ë¶„ì˜ Unity ê°œë°œìê°€ ë†“ì¹˜ëŠ” ë¶€ë¶„**

---

### 3ï¸âƒ£ **Object Pooling + Event-driven ê²°í•©**

```csharp
// Object Poolë¡œ GC ì••ë ¥ ì œê±°
poolContainer[i] = new ObjectPool<SkillLogic>(skillLogic, ObjectPoolSize, goContainer);

// UnityEventë¡œ ëŠìŠ¨í•œ ê²°í•©
attackSystem.EventAttack.AddListener(ListenerAttack);
```

â†’ **ì„±ëŠ¥ + ìœ ì§€ë³´ìˆ˜ì„± ë™ì‹œ ë‹¬ì„±**

---

## ğŸ“ ìµœì¢… ì˜ê²¬

ì´ í”„ë¡œì íŠ¸ëŠ” **ìƒìš© ê²Œì„ ìˆ˜ì¤€ì˜ ì½”ë“œ í’ˆì§ˆ**ì„ ë³´ì—¬ì£¼ê³  ìˆìœ¼ë©°, íŠ¹íˆ **ê²Œì„í”Œë ˆì´ ë¡œì§ê³¼ AI êµ¬ì¡°**ì—ì„œ íƒì›”í•©ë‹ˆë‹¤. 

**ì¦‰ì‹œ ê°œì„  ì‚¬í•­ 3ê°€ì§€**ë§Œ ì ìš©í•˜ë©´ í¬ë¦¬í‹°ì»¬ ë²„ê·¸ ê°€ëŠ¥ì„±ì´ ëŒ€í­ ì¤„ì–´ë“¤ê³ , **ì¤‘ì¥ê¸° ë¦¬íŒ©í† ë§**ì„ í†µí•´ íŒ€ í˜‘ì—… ë° í…ŒìŠ¤íŠ¸ ìš©ì´ì„±ì„ í•œì¸µ ë†’ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í˜„ì¬ ìƒíƒœì—ì„œë„ **84.5ì **ì´ë¼ëŠ” ë†’ì€ ì ìˆ˜ì´ë©°, ì œì•ˆì‚¬í•­ ì ìš© ì‹œ **90ì  ì´ìƒ** ë‹¬ì„± ê°€ëŠ¥í•©ë‹ˆë‹¤.

---

**ì‘ì„±ì**: GitHub Copilot (Claude Sonnet 4.5)  
**í‰ê°€ ê¸°ì¤€**: CodeEvaluationPrompt.md (Unity C# 10ëŒ€ í•­ëª©)
