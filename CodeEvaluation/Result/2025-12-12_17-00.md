# Unity C# ì½”ë“œ í’ˆì§ˆ í‰ê°€ ë³´ê³ ì„œ

**í‰ê°€ ì¼ì‹œ**: 2025-12-12  
**í”„ë¡œì íŠ¸**: project-magic  
**í‰ê°€ ëŒ€ìƒ**: Assets/Scripts ì „ì²´ ì½”ë“œë² ì´ìŠ¤

---

## ğŸ“Œ 1. Architecture & Unity Component Design

**ì ìˆ˜: 7.5/10**

### âœ… ì¥ì 
- **FSM & BehaviorTree êµ¬ì¡° ë¶„ë¦¬**: Core/FiniteStateMachine.csì™€ Core/BehaviorTree.csë¥¼ í™œìš©í•œ ëª…í™•í•œ ìƒíƒœ ê´€ë¦¬
- **ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤ í™œìš©**: `HealthSystem`, `AttackSystem` ë“± ìƒì† ê¸°ë°˜ í™•ì¥ì„± ì œê³µ
- **Unity ìƒëª…ì£¼ê¸° ì ì ˆí•œ ë¶„ë¦¬**: `Awake`(ì´ˆê¸°í™”), `Start`(ì´ë²¤íŠ¸ ë“±ë¡), `FixedUpdate`(ë¬¼ë¦¬), `Update`(ë¡œì§)ë¡œ ëª…í™•íˆ êµ¬ë¶„

### âš ï¸ ë¬¸ì œì 

1. **ì±…ì„ ê³¼ë‹¤ ì§‘ì¤‘** (PlayerBehavior.cs)
   - 422ì¤„ì˜ ê±°ëŒ€ í´ë˜ìŠ¤ì— ì…ë ¥ ì²˜ë¦¬, ìƒíƒœ ê´€ë¦¬, FSM êµ¬ì¶•, ë‚´ë¶€ State í´ë˜ìŠ¤ ì •ì˜ ëª¨ë‘ í¬í•¨
   - SRP ìœ„ë°˜: í•˜ë‚˜ì˜ í´ë˜ìŠ¤ê°€ ë„ˆë¬´ ë§ì€ ì—­í•  ìˆ˜í–‰

2. **ì¤‘ì²© í´ë˜ìŠ¤ ê³¼ë‹¤ ì‚¬ìš©**
   ```csharp
   class StateDeath : FSMNode { ... }
   class StateHit : FSMNode { ... }
   class StateAttack : FSMNode { ... }
   // PlayerBehavior ë‚´ë¶€ì— 7ê°œì˜ ì¤‘ì²© í´ë˜ìŠ¤
   ```
   - í…ŒìŠ¤íŠ¸ì™€ ì¬ì‚¬ìš©ì´ ì–´ë ¤ì›€
   - íŒŒì¼ ê°€ë…ì„± ì €í•˜

3. **ScriptableObject í™œìš© ë¶€ì¡±**
   - ìŠ¤í‚¬, ê³µê²© ë°ì´í„°ê°€ `CharacterStats`ì— ì§‘ì¤‘ë˜ì–´ ìˆìœ¼ë‚˜ ëŸ°íƒ€ì„ ë°ì´í„°ì™€ í˜¼ì¬
   - ë°ì´í„° ê¸°ë°˜ í™•ì¥ì„± ì œí•œ

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// í˜„ì¬: PlayerBehavior ë‚´ë¶€ ì¤‘ì²© í´ë˜ìŠ¤
class StateMove : FSMNode { ... }

// ê°œì„ : ë…ë¦½ íŒŒì¼ë¡œ ë¶„ë¦¬
public class PlayerMoveState : FSMNode 
{
    private readonly PlayerBehavior player;
    public PlayerMoveState(PlayerBehavior player) => this.player = player;
    // ...
}
```

---

## ğŸ“Œ 2. Code Readability & Maintainability

**ì ìˆ˜: 6/10**

### âœ… ì¥ì 
- **SerializeField í—¤ë” ì‚¬ìš©**: `[Header("Stats")]` ë“± Unity Inspector ê°€ë…ì„± ê³ ë ¤
- **ì¼ê´€ëœ ë„¤ì´ë°**: `camelCase` (private), `PascalCase` (public/method)

### âš ï¸ ë¬¸ì œì 

1. **XML ë¬¸ì„œí™” ì£¼ì„ ë¶€ì¬**
   ```csharp
   public abstract class HealthSystem : MonoBehaviour
   {
       // XML ì£¼ì„ ì—†ìŒ
       public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
   ```

2. **Magic Number ë‚¨ë°œ** (EnemyBehavior.cs)
   ```csharp
   if (Mathf.Abs(_target.position.x - ctx.transform.position.x) <= ctx.stats.attackRange + ctx.raycastDetectionMargin);
   if (Vector3.Distance(GetFollowTargetPos(_snapShotFollowTarget), transform.position) <= 1e-1)
   ```
   - `1e-1`, `0.2f` ë“± í•˜ë“œì½”ë”©ëœ ê°’ë“¤

3. **ë¶ˆëª…í™•í•œ ë³€ìˆ˜ëª…**
   ```csharp
   float _snapShotjumpInput; // typo: "jumpInput"
   Vector2 _hitForce; // ë‹¨ìˆœí•œ ì´ë¦„, knockbackForceê°€ ë” ëª…í™•
   ```

4. **ê¸´ ë©”ì„œë“œ** (EnemyBehavior.cs)
   - `CheckFlipDirection()` ë©”ì„œë“œê°€ 70ì¤„ ì´ìƒ

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// ê°œì„ : ìƒìˆ˜ ì •ì˜
private const float GROUND_DETECTION_RADIUS = 0.2f;
private const float POSITION_EPSILON = 0.1f;

/// <summary>
/// ìºë¦­í„°ê°€ ë°ë¯¸ì§€ë¥¼ ë°›ì•„ ì²´ë ¥ì„ ê°ì†Œì‹œí‚µë‹ˆë‹¤.
/// </summary>
/// <param name="rawDamage">ë°©ì–´ë ¥ ì ìš© ì „ í”¼í•´ëŸ‰</param>
/// <param name="knockbackDirection">ë„‰ë°± ë°©í–¥ ë²¡í„°</param>
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

**ì ìˆ˜: 7/10**

### âœ… ì¥ì 
- **ObjectPool êµ¬í˜„**: Common/ObjectPool.csë¡œ GC ì••ë ¥ ê°ì†Œ
- **GetComponent ìºì‹±**: `Awake`ì—ì„œ ì»´í¬ë„ŒíŠ¸ ìºì‹±
  ```csharp
  void Awake()
  {
      rb = GetComponentInChildren<Rigidbody2D>();
      animController = GetComponent<AnimationController>();
  }
  ```

### âš ï¸ ë¬¸ì œì 

1. **Update ë‚´ ë¶ˆí•„ìš”í•œ ì¡°ê±´ ì²´í¬**
   ```csharp
   void Update()
   {
       if (!healthSystem.IsAlive) return; // ë§¤ í”„ë ˆì„ ì²´í¬
       TickUpdate();
   }
   ```

2. **LINQ ì‚¬ìš©** (LLMSessionManager.cs)
   ```csharp
   returnMsg = RandomUtils.SampleArray(msgs, 1).First();
   ```
   - GC Allocation ë°œìƒ

3. **ë§¤ í”„ë ˆì„ Dictionary ìˆœíšŒ** (APCRouter.cs)
   ```csharp
   foreach (var eventTrigger in apcEvent.triggerContainer.Values)
   ```

4. **ë¶ˆí•„ìš”í•œ Vector3 ë³µì‚¬**
   ```csharp
   Vector3 scale = ctx.transform.localScale;
   scale.x = -scale.x;
   ctx.transform.localScale = scale;
   ```

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// ê°œì„ : ìƒíƒœ ê¸°ë°˜ Update ìµœì í™”
private bool isDead = false;
void Update()
{
    if (isDead) return;
    TickUpdate();
}

void ListenerDeath()
{
    isDead = true; // ìºì‹±ëœ ë¶ˆë¦¬ì–¸ ì‚¬ìš©
    // ...
}

// LINQ ì œê±°
returnMsg = RandomUtils.SampleArray(msgs, 1)[0];

// Vector ì¬ì‚¬ìš©
private Vector3 cachedScale;
void FlipDirection()
{
    cachedScale = transform.localScale;
    cachedScale.x = -cachedScale.x;
    transform.localScale = cachedScale;
}
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

**ì ìˆ˜: 8/10**

### âœ… ì¥ì 
- **Input ë²„í¼ë§ ì‹œìŠ¤í…œ**: `Queue<PlayerState>` í™œìš©
  ```csharp
  Queue<PlayerState> bufferXState = new Queue<PlayerState>();
  Queue<PlayerState> bufferYState = new Queue<PlayerState>();
  ```
- **Snapshot Input íŒ¨í„´**: `FixedUpdate`ì—ì„œ ì…ë ¥ ìŠ¤ëƒ…ìƒ·
  ```csharp
  void FixedUpdate()
  {
      _snapShotMoveInput = _moveInput;
      _snapShotjumpInput = _jumpInput ? 1.0f : 0.0f;
  }
  ```
- **Hit Recovery Cooldown**: ë¬´ì  ì‹œê°„ ì²˜ë¦¬
  ```csharp
  if (_hitRecoveryTimer > 0) return;
  ```

### âš ï¸ ë¬¸ì œì 

1. **Null ì°¸ì¡° ìœ„í—˜** (EnemyBehavior.cs)
   ```csharp
   if (ctx._target == null) return ...;
   // ì´í›„ ë¡œì§ì—ì„œ _target.position ì§ì ‘ ì ‘ê·¼
   ```

2. **ë™ì‹œì„± ë¬¸ì œ** (APCBehavior.cs)
   ```csharp
   void Update() { /* followTarget ì²´í¬ */ }
   void LateUpdate() 
   { 
       _snapShotFollowTarget = followTarget.transform; // null ê°€ëŠ¥ì„±
   }
   ```

3. **ê³µê²© ì¤‘ ì´ë™ ë¬¸ì œ**
   ```csharp
   // PlayerBehavior: ATTACK ìƒíƒœì—ì„œ ì´ë™ ì…ë ¥ ë¬´ì‹œ ë¯¸ì²˜ë¦¬
   case PlayerState.ATTACK:
       if (_attackRecoveryTimer <= 0)
           ChangeState(ref currentXState, PlayerState.IDLE);
       break;
   ```

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// Null ì•ˆì „ì„± ê°•í™”
if (ctx._target != null && ctx._target.position.x > 0) { ... }

// TryGetComponent í™œìš©
if (hit.TryGetComponent<HealthSystem>(out var health))
{
    health.TakeDamage(damage);
}

// ê³µê²© ì¤‘ ì´ë™ ë°©ì§€
class StateAttack : FSMNode
{
    public override void Update()
    {
        // ì´ë™ ì…ë ¥ ë¬´ì‹œ
        ctx.rb.linearVelocity = new Vector2(0, ctx.rb.linearVelocity.y);
    }
}
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

**ì ìˆ˜: 7.5/10**

### âœ… ì¥ì 
- **GetComponent ìºì‹± ì „ëµ**: `Awake`ì—ì„œ ì¼ê´„ ìºì‹±
- **Time.deltaTime ì‚¬ìš©**: í”„ë ˆì„ ë…ë¦½ì  íƒ€ì´ë¨¸
  ```csharp
  if (_hitRecoveryTimer > 0) _hitRecoveryTimer -= Time.deltaTime;
  ```
- **SerializeField í™œìš©**: private í•„ë“œì˜ Inspector ë…¸ì¶œ
- **LayerMask ì‚¬ìš©**: `[SerializeField] LayerMask layerGround;`
- **Gizmos ì‹œê°í™”**: `OnDrawGizmosSelected`ë¡œ ë””ë²„ê¹… ì§€ì›

### âš ï¸ ë¬¸ì œì 

1. **FindAnyObjectByType ì‚¬ìš©** (APCRouter.cs)
   ```csharp
   void Start()
   {
       playerBehavior = FindAnyObjectByType<PlayerBehavior>(); // ë¹„ìš© ë†’ìŒ
   }
   ```
   - ì˜ì¡´ì„± ì£¼ì… ê¶Œì¥

2. **Physicsì™€ Transform í˜¼í•©**
   ```csharp
   ctx.rb.linearVelocity = velocity; // physics
   ctx.transform.localScale = scale; // transform ì§ì ‘ ìˆ˜ì •
   ```

3. **Magic Number ì—¬ì „íˆ ì¡´ì¬**
   ```csharp
   Collider2D hit = Physics2D.OverlapCircle(attackBox, hitAreaRadius, targetLayerMask);
   // hitAreaRadiusê°€ Inspectorì—ì„œë§Œ ì„¤ì • ê°€ëŠ¥
   ```

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// Dependency Injection
public class APCRouter : MonoBehaviour
{
    [SerializeField] PlayerBehavior playerBehavior; // Inspector ì—°ê²°
}

// Physics ì¼ê´€ì„±
public class PlayerMovement
{
    private void FixedUpdate() // Physics ê³„ì‚°ì€ FixedUpdate
    {
        rb.linearVelocity = CalculateVelocity();
    }
}
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

**ì ìˆ˜: 7/10**

### âœ… ì¥ì 
- **FSM êµ¬ì¡° ëª…í™•**: PlayerëŠ” FSM, EnemyëŠ” BehaviorTreeë¡œ êµ¬ë¶„
- **Animation ë™ê¸°í™”**: `PlayStateAnimation` ë°˜í™˜ê°’ìœ¼ë¡œ clip time í™œìš©
  ```csharp
  ctx._attackRecoveryTimer = ctx.animController.PlayStateAnimation(PlayerState.ATTACK, rebind: true);
  ```
- **Event ê¸°ë°˜ í†µì‹ **: `UnityEvent` í™œìš©ìœ¼ë¡œ ê²°í•©ë„ ê°ì†Œ

### âš ï¸ ë¬¸ì œì 

1. **Animator Rebind ê³¼ë‹¤ ì‚¬ìš©**
   ```csharp
   ctx.animController.PlayStateAnimation(PlayerState.DAMAGED, rebind: true);
   ```
   - ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ

2. **Animation Event ëˆ„ë½**
   - ê³µê²© íŒì • íƒ€ì´ë°ì´ ì• ë‹ˆë©”ì´ì…˜ê³¼ ë™ê¸°í™”ë˜ì§€ ì•ŠìŒ
   - `ExecuteAttack`ì´ ì¦‰ì‹œ í˜¸ì¶œë¨

3. **BehaviorTree ë§¤ í”„ë ˆì„ ì¬í‰ê°€** (EnemyBehavior.cs)
   ```csharp
   void FixedUpdate()
   {
       var (selectorResult, actionPath) = selectorRoot.Evaluate(); // ë§¤ í”„ë ˆì„
   }
   ```

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// Animation Event í™œìš©
public class AttackAnimation : StateMachineBehaviour
{
    public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
    {
        // ê³µê²© íŒì • ì‹œì ì— ì´ë²¤íŠ¸ ë°œìƒ
        SendMessage("OnAttackHit");
    }
}

// BehaviorTree ì£¼ê¸° ì¡°ì ˆ
private float btEvaluationInterval = 0.1f;
private float btTimer;

void FixedUpdate()
{
    btTimer += Time.fixedDeltaTime;
    if (btTimer >= btEvaluationInterval)
    {
        selectorRoot.Evaluate();
        btTimer = 0;
    }
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

**ì ìˆ˜: 6/10**

### âœ… ì¥ì 
- **ê¸°ë³¸ì ì¸ Null ì²´í¬**: `if (_pipeline == IntPtr.Zero)`
- **Try-Catch ë¸”ë¡**: LLMWorkerThread.csì—ì„œ ì˜ˆì™¸ ì²˜ë¦¬

### âš ï¸ ë¬¸ì œì 

1. **ì¼ê´€ì„± ì—†ëŠ” Null ë°©ì–´**
   ```csharp
   // HealthSystem.cs: null ì²´í¬ ì—†ìŒ
   targetHealthSystem.TakeDamage(attack.damage, knockback);
   
   // AttackSystem.cs: ì¼ë¶€ë§Œ ì²´í¬
   if (targetHealthSystem == null) return;
   ```

2. **ê²½ê³„ ì²´í¬ ë¶€ì¡±**
   ```csharp
   if (attackIndex >= attackContainer.Count) // âœ…
   if (attackIndex < 0) // âŒ ìŒìˆ˜ ì²´í¬ ì—†ìŒ
   ```

3. **ì´ˆê¸°í™” ìˆœì„œ ë¬¸ì œ**
   ```csharp
   // APCEventTrigger.cs
   void Awake() { toolsJson = BuildToolsJson(); }
   void Start() 
   { 
       LLMSessionManager.Instance.RequestQuery(..., toolsJson, ...); 
       // Singleton ì´ˆê¸°í™” ìˆœì„œ ë³´ì¥ ì•ˆ ë¨
   }
   ```

4. **ë¹„ë™ê¸° ì‘ì—… ì·¨ì†Œ ì²˜ë¦¬ ë¶€ì¡±** (LLMWorkerThread.cs)
   ```csharp
   public void Stop()
   {
       _running = false;
       _queue.Enqueue(null); // nullì„ enqueueí•˜ëŠ” ë°©ì‹ì€ ë¶ˆì•ˆì •
   }
   ```

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// Null ì•ˆì „ì„± ê°•í™”
public void ApplyAttack(AttackContainer attack, Vector3 originPos, Vector3 hitPoint, HealthSystem target)
{
    if (target == null)
    {
        Logger.Write("Target HealthSystem is null", "WARNING");
        return;
    }
    target.TakeDamage(attack.damage);
}

// ê²½ê³„ ì²´í¬ ì™„ì „ì„±
if (attackIndex < 0 || attackIndex >= attackContainer.Count)
{
    Logger.Write($"Invalid attack index: {attackIndex}", "ERROR");
    return false;
}

// Singleton ì´ˆê¸°í™” ë³´ì¥
void Start()
{
    if (LLMSessionManager.Instance == null)
    {
        Logger.Write("LLMSessionManager not initialized", "ERROR");
        return;
    }
    // ...
}

// CancellationToken ì‚¬ìš©
private CancellationTokenSource _cts;

private void ThreadLoop()
{
    while (!_cts.Token.IsCancellationRequested)
    {
        // ...
    }
}

public void Stop()
{
    _cts?.Cancel();
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

**ì ìˆ˜: 7/10**

### âœ… ì¥ì 
- **ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤**: `HealthSystem`, `AttackSystem`ìœ¼ë¡œ í™•ì¥ ìš©ì´
- **Trigger ì‹œìŠ¤í…œ**: Core/Trigger.csì˜ ì¶”ìƒí™”
- **Tool Executor íŒ¨í„´**: APCEventTrigger.csì—ì„œ ë™ì  í•¨ìˆ˜ ë“±ë¡
  ```csharp
  apcToolExecutor.Add("CreatePlayerHealthPointTrigger", 
      (Func<string, float, ToolCallOutput>)CreatePlayerHealthPointTrigger);
  ```

### âš ï¸ ë¬¸ì œì 

1. **í•˜ë“œì½”ë”©ëœ ìƒíƒœ ì „ì´**
   ```csharp
   switch (currentXState)
   {
       case PlayerState.ATTACK:
           if (_attackRecoveryTimer <= 0)
               ChangeState(ref currentXState, PlayerState.IDLE);
   ```
   - ìƒˆë¡œìš´ ìƒíƒœ ì¶”ê°€ ì‹œ switch ë¬¸ ìˆ˜ì • í•„ìš”

2. **ìŠ¤í‚¬ ì¶”ê°€ í™•ì¥ì„± ì œí•œ**
   ```csharp
   public void OnSkillW(InputValue value) // í•˜ë“œì½”ë”©ëœ ë©”ì„œë“œ
   {
       _attackRes = attackSystem.ExecuteAttack(1, ...);
   }
   ```

3. **Enemy íƒ€ì…ë³„ ì°¨ì´ ì²˜ë¦¬ ë¶€ì¡±**
   - ëª¨ë“  Enemyê°€ ë™ì¼í•œ BehaviorTree êµ¬ì¡° ì‚¬ìš©
   - íƒ€ì…ë³„ íŠ¹í™” í–‰ë™ ì¶”ê°€ ì–´ë ¤ì›€

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// ScriptableObject ê¸°ë°˜ FSM
[CreateAssetMenu]
public class FSMTransitionData : ScriptableObject
{
    public PlayerState fromState;
    public PlayerState toState;
    public TransitionCondition condition;
}

// ìŠ¤í‚¬ ë§¤í•‘ ì‹œìŠ¤í…œ
public class SkillManager
{
    private Dictionary<KeyCode, int> skillMap = new()
    {
        { KeyCode.Q, 1 },
        { KeyCode.W, 2 },
        { KeyCode.E, 3 }
    };
    
    public void ExecuteSkill(KeyCode key)
    {
        if (skillMap.TryGetValue(key, out int skillIndex))
            attackSystem.ExecuteAttack(skillIndex);
    }
}

// Enemy íƒ€ì…ë³„ BehaviorTree ì£¼ì…
public class EnemyBehavior : MonoBehaviour
{
    [SerializeField] BehaviorTreeAsset treeAsset; // ScriptableObject
    
    void Awake()
    {
        selectorRoot = treeAsset.Build(this);
    }
}
```

---

## ğŸ“Œ 9. Clean Code Practices

**ì ìˆ˜: 6.5/10**

### âœ… ì¥ì 
- **ë„¤ì„ìŠ¤í˜ì´ìŠ¤ êµ¬ì¡°**: `Common`, `Core`, `Player`, `Enemy` ë“± ë…¼ë¦¬ì  í´ë” êµ¬ì¡°
- **KISS ì›ì¹™ ì¤€ìˆ˜**: ëŒ€ë¶€ë¶„ì˜ ë©”ì„œë“œê°€ ë‹¨ìˆœ ëª…í™•
- **Property í™œìš©**: `IsAlive`, `HealthPercentage` ë“±

### âš ï¸ ë¬¸ì œì 

1. **SOLID ìœ„ë°˜**
   - **SRP**: PlayerBehavior.cs 422ì¤„, ë„ˆë¬´ ë§ì€ ì±…ì„
   - **OCP**: switch ë¬¸ìœ¼ë¡œ ì¸í•œ ìˆ˜ì • í•„ìš”ì„±
   - **DIP**: FindAnyObjectByTypeìœ¼ë¡œ ì§ì ‘ ì°¸ì¡°

2. **DRY ìœ„ë°˜** (ì¤‘ë³µ ì½”ë“œ)
   ```csharp
   // PlayerBehavior.StateMove.FlipDirection()
   Vector3 scale = ctx.transform.localScale;
   scale.x = ctx._snapShotMoveInput < 0 ? Mathf.Abs(scale.x) : -Mathf.Abs(scale.x);
   
   // EnemyBehavior.ActionChase.FlipDirection()
   Vector3 scale = ctx.transform.localScale;
   scale.x = -scale.x;
   ```

3. **ë¶ˆí•„ìš”í•œ public í•„ë“œ**
   ```csharp
   public Animator animator; // AnimationController.cs
   // Inspector ì—°ê²°ìš©ì´ì§€ë§Œ ì™¸ë¶€ ì ‘ê·¼ ë¶ˆí•„ìš”
   ```

4. **í´ë” êµ¬ì¡° ê°œì„  í•„ìš”**
   - `Scriptable Object` í´ë”ëª…ì— ê³µë°±
   - `Animation` vs `AnimationController` ë¶„ë¦¬ ë¶ˆëª…í™•

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// ì¤‘ë³µ ì œê±°: ê³µí†µ ìœ í‹¸ë¦¬í‹°
public static class TransformUtils
{
    public static void FlipX(Transform transform)
    {
        var scale = transform.localScale;
        scale.x = -scale.x;
        transform.localScale = scale;
    }
}

// public -> private
[SerializeField] private Animator animator;

// í´ë” êµ¬ì¡° ê°œì„ 
Scripts/
â”œâ”€â”€ Core/          # FSM, BehaviorTree
â”œâ”€â”€ Gameplay/
â”‚   â”œâ”€â”€ Player/
â”‚   â”œâ”€â”€ Enemy/
â”‚   â””â”€â”€ APC/
â”œâ”€â”€ Systems/       # Health, Attack, Animation
â”œâ”€â”€ Data/          # ScriptableObjects
â””â”€â”€ Infrastructure/ # Singleton, ObjectPool
```

---

## ğŸ“Œ 10. Intel OpenVINO ê¸°ë°˜ AI ëª¨ë¸ ì¶”ë¡  í”„ë¡œì„¸ìŠ¤

**ì ìˆ˜: 7.5/10**

### âœ… ì¥ì 
- **ëª…í™•í•œ ì›Œì»¤ ìŠ¤ë ˆë“œ ë¶„ë¦¬**: LLMWorkerThread.csë¡œ ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€
- **ë©”ì¸ ìŠ¤ë ˆë“œ ë””ìŠ¤íŒ¨ì¹˜**: `ConcurrentQueue<Action>`ë¡œ Unity API ì•ˆì „ í˜¸ì¶œ
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: `OV_FreeString`ìœ¼ë¡œ C++ í™ ë©”ëª¨ë¦¬ í•´ì œ
- **Session ê´€ë¦¬**: LLMSessionManager.csì˜ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ìœ ì§€

### âš ï¸ ë¬¸ì œì 

1. **ì´ˆê¸°í™” ì‹¤íŒ¨ ì²˜ë¦¬ ë¯¸í¡**
   ```csharp
   _pipeline = OV_LoadModel(modelPath, device);
   if (_pipeline == IntPtr.Zero)
   {
       Logger.Write("failed to load model", "ERROR");
       // ì´í›„ _pipeline ê³„ì† ì‚¬ìš© ì‹œë„
   }
   ```

2. **ì¶”ë¡  ì‹¤íŒ¨ ì‹œ ì‘ë‹µ ëˆ„ë½**
   ```csharp
   IntPtr resultPtr = OV_Inference(_pipeline, req.messagesJson, req.toolsJson);
   if (resultPtr == IntPtr.Zero)
   {
       continue; // callback í˜¸ì¶œ ì•ˆ í•¨, ìš”ì²­ìê°€ ë¬´í•œ ëŒ€ê¸°
   }
   ```

3. **ìŠ¤ë ˆë“œ ë™ê¸°í™” ì·¨ì•½ì„±**
   ```csharp
   private bool _running = true; // volatile í‚¤ì›Œë“œ ì—†ìŒ
   ```

4. **DLL ê²½ë¡œ í•˜ë“œì½”ë”©**
   ```csharp
   string dllDir = Application.dataPath + "/Plugins/x86_64"; // ë¹Œë“œ í™˜ê²½ ì˜ì¡´
   ```

5. **Tool Call íŒŒì‹± ì˜ˆì™¸ ì²˜ë¦¬ ë¶€ì¡±**
   ```csharp
   var toolCallJson = ParseToolCall(toolCallBlock);
   // JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ null ë°˜í™˜, ì´í›„ NullReferenceException ê°€ëŠ¥
   ```

### ğŸ’¡ ê°œì„  ì œì•ˆ

```csharp
// ì´ˆê¸°í™” ê²€ì¦
void InitModel()
{
    string modelPath = Application.dataPath + $"/Models/{model_id}/";
    _pipeline = OV_LoadModel(modelPath, device);
    
    if (_pipeline == IntPtr.Zero)
    {
        Logger.Write("Failed to load model", "ERROR");
        enabled = false; // ì»´í¬ë„ŒíŠ¸ ë¹„í™œì„±í™”
        throw new InvalidOperationException($"Model load failed: {modelPath}");
    }
    Logger.Write("Model loaded successfully");
}

// ì¶”ë¡  ì‹¤íŒ¨ ì½œë°±
if (resultPtr == IntPtr.Zero)
{
    Logger.Write($"Inference failed / reqId={req.requestId}", "ERROR");
    var errorOutput = new LLMOutput(null, "Inference failed", 0);
    _dispatchResponse(req, errorOutput);
    continue;
}

// volatile ì¶”ê°€
private volatile bool _running = true;

// í”Œë«í¼ë³„ DLL ê²½ë¡œ
private string GetDllDirectory()
{
#if UNITY_EDITOR
    return Application.dataPath + "/Plugins/x86_64";
#elif UNITY_STANDALONE_WIN
    return Application.dataPath + "/Plugins";
#else
    throw new PlatformNotSupportedException();
#endif
}

// Tool Call ì•ˆì „ íŒŒì‹±
try
{
    var toolCallJson = ParseToolCall(toolCallBlock);
    if (toolCallJson == null)
    {
        Logger.Write("Tool call parsing returned null", "ERROR");
        EventLLMResult?.Invoke(LLMResult.Failed, "Tool parsing failed");
        return;
    }
    // ...
}
catch (Exception ex)
{
    Logger.Write($"Tool call exception: {ex.Message}", "ERROR");
    EventLLMResult?.Invoke(LLMResult.Failed, returnMsg);
}
```

---

## ğŸ“Œ ì¢…í•© í‰ê°€

### ì´ì : **7.1 / 10**

| í•­ëª© | ì ìˆ˜ | ê°€ì¤‘ì¹˜ | ë¹„ê³  |
|------|------|--------|------|
| 1. Architecture | 7.5 | â˜…â˜…â˜… | êµ¬ì¡°ëŠ” ì¢‹ìœ¼ë‚˜ SRP ê°œì„  í•„ìš” |
| 2. Readability | 6.0 | â˜…â˜…â˜… | ë¬¸ì„œí™” ë¶€ì¡±, Magic Number ê³¼ë‹¤ |
| 3. Performance | 7.0 | â˜…â˜… | ObjectPool ìš°ìˆ˜, LINQ ì œê±° í•„ìš” |
| 4. Gameplay Logic | 8.0 | â˜…â˜…â˜… | Input ë²„í¼ë§ í›Œë¥­, Null ì²´í¬ ë³´ê°• |
| 5. Unity Best Practices | 7.5 | â˜…â˜…â˜… | ì „ë°˜ì ìœ¼ë¡œ ìš°ìˆ˜, DI ë¶€ì¡± |
| 6. Animation/FSM | 7.0 | â˜…â˜… | êµ¬ì¡° ëª…í™•, Animation Event ëˆ„ë½ |
| 7. Safety | 6.0 | â˜…â˜… | ê¸°ë³¸ ì²´í¬ë§Œ ì¡´ì¬, ì¼ê´€ì„± í•„ìš” |
| 8. Scalability | 7.0 | â˜…â˜…â˜… | í™•ì¥ ê°€ëŠ¥í•˜ë‚˜ í•˜ë“œì½”ë”© ì”ì¡´ |
| 9. Clean Code | 6.5 | â˜…â˜… | ì¤‘ë³µ ì½”ë“œ, SOLID ì¼ë¶€ ìœ„ë°˜ |
| 10. OpenVINO Integration | 7.5 | â˜…â˜…â˜… | ë¹„ë™ê¸° ì²˜ë¦¬ ìš°ìˆ˜, ì—ëŸ¬ ì²˜ë¦¬ ë³´ê°• |

---

## ğŸš¨ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (Top 3)

### 1. **PlayerBehavior.cs ë¦¬íŒ©í† ë§ (ìµœìš°ì„ )**
- **ë¬¸ì œ**: 422ì¤„ ê±°ëŒ€ í´ë˜ìŠ¤, 7ê°œ ì¤‘ì²© í´ë˜ìŠ¤, SRP ì‹¬ê° ìœ„ë°˜
- **ì˜í–¥**: ìœ ì§€ë³´ìˆ˜ì„± ì €í•˜, í…ŒìŠ¤íŠ¸ ì–´ë ¤ì›€, ë²„ê·¸ ìœ ë°œ
- **í•´ê²°**:
  ```csharp
  // ë¶„ë¦¬ ì „ëµ
  PlayerBehavior (100ì¤„)           // ì½”ë””ë„¤ì´í„°
  â”œâ”€â”€ PlayerInputHandler           // ì…ë ¥ ì²˜ë¦¬
  â”œâ”€â”€ PlayerStateManager           // FSM ê´€ë¦¬
  â””â”€â”€ States/
      â”œâ”€â”€ PlayerMoveState.cs
      â”œâ”€â”€ PlayerAttackState.cs
      â””â”€â”€ PlayerJumpState.cs
  ```

### 2. **Null ì°¸ì¡° ì•ˆì „ì„± ê°•í™”**
- **ë¬¸ì œ**: ì¼ê´€ì„± ì—†ëŠ” null ì²´í¬, ëŸ°íƒ€ì„ í¬ë˜ì‹œ ìœ„í—˜
- **ìœ„ì¹˜**:
  - EnemyBehavior.cs `_target` ì²´í¬
  - AttackSystem.cs `targetHealthSystem`
  - LLMSessionManager.cs Tool call íŒŒì‹±
- **í•´ê²°**:
  ```csharp
  // í”„ë¡œì íŠ¸ ì „ì²´ì— null ì²´í¬ íŒ¨í„´ ì ìš©
  if (target?.IsAlive ?? false) { ... }
  
  // Nullable Reference Types í™œì„±í™” (.csproj)
  <Nullable>enable</Nullable>
  ```

### 3. **Magic Number ì œê±° ë° ìƒìˆ˜í™”**
- **ë¬¸ì œ**: 100ê°œ ì´ìƒì˜ í•˜ë“œì½”ë”©ëœ ìˆ«ì, ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€
- **ì˜ˆì‹œ**: `1e-1`, `0.2f`, `1.0f`, `Mathf.Epsilon`
- **í•´ê²°**:
  ```csharp
  // Constants/GameplayConstants.cs ìƒì„±
  public static class GameplayConstants
  {
      public const float GROUND_CHECK_RADIUS = 0.2f;
      public const float POSITION_TOLERANCE = 0.1f;
      public const float JUMP_FORCE_MULTIPLIER = 1.0f;
  }
  ```

---

## ğŸ”§ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Top 3)

### 1. **ë°ì´í„° ê¸°ë°˜ ì‹œìŠ¤í…œìœ¼ë¡œ ì „í™˜ (3ê°œì›”)**
- **ëª©í‘œ**: í•˜ë“œì½”ë”© ì œê±°, ìŠ¤í‚¬/ìŠ¤íƒ¯ í™•ì¥ì„± í™•ë³´
- **ì‘ì—…**:
  ```csharp
  // ScriptableObject ê¸°ë°˜ ì„¤ê³„
  [CreateAssetMenu]
  public class SkillData : ScriptableObject
  {
      public string skillName;
      public int skillIndex;
      public KeyCode defaultKey;
      public AttackData attackData;
  }
  
  public class SkillManager : MonoBehaviour
  {
      [SerializeField] List<SkillData> skills;
      // ë™ì  ë°”ì¸ë”©
  }
  ```

### 2. **ì˜ì¡´ì„± ì£¼ì…(DI) í”„ë ˆì„ì›Œí¬ ë„ì… (2ê°œì›”)**
- **ëª©í‘œ**: `FindAnyObjectByType` ì œê±°, í…ŒìŠ¤íŠ¸ ìš©ì´ì„± í–¥ìƒ
- **ë¼ì´ë¸ŒëŸ¬ë¦¬**: VContainer ë˜ëŠ” Zenject
- **ì˜ˆì‹œ**:
  ```csharp
  // í˜„ì¬
  playerBehavior = FindAnyObjectByType<PlayerBehavior>();
  
  // ê°œì„ 
  [Inject] private PlayerBehavior playerBehavior;
  ```

### 3. **ì• ë‹ˆë©”ì´ì…˜ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ êµ¬ì¶• (1ê°œì›”)**
- **ëª©í‘œ**: ê³µê²© íŒì •, ì‚¬ìš´ë“œ, VFXë¥¼ ì• ë‹ˆë©”ì´ì…˜ íƒ€ì„ë¼ì¸ê³¼ ë™ê¸°í™”
- **êµ¬ì¡°**:
  ```csharp
  // Animation Event ë¦¬ìŠ¤ë„ˆ
  public class AttackAnimationEvents : MonoBehaviour
  {
      public UnityEvent OnAttackStart;
      public UnityEvent OnAttackHit;    // ì´ ì‹œì ì— ë°ë¯¸ì§€ íŒì •
      public UnityEvent OnAttackEnd;
      
      public void AnimEvent_AttackHit() => OnAttackHit?.Invoke();
  }
  ```

---

## ğŸŒŸ ì˜í•œ ì  (Best Parts - Top 3)

### 1. **Input ë²„í¼ë§ & Snapshot ì‹œìŠ¤í…œ** â­â­â­â­â­
- **ìœ„ì¹˜**: PlayerBehavior.cs
- **ë‚´ìš©**:
  ```csharp
  Queue<PlayerState> bufferXState = new Queue<PlayerState>();
  void FixedUpdate()
  {
      _snapShotMoveInput = _moveInput;
      _snapShotjumpInput = _jumpInput ? 1.0f : 0.0f;
      UpdateYState();
      UpdateXState();
  }
  ```
- **ì¥ì **:
  - ì…ë ¥ ì†ì‹¤ ë°©ì§€
  - Physicsì™€ Input ë™ê¸°í™”
  - í”„ë ˆì„ ë…ë¦½ì  ê²Œì„í”Œë ˆì´
- **ì‚°ì—… í‘œì¤€**: AAA ê²Œì„ì—ì„œ ì‚¬ìš©í•˜ëŠ” íŒ¨í„´

### 2. **ObjectPool êµ¬í˜„** â­â­â­â­â­
- **ìœ„ì¹˜**: Common/ObjectPool.cs
- **ë‚´ìš©**: Generic ê¸°ë°˜ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í’€ë§ ì‹œìŠ¤í…œ
- **ì„±ëŠ¥ íš¨ê³¼**:
  - GC Allocation 90% ê°ì†Œ (ì¶”ì •)
  - ë°œì‚¬ì²´ ìƒì„± ì‹œ í”„ë ˆì„ ë“œë¡­ ë°©ì§€
- **í™•ì¥ì„±**: ëª¨ë“  MonoBehaviourì— ì ìš© ê°€ëŠ¥

### 3. **ë¹„ë™ê¸° LLM ì¶”ë¡  ì•„í‚¤í…ì²˜** â­â­â­â­â­
- **ìœ„ì¹˜**: Controller/LLMInferenceManager.cs, Controller/LLMWorkerThread.cs
- **ë‚´ìš©**:
  - ì›Œì»¤ ìŠ¤ë ˆë“œ + ë©”ì¸ ìŠ¤ë ˆë“œ ë””ìŠ¤íŒ¨ì¹˜ íŒ¨í„´
  - Session ê¸°ë°˜ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
  - Tool Call ë™ì  ì‹¤í–‰
- **ê¸°ìˆ ì  ìš°ìˆ˜ì„±**:
  ```csharp
  _mainThreadActions.Enqueue(() =>
  {
      OnWorkerCompleted(req, output);
  });
  ```
  - Unity API ìŠ¤ë ˆë“œ ì•ˆì „ì„± í™•ë³´
  - ë³µì¡í•œ AI í†µí•©ì„ ê¹”ë”í•˜ê²Œ ì²˜ë¦¬
- **í˜ì‹ ì„±**: OpenVINO Unity í†µí•© ë“œë¬¸ ì‚¬ë¡€

---

## ğŸ“Š ë¶€ë¬¸ë³„ ë ˆì´ë” ì°¨íŠ¸ (ì‹œê°í™”ìš© ë°ì´í„°)

```
Architecture:     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 7.5
Readability:      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 6.0
Performance:      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 7.0
Gameplay:         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 8.0
Unity Practices:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 7.5
Animation/FSM:    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 7.0
Safety:           â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 6.0
Scalability:      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 7.0
Clean Code:       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 6.5
AI Integration:   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘ 7.5
```

---

## ğŸ“ ìµœì¢… ì½”ë©˜íŠ¸

ì´ í”„ë¡œì íŠ¸ëŠ” **Unity ê²Œì„ ê°œë°œì˜ ì¤‘ê¸‰~ê³ ê¸‰ ìˆ˜ì¤€**ì˜ ì½”ë“œ í’ˆì§ˆì„ ë³´ì—¬ì¤ë‹ˆë‹¤. íŠ¹íˆ ë‹¤ìŒ ë¶€ë¶„ì´ ì¸ìƒì ì…ë‹ˆë‹¤:

1. **Input ì‹œìŠ¤í…œ**: ë²„í¼ë§ê³¼ ìŠ¤ëƒ…ìƒ·ìœ¼ë¡œ ì •í™•í•œ ì¡°ì‘ê° êµ¬í˜„
2. **AI í†µí•©**: OpenVINOë¥¼ Unityì— ì•ˆì •ì ìœ¼ë¡œ í†µí•©í•œ ì 
3. **FSM/BehaviorTree**: Playerì™€ Enemyì˜ ëª…í™•í•œ êµ¬ì¡° ë¶„ë¦¬

ê·¸ëŸ¬ë‚˜ **ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP) ìœ„ë°˜**, **Null ì•ˆì „ì„± ë¶€ì¡±**, **Magic Number ë‚¨ìš©**ì´ ì£¼ìš” ê¸°ìˆ  ë¶€ì±„ì…ë‹ˆë‹¤. ì¦‰ì‹œ ê°œì„  í•­ëª©ë¶€í„° ì§„í–‰í•˜ë©´ ì½”ë“œ í’ˆì§ˆì„ **8.5/10 ì´ìƒ**ìœ¼ë¡œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì¶”ì²œ ìš°ì„ ìˆœìœ„**:
1. PlayerBehavior ë¦¬íŒ©í† ë§ (1ì£¼)
2. Null ì²´í¬ ë³´ê°• (3ì¼)
3. ìƒìˆ˜ ì •ì˜ (2ì¼)
4. ë¬¸ì„œí™” (1ì£¼)
5. ë°ì´í„° ê¸°ë°˜ ì „í™˜ (ì¤‘ì¥ê¸°)

---

**í‰ê°€ì**: GitHub Copilot (Claude Sonnet 4.5)  
**í‰ê°€ ì¼ì‹œ**: 2025-12-12  
**ì½”ë“œë² ì´ìŠ¤ ë²„ì „**: í˜„ì¬ ë¸Œëœì¹˜ HEAD  
**ë¼ì¸ ìˆ˜**: ì•½ 5,000ì¤„ (Assets/Scripts)
