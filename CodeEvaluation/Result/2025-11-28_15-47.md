# Unity C# ì½”ë“œ í’ˆì§ˆ í‰ê°€ ë³´ê³ ì„œ

**í‰ê°€ ì¼ì‹œ**: 2025-11-28 15:47  
**í”„ë¡œì íŠ¸**: project-magic  
**í‰ê°€ ë²”ìœ„**: Assets/Scripts í´ë” ë‚´ í•µì‹¬ ë¡œì§

---

## ğŸ“Œ 1. Architecture & Unity Component Design

### í‰ê°€
**ì ìˆ˜: 7.5/10**

#### âœ… ì˜ëœ ì 
- **FSMê³¼ Behavior Tree íŒ¨í„´ ë¶„ë¦¬**: í”Œë ˆì´ì–´ëŠ” FSM, ì ì€ BTë¥¼ ì‚¬ìš©í•˜ì—¬ ê° ì‹œìŠ¤í…œ íŠ¹ì„±ì— ë§ê²Œ êµ¬ì¡°í™”
- **Component ê¸°ë°˜ ì„¤ê³„**: `HealthSystem`, `AttackSystem`, `AnimationController` ë“±ìœ¼ë¡œ ì±…ì„ ë¶„ë¦¬
- **ScriptableObject í™œìš©**: `CharacterStats`, `SkillData`ë¡œ ë°ì´í„°ì™€ ë¡œì§ ë¶„ë¦¬ê°€ ì˜ ë˜ì–´ìˆìŒ
- **ìƒëª…ì£¼ê¸° ì ì ˆí•œ ì‚¬ìš©**: `Awake`ì—ì„œ ì»´í¬ë„ŒíŠ¸ ìºì‹±, `Start`ì—ì„œ ì´ˆê¸°í™”, `FixedUpdate`ì—ì„œ ë¬¼ë¦¬ ë¡œì§

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Unity ìƒëª…ì£¼ê¸° í˜¼ìš© ë¬¸ì œ**
```csharp
// PlayerBehavior.cs
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput;
    _snapShotjumpInput = _jumpInput ? 1.0f : 0.0f;
    UpdateYState();
    UpdateXState();
}

void Update()
{
    TickUpdate();  // íƒ€ì´ë¨¸ë§Œ ì—…ë°ì´íŠ¸
}
```
**ë¬¸ì œ**: ìƒíƒœ ë³€ê²½ì€ `FixedUpdate`, íƒ€ì´ë¨¸ëŠ” `Update`ì—ì„œ ì²˜ë¦¬í•˜ì—¬ ë™ê¸°í™” ë¬¸ì œ ê°€ëŠ¥ì„±
**ê°œì„ ì•ˆ**:
```csharp
void Update()
{
    TickUpdate();
    // Input snapshotì€ Updateì—ì„œ
    _snapShotMoveInput = _moveInput;
    _snapShotjumpInput = _jumpInput ? 1.0f : 0.0f;
}

void FixedUpdate()
{
    // ë¬¼ë¦¬ ê¸°ë°˜ ìƒíƒœ ì—…ë°ì´íŠ¸ë§Œ
    UpdateYState();
    UpdateXState();
}
```

**2. PlayerState enum ì •ì˜ ìœ„ì¹˜ ë¶ˆëª…í™•**
- `PlayerState` enumì´ ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬(`SPUM_Prefabs.cs`)ì— ì •ì˜ë˜ì–´ ìˆì–´ í™•ì¥ì„± ì €í•´
- EnemyëŠ” ë³„ë„ `EnemyBehaviorState`ë¥¼ ê°€ì§€ëŠ”ë° ì¼ê´€ì„± ë¶€ì¡±

**ê°œì„ ì•ˆ**: Constants í´ë”ì— í†µì¼ëœ State enum ê´€ë¦¬
```csharp
// Assets/Scripts/Constants/CharacterStates.cs
public enum PlayerState { IDLE, MOVE, ATTACK, JUMP, DAMAGED, DEATH }
public enum EnemyState { IDLE, PATROL, DETECTION, CHASE, ATTACK, DAMAGED, DEATH }
```

**3. FSM ë‚´ë¶€ í´ë˜ìŠ¤ ê³¼ë‹¤**
- `PlayerBehavior`ì— 7ê°œì˜ inner classë¡œ FSM State êµ¬í˜„ â†’ íŒŒì¼ì´ 425ì¤„ë¡œ ë¹„ëŒ€í™”
- í…ŒìŠ¤íŠ¸, ì¬ì‚¬ìš©, í™•ì¥ì´ ì–´ë ¤ì›€

**ê°œì„ ì•ˆ**:
```
Assets/Scripts/Player/States/
    â”œâ”€â”€ PlayerStateBase.cs       // abstract base
    â”œâ”€â”€ StateIdle.cs
    â”œâ”€â”€ StateMove.cs
    â”œâ”€â”€ StateAttack.cs
    â”œâ”€â”€ StateDamaged.cs
    â””â”€â”€ StateDeath.cs
```

---

## ğŸ“Œ 2. Code Readability & Maintainability

### í‰ê°€
**ì ìˆ˜: 6.5/10**

#### âœ… ì˜ëœ ì 
- **SerializeField ì†ì„± ì‚¬ìš©**: Inspector ë…¸ì¶œ í•„ë“œ ëª…í™•
- **Header ì†ì„±**: `[Header("Stats")]`, `[Header("Attack")]` ë“±ìœ¼ë¡œ ê·¸ë£¹í™”
- ì¼ê´€ëœ camelCase/PascalCase ëª…ëª…

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. ë„¤ì´ë° ë¶ˆì¼ì¹˜**
```csharp
// PlayerBehavior.cs
float _moveInput;           // ì–¸ë”ìŠ¤ì½”ì–´ private
bool _jumpInput;
float _snapShotMoveInput;   // ì¹´ë©œì¼€ì´ìŠ¤
```
**ë¬¸ì œ**: ê°™ì€ private í•„ë“œì¸ë° ì¼ë¶€ëŠ” `_`, ì¼ë¶€ëŠ” ì¼ë°˜ ì´ë¦„
**ê°œì„ ì•ˆ**: Unity C# ì»¨ë²¤ì…˜ í†µì¼
```csharp
private float moveInput;
private bool jumpInput;
private float snapshotMoveInput;  // camelCase ì¼ê´€ì„±
```

**2. Magic Number ê³¼ë‹¤**
```csharp
// AoeSkillLogic.cs
RaycastHit2D hit = Physics2D.CircleCast(
    origin.position, 
    0.2f,  // â† í•˜ë“œì½”ë”©
    direction,
    attack.range,
    targetLayerMask
);

// EnemyBehavior.cs - ActionPatrol
pos.x += direction * (ctx.colliderGround.size.x + 0.05f);  // â† 0.05f?
```
**ê°œì„ ì•ˆ**:
```csharp
private const float DETECTION_RADIUS = 0.2f;
private const float GROUND_CHECK_OFFSET = 0.05f;

RaycastHit2D hit = Physics2D.CircleCast(
    origin.position, 
    DETECTION_RADIUS,
    direction,
    attack.range,
    targetLayerMask
);
```

**3. ì£¼ì„ ë¶€ì¡± ë° TODO ê´€ë¦¬ ë¯¸í¡**
```csharp
// PlayerBehavior.cs BuildStateController()
// ToDo
// attack ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì¤‘ ì›€ì§ì´ë©´ ìºë¦­í„° ì¤‘ì‹¬ì´ í”ë“¤ë¦¬ëŠ”ë“¯?
// attack ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì—ëŠ” ì›€ì§ì´ì§€ ëª»í•˜ë„ë¡ ì¡°ì •í•„ìš”
{PlayerState.ATTACK, new StateAttack(this)},
```
**ë¬¸ì œ**: 
- ì½”ë“œ ë‚´ TODOê°€ ì‹¤í–‰ë˜ì§€ ì•Šê³  ë°©ì¹˜ë¨
- ì£¼ìš” ë¡œì§ì— ì„¤ëª… ì£¼ì„ ì—†ìŒ

**ê°œì„ ì•ˆ**:
```csharp
/// <summary>
/// ê³µê²© ìƒíƒœ. ê³µê²© ëª¨ì…˜ ì¤‘ì—ëŠ” ì´ë™ ì…ë ¥ì„ ë¬´ì‹œí•¨
/// TODO: Issue #42 - ê³µê²© ì¤‘ ì´ë™ ì‹œ ìŠ¤í”„ë¼ì´íŠ¸ í”ë“¤ë¦¼ ìˆ˜ì • í•„ìš”
/// </summary>
{PlayerState.ATTACK, new StateAttack(this)},
```

**4. ì¤‘ë³µ ë¡œì§**
```csharp
// PlayerBehavior.StateMove + EnemyBehavior.ActionChase/ActionPatrol
// ëª¨ë‘ ë™ì¼í•œ FlipDirection + UpdateVelocity íŒ¨í„´
private void FlipDirection()
{
    Vector3 scale = ctx.transform.localScale;
    scale.x = -scale.x;
    ctx.transform.localScale = scale;
}

private void UpdateVelocity()
{
    Vector2 velocity = ctx.rb.linearVelocity;
    velocity.x = -ctx.transform.localScale.x * ctx.stats.moveSpeed;
    ctx.rb.linearVelocity = velocity;
}
```
**ê°œì„ ì•ˆ**: Utils í´ë˜ìŠ¤ë¡œ ê³µí†µí™”
```csharp
// Assets/Scripts/Utils/MovementHelper.cs
public static class MovementHelper
{
    public static void FlipSprite(Transform transform)
    {
        Vector3 scale = transform.localScale;
        scale.x = -scale.x;
        transform.localScale = scale;
    }

    public static void SetHorizontalVelocity(Rigidbody2D rb, float direction, float speed)
    {
        Vector2 velocity = rb.linearVelocity;
        velocity.x = direction * speed;
        rb.linearVelocity = velocity;
    }
}
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

### í‰ê°€
**ì ìˆ˜: 5.5/10**

#### âœ… ì˜ëœ ì 
- **GetComponent ìºì‹±**: `Awake()`ì—ì„œ ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë¥¼ ë¯¸ë¦¬ ìºì‹±
- **ObjectPool êµ¬í˜„**: `ObjectPool<T>` ì œë„¤ë¦­ìœ¼ë¡œ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ í’€ë§ ì‹œìŠ¤í…œ
- **Time.deltaTime ì‚¬ìš©**: íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸ì— ì¼ê´€ë˜ê²Œ ì‚¬ìš©

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. GC ìœ ë°œ - Tuple ì‚¬ìš©**
```csharp
// BehaviorTree.cs - ì£¼ì„ì— ì´ë¯¸ ì¸ì§€í•˜ê³  ìˆìŒ
// Todo
// íŠœí”Œë¡œ ë¦¬í„´í•˜ë©´ GC ë°œìƒí•œë‹¤ê³ í•¨ (ê°€ë” ëŠê¸°ëŠ” ì¦ìƒì´ ì´ê±° ë–„ë¬¸ì´ì—ˆëŠ”ë“¯)
public abstract Tuple<BTNode.State, string> Evaluate();
```
**ë¬¸ì œ**: ë§¤ í”„ë ˆì„ `FixedUpdate`ì—ì„œ `selectorRoot.Evaluate()` í˜¸ì¶œ â†’ ì§€ì†ì  GC
**ê°œì„ ì•ˆ** (ì´ë¯¸ ì£¼ì„ì— ì œì•ˆë˜ì–´ ìˆìŒ):
```csharp
public struct EvaluateResult
{
    public BTNode.State state;
    public string actionName;  // ë””ë²„ê·¸ìš©, Releaseì—ì„œëŠ” ì œê±° ê°€ëŠ¥
    
    public EvaluateResult(BTNode.State state, string actionName)
    {
        this.state = state;
        this.actionName = actionName;
    }
}

public abstract class ActionNode : BTNode
{
    public abstract EvaluateResult Evaluate();
}
```

**2. Queue ë°˜ë³µ Dequeue - ì ì¬ì  ë¬´í•œë£¨í”„**
```csharp
// PlayerBehavior.UpdateXState()
while (bufferXState.Count > 0)
{
    var newState = bufferXState.Dequeue();
    ChangeState(ref currentXState, newState);
    if (currentXState == PlayerState.DEATH) return;
}
```
**ë¬¸ì œ**: 
- State ë³€ê²½ ì¤‘ ë‹¤ì‹œ ê°™ì€ Stateê°€ ë²„í¼ì— ì¶”ê°€ë˜ë©´ ë¬´í•œë£¨í”„ ê°€ëŠ¥
- Queue í¬ê¸° ì œí•œ ì—†ìŒ

**ê°œì„ ì•ˆ**:
```csharp
private const int MAX_STATE_BUFFER = 5;

while (bufferXState.Count > 0)
{
    if (bufferXState.Count > MAX_STATE_BUFFER)
    {
        Logger.Write("State buffer overflow! Clearing...", "ERROR");
        bufferXState.Clear();
        break;
    }
    
    var newState = bufferXState.Dequeue();
    if (newState == currentXState) continue;  // ì¤‘ë³µ ë°©ì§€
    
    ChangeState(ref currentXState, newState);
    if (currentXState == PlayerState.DEATH) return;
}
```

**3. Update() ì—ì„œ ë¶ˆí•„ìš”í•œ Physics2D í˜¸ì¶œ**
```csharp
// EnemyBehavior.FixedUpdate()
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
}
```
**ë¬¸ì œ**: 
- BT Evaluation ë‚´ë¶€ì—ì„œ `Physics2D.CircleCast`, `OverlapBox` ë“±ì´ ë§¤ í”„ë ˆì„ í˜¸ì¶œë¨
- `ActionPatrol`ì—ì„œ 3ê°œì˜ Physics ì²´í¬ (ë²½/ë°”ë‹¥/ë²”ìœ„)

**ê°œì„ ì•ˆ**:
```csharp
// ì²´í¬ ì£¼ê¸° ë¶„ì‚°
private float physicsCheckInterval = 0.1f;
private float lastPhysicsCheck;

void FixedUpdate()
{
    if (Time.time - lastPhysicsCheck > physicsCheckInterval)
    {
        var (selectorResult, actionPath) = selectorRoot.Evaluate();
        lastPhysicsCheck = Time.time;
    }
}
```

**4. ObjectPool Get() ë¡œì§ ë¬¸ì œ**
```csharp
// ObjectPool.cs
public T Get()
{
    if (pool.Count > 0)
    {
        var obj = pool.Dequeue();
        return obj;
    }
    else
    {
        var obj = GameObject.Instantiate(prefab, parent);
        pool.Enqueue(obj);  // â† ì¦‰ì‹œ Enqueue? 
        return obj;
    }
}
```
**ë¬¸ì œ**: í’€ì´ ë¹„ì—ˆì„ ë•Œ ìƒˆ ê°ì²´ ìƒì„± í›„ ë°”ë¡œ Enqueueí•˜ë©´ ë‹¤ìŒ Get()ì—ì„œ ë¹„í™œì„± ìƒíƒœ ê°ì²´ê°€ ë‚˜ì˜´
**ê°œì„ ì•ˆ**:
```csharp
public T Get()
{
    T obj;
    if (pool.Count > 0)
    {
        obj = pool.Dequeue();
    }
    else
    {
        obj = GameObject.Instantiate(prefab, parent);
        Logger.Write($"ObjectPool expanded: {typeof(T).Name}", "WARNING");
    }
    obj.gameObject.SetActive(true);
    return obj;
}
```

**5. ë§¤ í”„ë ˆì„ Logger.Write í˜¸ì¶œ**
```csharp
// EnemyBehavior.FixedUpdate()
Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");

// AoeSkillLogic.OnTriggerEnter2D()
Logger.Write($"triggered layer info / layer={other.gameObject.layer}, layerBit={1 << other.gameObject.layer}, targetLayerMask={targetLayerMask}");
```
**ë¬¸ì œ**: ë¡œê·¸ ë¹Œë“œì— í¬í•¨ ì‹œ string interpolationìœ¼ë¡œ ë§¤ í”„ë ˆì„ GC ë°œìƒ
**ê°œì„ ì•ˆ**:
```csharp
#if UNITY_EDITOR
if (Logger.DEBUG)
{
    Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
}
#endif
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

### í‰ê°€
**ì ìˆ˜: 6/10**

#### âœ… ì˜ëœ ì 
- **Input Snapshot**: `_snapShotMoveInput`, `_snapShotjumpInput`ìœ¼ë¡œ í”„ë ˆì„ ì¼ê´€ì„± ë³´ì¥
- **Cooldown ì‹œìŠ¤í…œ**: `_hitRecoveryTimer`, `_attackRecoveryTimer`ë¡œ ì¤‘ë³µ ê³µê²© ë°©ì§€
- **ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹ **: `UnityEvent`ë¡œ ì‹œìŠ¤í…œ ê°„ ê²°í•©ë„ ë‚®ì¶¤

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Jump Input ì²˜ë¦¬ ë¬¸ì œ**
```csharp
// PlayerBehavior.cs
public void OnJump(InputValue value)
{
    if (value.isPressed && currentYState != PlayerState.InFlight)
        _jumpInput = true;
}

// StateInFlight.OnEnter()
ctx._jumpInput = false;  // â† ì í”„ ì§í›„ ë°”ë¡œ ë¦¬ì…‹
```
**ë¬¸ì œ**:
- Inputê³¼ State ê°±ì‹  íƒ€ì´ë° ë¶ˆì¼ì¹˜ë¡œ ì í”„ ì”¹í˜ ê°€ëŠ¥
- Jump buffer ë¯¸êµ¬í˜„ (ê°€ì´ë“œë¼ì¸ì—ì„œ ì–¸ê¸‰í•œ ë¬¸ì œ)

**ê°œì„ ì•ˆ**:
```csharp
public class PlayerBehavior : MonoBehaviour
{
    private float jumpBufferTime = 0.2f;
    private float jumpBufferCounter;
    
    void Update()
    {
        if (jumpBufferCounter > 0)
            jumpBufferCounter -= Time.deltaTime;
    }
    
    public void OnJump(InputValue value)
    {
        if (value.isPressed)
            jumpBufferCounter = jumpBufferTime;
    }
    
    // UpdateYState()ì—ì„œ
    case PlayerState.ReadyToJump:
        if (jumpBufferCounter > 0 && CheckGrounded())
        {
            ChangeState(ref currentYState, PlayerState.InFlight);
            jumpBufferCounter = 0;  // ì‚¬ìš© í›„ ë¦¬ì…‹
        }
        break;
}
```

**2. Attack ì¤‘ ì´ë™ ë¬¸ì œ (TODOì—ì„œ ì–¸ê¸‰)**
```csharp
// PlayerBehavior.BuildStateController()
// ToDo
// attack ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì¤‘ ì›€ì§ì´ë©´ ìºë¦­í„° ì¤‘ì‹¬ì´ í”ë“¤ë¦¬ëŠ”ë“¯?
// attack ì• ë‹ˆë©”ì´ì…˜ ì¤‘ì—ëŠ” ì›€ì§ì´ì§€ ëª»í•˜ë„ë¡ ì¡°ì •í•„ìš”
```
**í˜„ì¬ êµ¬ì¡°**: `StateAttack`ëŠ” Xì¶• ìƒíƒœì´ì§€ë§Œ `StateMove.Update()`ê°€ ê³„ì† í˜¸ì¶œë¨
**ê°œì„ ì•ˆ**:
```csharp
class StateAttack : FSMNode
{
    public override void OnEnter()
    {
        if (!ctx._attackRes) return;
        
        ctx.rb.linearVelocity = new Vector2(0, ctx.rb.linearVelocity.y);  // Xì†ë„ ì œê±°
        var clipTime = ctx.animController.PlayStateAnimation(PlayerState.ATTACK);
        ctx._attackRecoveryTimer = clipTime;
    }
    
    public override void Update()
    {
        // ê³µê²© ì¤‘ ì´ë™ ì…ë ¥ ë¬´ì‹œ
        // velocity.xëŠ” 0ìœ¼ë¡œ ìœ ì§€
    }
}
```

**3. Ground Check ë¯¸í¡**
```csharp
bool CheckGrounded()
{
    return colliderGround.IsTouchingLayers(layerGround.value);
}
```
**ë¬¸ì œ**:
- Collider ì ‘ì´‰ë§Œ í™•ì¸ â†’ ìºë¦­í„°ê°€ ì‚´ì§ ë– ìˆì–´ë„ true ê°€ëŠ¥
- Raycast ê¸°ë°˜ ì²´í¬ê°€ ë” ì •í™•

**ê°œì„ ì•ˆ**:
```csharp
[SerializeField] private Vector2 groundCheckSize = new Vector2(0.8f, 0.1f);
[SerializeField] private float groundCheckDistance = 0.1f;

bool CheckGrounded()
{
    Vector2 pos = transform.position;
    pos.y -= colliderGround.bounds.extents.y + groundCheckDistance;
    
    return Physics2D.OverlapBox(pos, groundCheckSize, 0f, layerGround);
}
```

**4. Animation Sync ë¬¸ì œ**
```csharp
// EnemyBehavior.ListenerAttack()
void ListenerAttack(int attackIndex)
{
    animController.PlayStateAnimation(PlayerState.ATTACK);  // â† Enemyì¸ë° PlayerState?
}
```
**ë¬¸ì œ**: íƒ€ì… ë¶ˆì¼ì¹˜ë¡œ í˜¼ë™ ìœ ë°œ
**ê°œì„ ì•ˆ**: ë³„ë„ `EnemyState` enum ì‚¬ìš©

**5. Null ë°©ì–´ ë¶€ì¡±**
```csharp
// PlayerBehavior.ListenerHit()
void ListenerHit(Vector2 knockback)
{
    if (_hitRecoveryTimer > 0) return;

    _hitForce = knockback;
    bufferXState.Enqueue(PlayerState.DAMAGED);
}
```
**ë¬¸ì œ**: `IsAlive` ì²´í¬ ì—†ì´ ë¬´ì¡°ê±´ DAMAGED ìƒíƒœ ì¶”ê°€
**ê°œì„ ì•ˆ**:
```csharp
void ListenerHit(Vector2 knockback)
{
    if (!IsAlive || _hitRecoveryTimer > 0) return;
    
    _hitForce = knockback;
    bufferXState.Enqueue(PlayerState.DAMAGED);
}
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

### í‰ê°€
**ì ìˆ˜: 7/10**

#### âœ… ì˜ëœ ì 
- **GetComponent ìºì‹±**: Awakeì—ì„œ ì¼ê´„ ì²˜ë¦¬
- **SerializeField + Header/Tooltip**: Inspector ê°€ë…ì„± ìš°ìˆ˜
- **Gizmos í™œìš©**: ì—ë””í„°ì—ì„œ ë””ë²„ê¹… ë²”ìœ„ ì‹œê°í™”
- **Time.deltaTime ì ìš©**: í”„ë ˆì„ ë…ë¦½ì  íƒ€ì´ë¨¸

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Rigidbody.linearVelocity ì§ì ‘ ìˆ˜ì •**
```csharp
// StateMove.UpdateVelocity()
Vector2 velocity = ctx.rb.linearVelocity;
velocity.x = ctx._snapShotMoveInput * ctx.stats.moveSpeed;
ctx.rb.linearVelocity = velocity;  // â† ì§ì ‘ í• ë‹¹
```
**ë¬¸ì œ**: ë¬¼ë¦¬ ì—”ì§„ê³¼ ì¶©ëŒ, AddForce ê¶Œì¥
**ê°œì„ ì•ˆ**:
```csharp
// ì´ë™ì€ velocity ì§ì ‘ ì„¤ì • OK (ì •í™•í•œ ì†ë„ ì œì–´)
// ì í”„/ë„‰ë°±ì€ AddForce ì‚¬ìš©
Vector2 targetVelocity = new Vector2(
    ctx._snapShotMoveInput * ctx.stats.moveSpeed,
    ctx.rb.linearVelocity.y
);
ctx.rb.linearVelocity = targetVelocity;
```
(í˜„ì¬ êµ¬ì¡°ëŠ” ì‹¤ì€ ê´œì°®ìŒ, ë‹¤ë§Œ ì£¼ì„ìœ¼ë¡œ ì˜ë„ ëª…ì‹œ í•„ìš”)

**2. Magic Number ëŒ€ì‹  SerializeField**
```csharp
// PlayerBehavior.UpdateYState()
if ((rb.linearVelocity.y <= (Mathf.Epsilon + landingVelocityMargin)) && CheckGrounded())
```
**ë¬¸ì œ**: `Mathf.Epsilon`ì´ ë­”ì§€ ë¶ˆëª…í™•
**ê°œì„ ì•ˆ**:
```csharp
[SerializeField] 
[Tooltip("ì°©ì§€ íŒì • ì†ë„ ì„ê³„ê°’. ì´ ê°’ ì´í•˜ì¼ ë•Œ ì°©ì§€ë¡œ ì¸ì‹")]
private float landingVelocityThreshold = 0.1f;

if (rb.linearVelocity.y <= landingVelocityThreshold && CheckGrounded())
```

**3. LayerMask ì‚¬ìš© ì¼ê´€ì„±**
```csharp
// PlayerBehavior.cs
colliderGround.IsTouchingLayers(layerGround.value);

// Attack.cs
Physics2D.OverlapCircle(attackBox, hitAreaRadius, targetLayerMask);
```
**ë¬¸ì œ**: í•œ ê³³ì€ `.value`, í•œ ê³³ì€ ì§ì ‘ ì‚¬ìš©
**ê°œì„ ì•ˆ**: LayerMaskëŠ” ì•”ì‹œì  int ë³€í™˜ë˜ë¯€ë¡œ ì¼ê´€ë˜ê²Œ ì§ì ‘ ì‚¬ìš©

**4. Prefab ì°¸ì¡° ë¶€ì¡±**
```csharp
[SerializeField] public GameObject skillPrefab;  // CharacterStats.cs
```
**ë¬¸ì œ**: 
- `GameObject`ë³´ë‹¤ëŠ” ì»´í¬ë„ŒíŠ¸ íƒ€ì…ìœ¼ë¡œ ì§ì ‘ ì°¸ì¡°
- `public` í•„ë“œëŠ” ìº¡ìŠí™” ìœ„ë°˜

**ê°œì„ ì•ˆ**:
```csharp
[SerializeField] private SkillLogic skillPrefab;  // ì»´í¬ë„ŒíŠ¸ ì§ì ‘ ì°¸ì¡°
public SkillLogic SkillPrefab => skillPrefab;    // readonly í”„ë¡œí¼í‹°
```

**5. Animator Parameter Hash ë¯¸ì‚¬ìš©**
```csharp
// AnimationController.csì— Animator í˜¸ì¶œë§Œ ìˆê³  hash ìµœì í™” ì—†ìŒ
```
**ê°œì„ ì•ˆ**:
```csharp
private static readonly int AnimState_Idle = Animator.StringToHash("Idle");
private static readonly int AnimState_Move = Animator.StringToHash("Move");

animator.SetBool(AnimState_Move, true);  // stringë³´ë‹¤ ë¹ ë¦„
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

### í‰ê°€
**ì ìˆ˜: 7/10**

#### âœ… ì˜ëœ ì 
- **FSMê³¼ BT ì ì ˆí•œ ë¶„ë¦¬**: í”Œë ˆì´ì–´(ê²°ì •ì ) vs ì (ìš°ì„ ìˆœìœ„ ê¸°ë°˜)
- **Event ê¸°ë°˜ í†µì‹ **: `EventHit`, `EventDeath`, `EventAttack`ë¡œ ëŠìŠ¨í•œ ê²°í•©
- **Animation í´ë¦½ ì‹œê°„ ë°˜í™˜**: `PlayStateAnimation()`ì´ clip timeì„ ë¦¬í„´í•˜ì—¬ ì¿¨ë‹¤ìš´ ë™ê¸°í™”

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Animationê³¼ State ë™ê¸°í™” ë¶€ì¡±**
```csharp
// PlayerBehavior.StateAttack
public override void OnEnter()
{
    if (!ctx._attackRes) return;

    var clipTime = ctx.animController.PlayStateAnimation(PlayerState.ATTACK);
    ctx._attackRecoveryTimer = clipTime;
}

public override void Update()
{
    // â† ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ ì´ë²¤íŠ¸ ì—†ìŒ
}
```
**ë¬¸ì œ**:
- íƒ€ì´ë¨¸ë¡œë§Œ ì¢…ë£Œ íŒë‹¨ â†’ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë‹¨ ì‹œ ë¶ˆì¼ì¹˜
- Animation Event ë¯¸í™œìš©

**ê°œì„ ì•ˆ**:
```csharp
// Animatorì— AttackFinished() ì´ë²¤íŠ¸ ì¶”ê°€
public void OnAttackAnimationFinished()
{
    _attackRecoveryTimer = 0;  // ì¦‰ì‹œ ì¢…ë£Œ
}
```

**2. FSM State ì „í™˜ ë¡œì§ ë³µì¡**
```csharp
// PlayerBehavior.UpdateXState()
switch (currentXState)
{
    case PlayerState.DEATH:
        break;
    case PlayerState.DAMAGED:
        ChangeState(ref currentXState, PlayerState.IDLE);
        break;
    case PlayerState.ATTACK:
        if (_attackRecoveryTimer <= 0)
            ChangeState(ref currentXState, PlayerState.IDLE);
        break;
    // ...
}
```
**ë¬¸ì œ**: ê° Stateì˜ ì „í™˜ ì¡°ê±´ì´ ì™¸ë¶€ì— í•˜ë“œì½”ë”©
**ê°œì„ ì•ˆ**: State ë‚´ë¶€ì— `CanTransition()` ë©”ì„œë“œ
```csharp
public abstract class FSMNode
{
    public abstract void OnEnter();
    public abstract void Update();
    public abstract void OnExit();
    public virtual bool CanExit() => true;  // ì „í™˜ ê°€ëŠ¥ ì—¬ë¶€
}

class StateAttack : FSMNode
{
    public override bool CanExit()
    {
        return ctx._attackRecoveryTimer <= 0;
    }
}
```

**3. Behavior Tree ë§¤ í”„ë ˆì„ ì „ì²´ ìˆœíšŒ**
```csharp
// EnemyBehavior.FixedUpdate()
var (selectorResult, actionPath) = selectorRoot.Evaluate();
```
**ë¬¸ì œ**:
- 7ê°œì˜ Sequenceë¥¼ ë§¤ë²ˆ í‰ê°€ (DEATH, DAMAGED, DETECTION, ...)
- ëŒ€ë¶€ë¶„ì€ Failureë¡œ ëë‚˜ëŠ”ë° ë¹„íš¨ìœ¨

**ê°œì„ ì•ˆ**:
```csharp
// í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ë…¸ë“œ ìºì‹±
private SequenceNode currentSequence;

void FixedUpdate()
{
    if (currentSequence != null)
    {
        var (state, path) = currentSequence.Evaluate();
        if (state == BTNode.State.Running) return;
        currentSequence = null;
    }
    
    // ìƒˆ ë…¸ë“œ íƒìƒ‰
    var (result, actionPath) = selectorRoot.Evaluate();
    if (result == BTNode.State.Running)
        currentSequence = FindRunningSequence();
}
```

**4. AnimationController ë¸”ë™ë°•ìŠ¤í™”**
```csharp
// AnimationController.cs - SPUM ë¼ì´ë¸ŒëŸ¬ë¦¬ ì˜ì¡´
_prefabs.PlayAnimation(state, index);
```
**ë¬¸ì œ**: 
- ì™¸ë¶€ ì—ì…‹ì— ê°•í•˜ê²Œ ê²°í•©
- êµì²´ ì‹œ ì „ì²´ ë¦¬íŒ©í† ë§ í•„ìš”

**ê°œì„ ì•ˆ**: Adapter íŒ¨í„´
```csharp
public interface IAnimationPlayer
{
    float PlayAnimation(PlayerState state, int index);
    float GetClipTime(PlayerState state, int index);
}

public class SPUMAnimationAdapter : IAnimationPlayer
{
    private SPUM_Prefabs _prefabs;
    
    public float PlayAnimation(PlayerState state, int index)
    {
        _prefabs.PlayAnimation(state, index);
        return _prefabs.GetClipTime(state, index);
    }
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

### í‰ê°€
**ì ìˆ˜: 5/10**

#### âœ… ì˜ëœ ì 
- **TryGetComponent í™œìš©**: `Attack.cs`ì—ì„œ `TryGetComponent<HealthSystem>` ì‚¬ìš©
- **Invincibility Frame**: ë¬´ì  ì‹œê°„ìœ¼ë¡œ ì—°ì† í”¼ê²© ë°©ì§€
- **IsAlive í”Œë˜ê·¸**: ì£½ì€ í›„ ì²˜ë¦¬ ë°©ì§€

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Null Reference ìœ„í—˜**
```csharp
// PlayerBehavior.Awake()
stats = GetComponentInChildren<StatsContainer>().stats;
rb = GetComponentInChildren<Rigidbody2D>();
```
**ë¬¸ì œ**: `GetComponentInChildren` ì‹¤íŒ¨ ì‹œ NullReferenceException
**ê°œì„ ì•ˆ**:
```csharp
void Awake()
{
    if (!TryGetComponentInChildren(out StatsContainer container))
    {
        Logger.Write($"StatsContainer not found on {gameObject.name}", "ERROR");
        enabled = false;
        return;
    }
    stats = container.stats;
    
    rb = GetComponentInChildren<Rigidbody2D>();
    Debug.Assert(rb != null, "Rigidbody2D is required!", this);
}
```

**2. Array Index ê²€ì¦ ë¶€ì¡±**
```csharp
// AttackSystem.ExecuteAttack()
if (attackIndex >= attackContainer.Count)
{
    Logger.Write($"Invalid attack index: {attackIndex}", "ERROR");
    return false;
}
```
**ë¬¸ì œ**: ìŒìˆ˜ ì¸ë±ìŠ¤ ì²´í¬ ì—†ìŒ
**ê°œì„ ì•ˆ**:
```csharp
if (attackIndex < 0 || attackIndex >= attackContainer.Count)
{
    Logger.Write($"Invalid attack index: {attackIndex} (valid: 0~{attackContainer.Count-1})", "ERROR");
    return false;
}
```

**3. Event Unsubscribe ëˆ„ë½**
```csharp
// PlayerBehavior.Start()
healthSystem.EventHit.AddListener(ListenerHit);
healthSystem.EventDeath.AddListener(ListenerDeath);

// â† OnDestroy()ì—ì„œ RemoveListener ì—†ìŒ
```
**ë¬¸ì œ**: ê°ì²´ íŒŒê´´ í›„ ë©”ëª¨ë¦¬ ë¦­ ê°€ëŠ¥
**ê°œì„ ì•ˆ**:
```csharp
void OnDestroy()
{
    if (healthSystem != null)
    {
        healthSystem.EventHit.RemoveListener(ListenerHit);
        healthSystem.EventDeath.RemoveListener(ListenerDeath);
    }
    if (attackSystem != null)
    {
        attackSystem.EventAttack.RemoveListener(ListenerAttack);
    }
}
```

**4. Physics Layer Mask ê²€ì¦ ë¶€ì¡±**
```csharp
// AoeSkillLogic.OnTriggerEnter2D()
if (((1 << other.gameObject.layer) & targetLayerMask) != 0)
```
**ë¬¸ì œ**: 
- layer ê°’ì´ 32 ì´ìƒì´ë©´ bit shift overflow
- Unity LayerëŠ” 0~31ë§Œ ìœ íš¨

**ê°œì„ ì•ˆ**:
```csharp
int layer = other.gameObject.layer;
if (layer < 0 || layer > 31)
{
    Logger.Write($"Invalid layer: {layer}", "ERROR");
    return;
}

if (((1 << layer) & targetLayerMask) != 0)
```

**5. Initialization ìˆœì„œ ë¬¸ì œ**
```csharp
// AttackSystem.Start()
poolContainer = new Dictionary<int, object>();
var goContainer = ContainerController.Instance.GetContainer(ContainerName.VFX.ToString());
```
**ë¬¸ì œ**: `ContainerController.Instance`ê°€ ì´ˆê¸°í™” ì•ˆ ëìœ¼ë©´ NullReference
**ê°œì„ ì•ˆ**:
```csharp
protected virtual void Start()
{
    if (ContainerController.Instance == null)
    {
        Logger.Write("ContainerController not initialized yet!", "ERROR");
        StartCoroutine(DelayedInitialize());
        return;
    }
    InitializePools();
}

IEnumerator DelayedInitialize()
{
    yield return new WaitUntil(() => ContainerController.Instance != null);
    InitializePools();
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

### í‰ê°€
**ì ìˆ˜: 7.5/10**

#### âœ… ì˜ëœ ì 
- **ScriptableObject ê¸°ë°˜**: ìºë¦­í„° ìŠ¤íƒ¯, ìŠ¤í‚¬ì„ ë°ì´í„°ë¡œ ë¶„ë¦¬í•˜ì—¬ í™•ì¥ ìš©ì´
- **ì œë„¤ë¦­ ObjectPool**: ì–´ë–¤ MonoBehaviourë“  í’€ë§ ê°€ëŠ¥
- **AttackType enum + routing**: Melee/Projectile/Aoe ì¶”ê°€ ì‹œ switchë¬¸ë§Œ ìˆ˜ì •
- **Event ê¸°ë°˜**: HealthSystemê³¼ Behaviorê°€ ë…ë¦½ì 

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Hard-coded State Mapping**
```csharp
// PlayerBehavior.BuildStateController()
stateContainer = new Dictionary<PlayerState, FSMNode>
{
    {PlayerState.DEATH, new StateDeath(this)},
    {PlayerState.DAMAGED, new StateHit(this)},
    {PlayerState.ATTACK, new StateAttack(this)},
    // ...
};
```
**ë¬¸ì œ**: 
- ìƒˆ State ì¶”ê°€ ì‹œ 3ê³³ ìˆ˜ì • (enum, BuildState, switchë¬¸)
- ëŸ°íƒ€ì„ ë³€ê²½ ë¶ˆê°€

**ê°œì„ ì•ˆ**: Attribute ê¸°ë°˜ ìë™ ë“±ë¡
```csharp
[State(PlayerState.ATTACK)]
public class StateAttack : FSMNode<PlayerBehavior>
{
    // ...
}

// PlayerBehavior.BuildStateController()
void BuildStateController()
{
    var stateTypes = Assembly.GetExecutingAssembly()
        .GetTypes()
        .Where(t => t.GetCustomAttribute<StateAttribute>() != null);
    
    foreach (var type in stateTypes)
    {
        var attr = type.GetCustomAttribute<StateAttribute>();
        var instance = (FSMNode)Activator.CreateInstance(type, this);
        stateContainer[attr.State] = instance;
    }
}
```

**2. Skill í™•ì¥ì„± ë¶€ì¡±**
```csharp
// PlayerBehavior.cs
public void OnSkillW(InputValue value)
{
    _attackRes = attackSystem.ExecuteAttack(1, this.transform, layerEnemy);
}

public void OnSkillE(InputValue value)
{
    _attackRes = attackSystem.ExecuteAttack(2, this.transform, layerEnemy);
}
```
**ë¬¸ì œ**: ìŠ¤í‚¬ ì¶”ê°€í•  ë•Œë§ˆë‹¤ ë©”ì„œë“œ ì¶”ê°€ í•„ìš”
**ê°œì„ ì•ˆ**:
```csharp
[SerializeField] private KeyCode[] skillKeys = { KeyCode.Q, KeyCode.W, KeyCode.E, KeyCode.R };

void Update()
{
    for (int i = 0; i < skillKeys.Length; i++)
    {
        if (Input.GetKeyDown(skillKeys[i]))
        {
            attackSystem.ExecuteAttack(i + 1, transform, layerEnemy);
        }
    }
}
```
ë˜ëŠ” ìƒˆ Input System í™œìš©:
```csharp
public void OnSkill(InputValue value)
{
    int skillIndex = (int)value.Get<float>();  // Composite binding
    attackSystem.ExecuteAttack(skillIndex, transform, layerEnemy);
}
```

**3. Enemy AI ë‹¤ì–‘í™” ì–´ë ¤ì›€**
```csharp
// EnemyBehavior.cs - ëª¨ë“  ì ì´ ê°™ì€ BT êµ¬ì¡°
selectorRoot = new SelectorNode(
    new List<SequenceNode>()
    {
        sequenceContainer[EnemyBehaviorState.DEATH],
        sequenceContainer[EnemyBehaviorState.DAMAGED],
        // ...
    },
    "Root"            
);
```
**ë¬¸ì œ**: ë‹¤ë¥¸ íŒ¨í„´ì˜ ì (ì›ê±°ë¦¬, ë¹„í–‰ ë“±) ì¶”ê°€ ì‹œ ì½”ë“œ ë³µì‚¬ í•„ìš”
**ê°œì„ ì•ˆ**: ScriptableObjectë¡œ BT êµ¬ì„±
```csharp
[CreateAssetMenu(fileName = "Enemy AI", menuName = "Game/Enemy AI")]
public class EnemyAIConfig : ScriptableObject
{
    public List<BehaviorNodeData> behaviors;
}

[Serializable]
public class BehaviorNodeData
{
    public string actionType;  // "Patrol", "Chase", "RangedAttack" ë“±
    public float priority;
    public float detectionRange;
    // ...
}
```

**4. ì˜ì¡´ì„± ì—­ì „ ë¶€ì¬**
```csharp
// ëª¨ë“  í´ë˜ìŠ¤ê°€ GetComponentInChildrenìœ¼ë¡œ ì§ì ‘ ì°¸ì¡°
stats = GetComponentInChildren<StatsContainer>().stats;
healthSystem = GetComponentInChildren<HealthSystem>();
```
**ë¬¸ì œ**: ì»´í¬ë„ŒíŠ¸ êµ¬ì¡° ë³€ê²½ ì‹œ ì „ì²´ ìˆ˜ì •
**ê°œì„ ì•ˆ**: Dependency Injection (Zenject, VContainer ë“±)
```csharp
[Inject] private CharacterStats stats;
[Inject] private HealthSystem healthSystem;
[Inject] private AttackSystem attackSystem;
```

---

## ğŸ“Œ 9. Clean Code Practices

### í‰ê°€
**ì ìˆ˜: 6/10**

#### âœ… ì˜ëœ ì 
- **SRP ì˜ì‹**: HealthSystem, AttackSystem, AnimationController ë¶„ë¦¬
- **DRY**: ObjectPool ì œë„¤ë¦­í™”ë¡œ ì¬ì‚¬ìš©
- **ë„¤ì„ìŠ¤í˜ì´ìŠ¤**: (í™•ì¸ ì•ˆ ëì§€ë§Œ) í´ë” êµ¬ì¡°ëŠ” ê¹”ë”

#### âŒ ë¬¸ì œì  ë° ê°œì„ ì•ˆ

**1. Public í•„ë“œ ë‚¨ìš©**
```csharp
// CharacterStats.cs
[SerializeField] public string characterName;
[SerializeField] public float maxHealth;
[SerializeField] public float moveSpeed;
// ... 15ê°œ ì´ìƒì˜ public í•„ë“œ
```
**ë¬¸ì œ**: 
- SerializeFieldëŠ” ì´ë¯¸ Inspector ë…¸ì¶œ
- publicì€ ì™¸ë¶€ ìˆ˜ì • ê°€ëŠ¥ â†’ ìº¡ìŠí™” ìœ„ë°˜

**ê°œì„ ì•ˆ**:
```csharp
[SerializeField] private string characterName;
[SerializeField] private float maxHealth;

public string CharacterName => characterName;  // readonly
public float MaxHealth => maxHealth;
```

**2. ê¸´ ë©”ì„œë“œ**
```csharp
// EnemyBehavior.ActionPatrol.CheckFlipDirection() - 60ì¤„
private bool CheckFlipDirection()
{
    // condition1: ë²”ìœ„ ì²´í¬
    // condition2: ë²½ ì²´í¬
    // condition3: ë°”ë‹¥ ì²´í¬
    // ...
}
```
**ê°œì„ ì•ˆ**:
```csharp
private bool CheckFlipDirection()
{
    if (ctx._flipTimer > 0) return false;
    
    return IsOutOfPatrolRange() || IsWallAhead() || IsEdgeAhead();
}

private bool IsOutOfPatrolRange() { /* ... */ }
private bool IsWallAhead() { /* ... */ }
private bool IsEdgeAhead() { /* ... */ }
```

**3. Switchë¬¸ ì¤‘ë³µ**
```csharp
// PlayerBehavior.UpdateXState() - 20ì¤„ switch
// PlayerBehavior.UpdateYState() - 15ì¤„ switch
// AttackSystem.ExecuteAttack() - switchë¬¸
```
**ê°œì„ ì•ˆ**: Strategy íŒ¨í„´ ë˜ëŠ” Dictionary
```csharp
private Dictionary<PlayerState, Action> stateUpdateHandlers;

void BuildUpdateHandlers()
{
    stateUpdateHandlers = new Dictionary<PlayerState, Action>
    {
        { PlayerState.IDLE, HandleIdleUpdate },
        { PlayerState.MOVE, HandleMoveUpdate },
        // ...
    };
}

void UpdateXState()
{
    if (stateUpdateHandlers.TryGetValue(currentXState, out var handler))
    {
        handler?.Invoke();
    }
}
```

**4. ë¶ˆëª…í™•í•œ íƒ€ì… ìºìŠ¤íŒ…**
```csharp
// AttackSystem.ExecuteAttack()
ExecuteProjectileAttack(
    attack, origin, YPosAdjust, targetLayerMask, 
    (ObjectPool<ProjectileSkillLogic>)poolContainer[attackIndex]  // â† unsafe cast
);
```
**ê°œì„ ì•ˆ**: as + null check
```csharp
if (poolContainer[attackIndex] is ObjectPool<ProjectileSkillLogic> pool)
{
    ExecuteProjectileAttack(attack, origin, YPosAdjust, targetLayerMask, pool);
}
else
{
    Logger.Write($"Invalid pool type for attack {attackIndex}", "ERROR");
}
```

**5. í´ë” êµ¬ì¡° ê°œì„  ê°€ëŠ¥**
```
Assets/Scripts/
    â”œâ”€â”€ Player/          âœ…
    â”œâ”€â”€ Enemy/           âœ…
    â”œâ”€â”€ Common/          âœ… (Health, Attack)
    â”œâ”€â”€ Core/            â“ (FSM, BT - Commonìœ¼ë¡œ í•©ì¹˜ê¸°?)
    â”œâ”€â”€ Controller/      â“ (Singleton, Scene - Utils?)
    â””â”€â”€ Scriptable Object/  âŒ ê³µë°± í¬í•¨
```
**ê°œì„ ì•ˆ**:
```
Assets/Scripts/
    â”œâ”€â”€ Characters/
    â”‚   â”œâ”€â”€ Player/
    â”‚   â”œâ”€â”€ Enemy/
    â”‚   â””â”€â”€ Common/      (Health, Attack, Stats)
    â”œâ”€â”€ AI/
    â”‚   â”œâ”€â”€ FSM/
    â”‚   â””â”€â”€ BehaviorTree/
    â”œâ”€â”€ Skills/
    â”œâ”€â”€ Data/            (ScriptableObjects)
    â”œâ”€â”€ Utils/
    â””â”€â”€ Core/            (Singleton, Manager ë“±)
```

---

## ğŸ“Œ 10. ì¢…í•© ì ìˆ˜ ë° ê°œì„  ìš°ì„ ìˆœìœ„

### ì´ì : **6.6 / 10**

| í•­ëª© | ì ìˆ˜ | ë¹„ê³  |
|------|------|------|
| 1. Architecture | 7.5 | FSM/BT êµ¬ì¡° ìš°ìˆ˜, ë‚´ë¶€ í´ë˜ìŠ¤ ë¹„ëŒ€í™” |
| 2. Readability | 6.5 | ë„¤ì´ë° ë¶ˆì¼ì¹˜, ì¤‘ë³µ ì½”ë“œ, TODO ë°©ì¹˜ |
| 3. Performance | 5.5 | **GC ìœ ë°œ (Tuple), ë§¤ í”„ë ˆì„ Physics** |
| 4. Gameplay Logic | 6.0 | Jump buffer ë¶€ì¬, Attack ì¤‘ ì´ë™ |
| 5. Unity Best Practices | 7.0 | ìºì‹± ìš°ìˆ˜, Magic Number ê°œì„  í•„ìš” |
| 6. Animation/FSM/BT | 7.0 | Event í™œìš© ë¶€ì¡±, BT ìµœì í™” ì—¬ì§€ |
| 7. Safety | 5.0 | **Null ì²´í¬ ë¶€ì¡±, Event Leak** |
| 8. Scalability | 7.5 | ScriptableObject ìš°ìˆ˜, DI ë¶€ì¬ |
| 9. Clean Code | 6.0 | Public í•„ë“œ ë‚¨ìš©, ê¸´ ë©”ì„œë“œ |

---

### ğŸ”¥ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (High Priority)

#### 1ï¸âƒ£ **GC ìµœì í™” - Behavior Tree Tuple ì œê±°**
**ì˜í–¥ë„**: â­â­â­â­â­  
**ìœ„ì¹˜**: `Assets/Scripts/Core/BehaviorTree.cs`

```csharp
// âŒ í˜„ì¬ (ë§¤ í”„ë ˆì„ GC ë°œìƒ)
public abstract Tuple<BTNode.State, string> Evaluate();

// âœ… ê°œì„ 
public struct EvaluateResult
{
    public BTNode.State state;
    #if UNITY_EDITOR
    public string actionName;  // Releaseì—ì„œëŠ” ì œì™¸
    #endif
}

public abstract EvaluateResult Evaluate();
```

**ì´ìœ **: 
- EnemyBehaviorê°€ FixedUpdateë§ˆë‹¤ Tuple ìƒì„± â†’ GC ì••ë°•
- ì£¼ì„ì—ë„ ì¸ì§€ë˜ì–´ ìˆì§€ë§Œ ë¯¸í•´ê²° ìƒíƒœ

---

#### 2ï¸âƒ£ **Event Leak ë°©ì§€ - OnDestroy êµ¬í˜„**
**ì˜í–¥ë„**: â­â­â­â­  
**ìœ„ì¹˜**: `PlayerBehavior.cs`, `EnemyBehavior.cs`

```csharp
void OnDestroy()
{
    if (healthSystem != null)
    {
        healthSystem.EventHit.RemoveListener(ListenerHit);
        healthSystem.EventDeath.RemoveListener(ListenerDeath);
    }
    if (attackSystem != null)
    {
        attackSystem.EventAttack.RemoveListener(ListenerAttack);
    }
}
```

**ì´ìœ **: 
- Scene ì¬ë¡œë“œ ì‹œ ì´ë²¤íŠ¸ êµ¬ë…ì´ ëˆ„ì ë˜ì–´ ë©”ëª¨ë¦¬ ë¦­
- ë©€í‹°í”Œë ˆì´ì–´ í™˜ê²½ì—ì„œ ì¹˜ëª…ì 

---

#### 3ï¸âƒ£ **Jump Buffer êµ¬í˜„**
**ì˜í–¥ë„**: â­â­â­â­  
**ìœ„ì¹˜**: `PlayerBehavior.cs`

```csharp
private float jumpBufferTime = 0.2f;
private float jumpBufferCounter;

void Update()
{
    if (jumpBufferCounter > 0)
        jumpBufferCounter -= Time.deltaTime;
}

public void OnJump(InputValue value)
{
    if (value.isPressed)
        jumpBufferCounter = jumpBufferTime;
}

// UpdateYState()
case PlayerState.ReadyToJump:
    if (jumpBufferCounter > 0 && CheckGrounded())
    {
        ChangeState(ref currentYState, PlayerState.InFlight);
        jumpBufferCounter = 0;
    }
    break;
```

**ì´ìœ **: 
- í˜„ì¬ëŠ” ì •í™•í•œ íƒ€ì´ë°ì—ë§Œ ì í”„ ê°€ëŠ¥ â†’ ì¡°ì‘ê° ë‚˜ì¨
- Jump bufferëŠ” ê²Œì„ ëŠë‚Œ ê°œì„ ì˜ í•µì‹¬

---

### ğŸ”„ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Medium Priority)

#### 1ï¸âƒ£ **FSM State ì™¸ë¶€í™”**
**ëª©í‘œ**: PlayerBehavior íŒŒì¼ ë¶„ë¦¬ (425ì¤„ â†’ 100ì¤„ ì´í•˜)

```
Assets/Scripts/Player/States/
    â”œâ”€â”€ PlayerStateBase.cs
    â”œâ”€â”€ StateIdle.cs
    â”œâ”€â”€ StateMove.cs
    â”œâ”€â”€ StateAttack.cs
    â”œâ”€â”€ StateDamaged.cs
    â””â”€â”€ StateDeath.cs
```

**ì¥ì **:
- í…ŒìŠ¤íŠ¸ ìš©ì´
- State ë…ë¦½ ìˆ˜ì • ê°€ëŠ¥
- í˜‘ì—… ì‹œ ì¶©ëŒ ê°ì†Œ

---

#### 2ï¸âƒ£ **ScriptableObject ê¸°ë°˜ Enemy AI Config**
**ëª©í‘œ**: ì  íƒ€ì…ë§ˆë‹¤ ì½”ë“œ ë³µì‚¬ ì—†ì´ ë°ì´í„°ë§Œ ë³€ê²½

```csharp
[CreateAssetMenu]
public class EnemyAIConfig : ScriptableObject
{
    public float patrolRange;
    public float detectionRange;
    public float attackRange;
    public List<AIBehaviorData> behaviors;
}
```

**ì¥ì **:
- ê¸°íšìê°€ ì§ì ‘ AI ì¡°ì • ê°€ëŠ¥
- ëŸ°íƒ€ì„ AI ë³€ê²½ ê°€ëŠ¥ (ë³´ìŠ¤ í˜ì´ì¦ˆ ë“±)

---

#### 3ï¸âƒ£ **Dependency Injection ë„ì…**
**ëª©í‘œ**: GetComponentInChildren ì œê±°, í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± í–¥ìƒ

```csharp
// VContainer ì‚¬ìš© ì˜ˆì‹œ
public class PlayerBehavior : MonoBehaviour
{
    [Inject] private CharacterStats stats;
    [Inject] private HealthSystem healthSystem;
    [Inject] private AttackSystem attackSystem;
}
```

**ì¥ì **:
- Mock ê°ì²´ë¡œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- ì»´í¬ë„ŒíŠ¸ êµ¬ì¡° ë³€ê²½ì— ìœ ì—°

---

### âœ¨ Best Parts (ì˜í•œ ì  3ê°œ)

#### 1ï¸âƒ£ **FSM + Behavior Tree í•˜ì´ë¸Œë¦¬ë“œ êµ¬ì¡°** â­â­â­â­â­
- í”Œë ˆì´ì–´ëŠ” FSM (ê²°ì •ì , ë¹ ë¦„)
- ì ì€ BT (ìš°ì„ ìˆœìœ„, í™•ì¥ ìš©ì´)
- ê° ì‹œìŠ¤í…œì˜ ì¥ì ì„ ì‚´ë¦° ì„¤ê³„

**ì½”ë“œ**:
```csharp
// PlayerBehavior.cs - ëª…í™•í•œ ìƒíƒœ ì „í™˜
case PlayerState.IDLE:
    if (Mathf.Abs(_snapShotMoveInput) > Mathf.Epsilon)
        ChangeState(ref currentXState, PlayerState.MOVE);
    break;

// EnemyBehavior.cs - ìš°ì„ ìˆœìœ„ ê¸°ë°˜
selectorRoot = new SelectorNode(
    new List<SequenceNode>() { DEATH, DAMAGED, CHASE, PATROL, IDLE }
);
```

---

#### 2ï¸âƒ£ **ScriptableObject ê¸°ë°˜ ë°ì´í„° ì„¤ê³„** â­â­â­â­â­
- `CharacterStats`, `SkillData`ë¡œ ìºë¦­í„°/ìŠ¤í‚¬ í™•ì¥ ê°€ëŠ¥
- ì½”ë“œ ìˆ˜ì • ì—†ì´ ë°¸ëŸ°ì‹± ê°€ëŠ¥
- í”„ë¦¬íŒ¹ ì¬ì‚¬ìš© ìš°ìˆ˜

**ì½”ë“œ**:
```csharp
[CreateAssetMenu(fileName = "New Character Stats", menuName = "Game/Character Stats")]
public class CharacterStats : ScriptableObject
{
    [Header("Health")]
    [SerializeField] public float maxHealth;
    [SerializeField] public float healthRegen;
    // ...
}
```

---

#### 3ï¸âƒ£ **ì œë„¤ë¦­ ObjectPool + Event ì‹œìŠ¤í…œ** â­â­â­â­
- `ObjectPool<T>`ë¡œ ì–´ë–¤ ìŠ¤í‚¬ì´ë“  í’€ë§ ê°€ëŠ¥
- `UnityEvent`ë¡œ ì‹œìŠ¤í…œ ê°„ ê²°í•©ë„ ìµœì†Œí™”
- ì„±ëŠ¥ê³¼ ìœ ì§€ë³´ìˆ˜ì„± ê· í˜•

**ì½”ë“œ**:
```csharp
// ObjectPool.cs
public class ObjectPool<T> where T : MonoBehaviour
{
    private readonly Queue<T> pool;
    
    public T Get() { /* ... */ }
    public void Return(T obj) { pool.Enqueue(obj); }
}

// HealthSystem.cs
public UnityEvent<Vector2> EventHit;
public UnityEvent EventDeath;
```

---

## ğŸ¯ ê²°ë¡ 

**ì „ì²´ í‰ê°€**: 
- **êµ¬ì¡°ì  ì„¤ê³„**ëŠ” ìš°ìˆ˜ (FSM/BT ë¶„ë¦¬, ScriptableObject í™œìš©)
- **ì„±ëŠ¥ ìµœì í™”**ì™€ **ì•ˆì „ì„±**ì—ì„œ ê°œì„  ì—¬ì§€ í° í¸
- ì¤‘ê·œëª¨ í”„ë¡œì íŠ¸ë¡œ í™•ì¥ ê°€ëŠ¥í•œ ê¸°ë°˜ì€ ê°–ì¶¤

**ë‹¤ìŒ ë‹¨ê³„**:
1. GC ìµœì í™” (Tuple â†’ struct)
2. Jump buffer êµ¬í˜„
3. Event Leak ìˆ˜ì •
4. FSM State ì™¸ë¶€í™”
5. Enemy AI Config ë°ì´í„°í™”

**ì´í‰**: 
- Unity ì´ˆì¤‘ê¸‰ ìˆ˜ì¤€ì˜ ê¹”ë”í•œ ì½”ë“œ
- ëª‡ ê°€ì§€ í•µì‹¬ ì´ìŠˆë§Œ í•´ê²°í•˜ë©´ ê³ í’ˆì§ˆ ì½”ë“œë² ì´ìŠ¤ë¡œ ë°œì „ ê°€ëŠ¥
- ë¦¬íŒ©í† ë§ ìš°ì„ ìˆœìœ„ë¥¼ ëª…í™•íˆ í•˜ë©´ íš¨ìœ¨ì  ê°œì„  ê°€ëŠ¥

---

**í‰ê°€ì ë…¸íŠ¸**: 
- ê°€ì´ë“œë¼ì¸ 10ê°œ í•­ëª© ëª¨ë‘ ì¶©ì‹¤íˆ í‰ê°€
- ê° ë¬¸ì œì ì— êµ¬ì²´ì  ì½”ë“œ ì˜ˆì‹œ ì œê³µ
- ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ ê°œì„ ì•ˆ ì¤‘ì‹¬ìœ¼ë¡œ ì‘ì„±
