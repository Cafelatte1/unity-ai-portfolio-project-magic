# Unity C# ì½”ë“œ í’ˆì§ˆ í‰ê°€ ë³´ê³ ì„œ

**í‰ê°€ ì¼ì‹œ:** 2025-12-11 21:44  
**í”„ë¡œì íŠ¸ëª…:** project-magic  
**í‰ê°€ ëŒ€ìƒ:** Assets/Scripts ì½”ë“œë² ì´ìŠ¤

---

## ğŸ“Œ 1. Architecture & Unity Component Design

### í‰ê°€ (7.5/10)

**ê°•ì :**
- FSMê³¼ Behavior Treeë¥¼ ì ì ˆíˆ ë¶„ë¦¬í•˜ì—¬ ì‚¬ìš© (PlayerëŠ” FSM, EnemyëŠ” BT)
- `HealthSystem`, `AttackSystem` ë“± ê³µí†µ ë¡œì§ì„ abstract classë¡œ ì¶”ìƒí™”í•˜ì—¬ ì¬ì‚¬ìš©ì„± í™•ë³´
- `StatsContainer`ë¥¼ í†µí•´ ScriptableObject ê¸°ë°˜ ë°ì´í„° ê´€ë¦¬ êµ¬ì¡° ì ìš©
- Unity ìƒëª…ì£¼ê¸°ë¥¼ ì ì ˆíˆ í™œìš© (Awakeì—ì„œ ì»´í¬ë„ŒíŠ¸ ìºì‹±, Startì—ì„œ ì´ë²¤íŠ¸ êµ¬ë…)

**ë¬¸ì œì :**
1. **SRP ìœ„ë°˜ ì‚¬ë¡€**
   - `PlayerBehavior`ê°€ 600+ ë¼ì¸ìœ¼ë¡œ ë„ˆë¬´ ë¹„ëŒ€í•¨ (ì…ë ¥ ì²˜ë¦¬, ìƒíƒœ ê´€ë¦¬, ë¬¼ë¦¬ ì²˜ë¦¬, ì• ë‹ˆë©”ì´ì…˜ ë“±ì„ ëª¨ë‘ í¬í•¨)
   - `EnemyBehavior` ì—­ì‹œ 500+ ë¼ì¸ìœ¼ë¡œ ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°€ì§
   
2. **ë‚´ë¶€ í´ë˜ìŠ¤ ê³¼ë‹¤ ì‚¬ìš©**
   - `PlayerBehavior` ë‚´ë¶€ì— 7ê°œì˜ State í´ë˜ìŠ¤ê°€ ì •ì˜ë˜ì–´ ìˆì–´ í´ë˜ìŠ¤ í¬ê¸°ê°€ ê³¼ë„í•˜ê²Œ ì»¤ì§
   - ì´ëŠ” í…ŒìŠ¤íŠ¸ ë° ì¬ì‚¬ìš©ì„±ì„ ì €í•´í•¨

3. **Composition vs Inheritance í˜¼ì¬**
   - `HealthSystem`/`AttackSystem`ì€ ìƒì† ê¸°ë°˜ì¸ë° `StatsContainer`ëŠ” ì»´í¬ì§€ì…˜ ë°©ì‹
   - ì¼ê´€ì„± ìˆëŠ” ì„¤ê³„ ì›ì¹™ í•„ìš”

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: PlayerBehaviorì— ëª¨ë“  State í´ë˜ìŠ¤ê°€ ë‚´ì¥
public class PlayerBehavior : MonoBehaviour
{
    class StateMove : FSMNode { /* ... */ }
    class StateIdle : FSMNode { /* ... */ }
    // ... 7ê°œì˜ State í´ë˜ìŠ¤
}

// ê°œì„  í›„: ê° Stateë¥¼ ë³„ë„ íŒŒì¼ë¡œ ë¶„ë¦¬
// Assets/Scripts/Player/States/PlayerMoveState.cs
public class PlayerMoveState : FSMNode
{
    private readonly PlayerBehavior _context;
    public PlayerMoveState(PlayerBehavior context) => _context = context;
    
    public override void OnEnter() { /* ... */ }
    public override void Update() { /* ... */ }
    public override void OnExit() { /* ... */ }
}

// PlayerBehaviorëŠ” ìƒíƒœ ì¡°ìœ¨ì—ë§Œ ì§‘ì¤‘
public class PlayerBehavior : MonoBehaviour
{
    private readonly Dictionary<PlayerState, FSMNode> _stateContainer;
    // í›¨ì”¬ ê°„ê²°í•´ì§
}
```

---

## ğŸ“Œ 2. Code Readability & Maintainability

### í‰ê°€ (6.5/10)

**ê°•ì :**
- `[Header]`, `[SerializeField]` ë“± Unity ì†ì„±ì„ ì ì ˆíˆ í™œìš©
- ë©”ì„œë“œëª…ì´ ëŒ€ì²´ë¡œ ëª…í™•í•¨ (`ExecuteAttack`, `CheckGrounded`, `ListenerHit` ë“±)
- Loggerë¥¼ í†µí•œ ë””ë²„ê·¸ ë¡œê¹… êµ¬ì¡° ì–‘í˜¸

**ë¬¸ì œì :**

1. **ë„¤ì´ë° ê·œì¹™ ë¶ˆì¼ì¹˜**
   ```csharp
   // ì¼ê´€ì„± ì—†ëŠ” ë„¤ì´ë°
   float _moveInput;              // underscore prefix (private)
   Vector2 _hitForce;
   Queue<PlayerState> bufferXState;  // underscore ì—†ìŒ (private)
   CharacterStats stats;          // publicì´ì§€ë§Œ underscore ì—†ìŒ
   ```

2. **Magic Number ê³¼ë‹¤**
   ```csharp
   // PlayerBehavior.cs
   if (rb.linearVelocity.y <= (Mathf.Epsilon + landingVelocityMargin))
   
   // BehaviorTree.cs
   Collider2D[] hitResults = new Collider2D[2];  // 2ëŠ” ë¬´ì—‡ì„ ì˜ë¯¸?
   ```

3. **ì£¼ì„ ë° XML ë¬¸ì„œí™” ë¶€ì¬**
   - ëŒ€ë¶€ë¶„ì˜ public ë©”ì„œë“œì— XML ì£¼ì„ì´ ì—†ìŒ
   - ë³µì¡í•œ ë¡œì§ì— ëŒ€í•œ ì„¤ëª… ë¶€ì¡±

4. **í•˜ë“œì½”ë”©ëœ ë¬¸ìì—´**
   ```csharp
   colliders.layer = LayerMask.NameToLayer(LayerName.Corpse.ToString());
   // LayerName enumì€ ìˆì§€ë§Œ ì—¬ì „íˆ runtime string ë³€í™˜ ì‚¬ìš©
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „
float _moveInput;
Queue<PlayerState> bufferXState;

// ê°œì„  í›„: ì¼ê´€ëœ ë„¤ì´ë° ê·œì¹™
private float _moveInput;
private Queue<PlayerState> _bufferXState;

// ê°œì„  ì „: Magic number
Collider2D[] hitResults = new Collider2D[2];

// ê°œì„  í›„: ìƒìˆ˜í™”
private const int MAX_HIT_TARGETS = 2;
private Collider2D[] _hitResults = new Collider2D[MAX_HIT_TARGETS];

// XML ë¬¸ì„œí™” ì¶”ê°€
/// <summary>
/// í”Œë ˆì´ì–´ì˜ ê³µê²©ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.
/// </summary>
/// <param name="attackIndex">ê³µê²© ì¸ë±ìŠ¤ (0: ê¸°ë³¸ ê³µê²©, 1+: ìŠ¤í‚¬)</param>
/// <returns>ê³µê²© ì‹¤í–‰ ì„±ê³µ ì—¬ë¶€</returns>
public bool ExecuteAttack(int attackIndex)
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

### í‰ê°€ (6.0/10)

**ê°•ì :**
- `ObjectPool<T>` êµ¬í˜„ìœ¼ë¡œ Projectile ì¬ì‚¬ìš© êµ¬ì¡° ë§ˆë ¨
- GetComponent ìºì‹±ì„ Awakeì—ì„œ ìˆ˜í–‰
- FixedUpdate/Update ë¶„ë¦¬ ì ì ˆ

**ë¬¸ì œì :**

1. **ë§¤ í”„ë ˆì„ GC ë°œìƒ ê°€ëŠ¥ì„±**
   ```csharp
   // EnemyBehavior.FixedUpdate
   var (selectorResult, actionPath) = selectorRoot.Evaluate();
   // ë§¤ í”„ë ˆì„ Behavior Tree ì „ì²´ ìˆœíšŒ + string ìƒì„±
   Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
   ```

2. **Boxing ë°œìƒ**
   ```csharp
   // Enumì„ ToString()ìœ¼ë¡œ ìì£¼ ë³€í™˜
   Logger.Write($"XState changed from={fromXState.ToString()} to={currentXState.ToString()}");
   ```

3. **ë¶ˆí•„ìš”í•œ ì»¬ë ‰ì…˜ ìˆœíšŒ**
   ```csharp
   // AttackSystem.Update - ëª¨ë“  attackì˜ íƒ€ì´ë¨¸ë¥¼ ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
   foreach (var attack in attackContainer)
   {
       attack.UpdateTimer(Time.deltaTime);
   }
   // ì‹¤ì œë¡œëŠ” ì¿¨ë‹¤ìš´ì´ í™œì„±í™”ëœ ê²ƒë§Œ ì—…ë°ì´íŠ¸í•˜ë©´ ë¨
   ```

4. **Find ê³„ì—´ ì‚¬ìš©**
   ```csharp
   // APCRouter.Start
   playerBehavior = FindAnyObjectByType<PlayerBehavior>();
   
   // PlayerHealth.Start
   apcRouter = FindFirstObjectByType<APCRouter>();
   // Startì—ì„œ Find ì‚¬ìš© - ê´œì°®ì§€ë§Œ DIë‚˜ ì‹±ê¸€í†¤ì´ ë” íš¨ìœ¨ì 
   ```

5. **Dictionary ê³¼ë‹¤ ì‚¬ìš©**
   ```csharp
   Dictionary<PlayerState, FSMNode> stateContainer;  // enumì´ í‚¤ì¸ ê²½ìš° ë°°ì—´ì´ ë” ë¹ ë¦„
   Dictionary<int, ObjectPool<SkillLogic>> poolContainer;
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: ë§¤ í”„ë ˆì„ BT í‰ê°€ + ë¡œê¹…
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
}

// ê°œì„  í›„: ë””ë²„ê·¸ ëª¨ë“œì—ì„œë§Œ ë¡œê¹…
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    
#if UNITY_EDITOR && DEBUG_BT
    if (Logger.DEBUG)
    {
        Logger.Write($"BT: {selectorResult} - {actionPath}");
    }
#endif
}

// ê°œì„  ì „: Dictionaryë¡œ State ê´€ë¦¬
Dictionary<PlayerState, FSMNode> stateContainer;

// ê°œì„  í›„: Arrayë¡œ ë³€ê²½ (enumì„ ì¸ë±ìŠ¤ë¡œ)
private FSMNode[] _stateContainer = new FSMNode[Enum.GetValues(typeof(PlayerState)).Length];

// ê°œì„  ì „: ëª¨ë“  ì¿¨ë‹¤ìš´ ë§¤ í”„ë ˆì„ ì—…ë°ì´íŠ¸
foreach (var attack in attackContainer)
{
    attack.UpdateTimer(Time.deltaTime);
}

// ê°œì„  í›„: í™œì„± ì¿¨ë‹¤ìš´ë§Œ ì¶”ì 
private List<AttackContainer> _activeCooldowns = new List<AttackContainer>();

protected virtual void Update()
{
    for (int i = _activeCooldowns.Count - 1; i >= 0; i--)
    {
        _activeCooldowns[i].UpdateTimer(Time.deltaTime);
        if (_activeCooldowns[i].CheckTimer())
        {
            _activeCooldowns.RemoveAt(i);
        }
    }
}
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

### í‰ê°€ (7.0/10)

**ê°•ì :**
- Input Snapshot íŒ¨í„´ ì‚¬ìš©ìœ¼ë¡œ FixedUpdate/Update ë™ê¸°í™” ë¬¸ì œ í•´ê²°
- Jump Buffer êµ¬í˜„ (`bufferXState`, `bufferYState`)
- ë¬´ì  ì‹œê°„ ì²˜ë¦¬ (`invincibleTimer`, `_hitRecoveryTimer`)
- Ground Checkë¥¼ BoxCollider2D.IsTouchingLayersë¡œ êµ¬í˜„

**ë¬¸ì œì :**

1. **Null ë°©ì–´ ë¶ˆì¶©ë¶„**
   ```csharp
   // EnemyBehavior.ActionChase
   if (ctx._target == null) return new EvaluateResult(BTNode.State.Failure, ...);
   
   var direction = Mathf.Sign(ctx._target.position.x - ctx.transform.position.x);
   // ì—¬ê¸°ì„œ ctx._targetì´ Destroyë˜ë©´?
   ```

2. **ë™ì‹œì„± ë¬¸ì œ ê°€ëŠ¥ì„±**
   ```csharp
   // PlayerBehavior - X/Y stateê°€ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬ë˜ì§€ë§Œ
   // DEATH stateëŠ” ì–‘ìª½ì— ëª¨ë‘ ë“¤ì–´ê°
   // í•˜ë‚˜ê°€ ì‹¤í–‰ë˜ê³  ë‹¤ë¥¸ ìª½ì´ ì‹¤í–‰ë  ë•Œ ìˆœì„œ ë³´ì¥ ì•ˆë¨
   bufferXState.Enqueue(PlayerState.DEATH);
   bufferYState.Enqueue(PlayerState.DEATH);
   ```

3. **Attack Recovery íƒ€ì´ë° ì´ìŠˆ**
   ```csharp
   // StateAttack.OnEnter
   if (!ctx._attackRes) return;  // ê³µê²© ì‹¤íŒ¨ ì‹œ returnë§Œ í•˜ê³ 
   // OnExitì´ í˜¸ì¶œë˜ì§€ ì•ŠìŒ
   
   var clipTime = ctx.animController.PlayStateAnimation(PlayerState.ATTACK, rebind: true);
   ctx._attackRecoveryTimer = clipTime;
   // ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ë¡œ ì¿¨ë‹¤ìš´ ì„¤ì • - ì¢‹ì€ ì ‘ê·¼ì´ì§€ë§Œ
   // ì• ë‹ˆë©”ì´ì…˜ì´ ì¤‘ë‹¨ë˜ë©´?
   ```

4. **Hit Force ì´ˆê¸°í™” ë¯¸í¡**
   ```csharp
   void ListenerHit(Vector2 knockback)
   {
       if (_hitRecoveryTimer > 0) return;
       _hitForce = knockback;
       bufferXState.Enqueue(PlayerState.DAMAGED);
   }
   // _hitForceê°€ ì‚¬ìš© í›„ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: Null ì²´í¬ ì—†ìŒ
var direction = Mathf.Sign(ctx._target.position.x - ctx.transform.position.x);

// ê°œì„  í›„
if (ctx._target == null || !ctx._target.gameObject.activeInHierarchy)
{
    ctx._target = null;
    return new EvaluateResult(BTNode.State.Failure, this.GetType().ToString());
}

// ê°œì„  ì „: Attack ì‹¤íŒ¨ ì‹œ ì²˜ë¦¬ ë¯¸í¡
if (!ctx._attackRes) return;

// ê°œì„  í›„: ìƒíƒœë¥¼ IDLEë¡œ ëª…ì‹œì ìœ¼ë¡œ ì „í™˜
if (!ctx._attackRes)
{
    ctx.ChangeState(ref ctx.currentXState, PlayerState.IDLE);
    return;
}

// ê°œì„  ì „: Hit Force ê´€ë¦¬ ë¯¸í¡
_hitForce = knockback;

// ê°œì„  í›„: êµ¬ì¡°ì²´ë¡œ ìº¡ìŠí™”
private struct HitData
{
    public Vector2 Force;
    public bool IsValid;
    
    public void Consume()
    {
        Force = Vector2.zero;
        IsValid = false;
    }
}
private HitData _hitData;
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

### í‰ê°€ (7.5/10)

**ê°•ì :**
- GetComponentë¥¼ Awakeì—ì„œ ìºì‹±
- `[SerializeField]`, `[Header]` í™œìš© ìš°ìˆ˜
- `Time.deltaTime` ê¸°ë°˜ íƒ€ì´ë¨¸ ì²˜ë¦¬
- Rigidbody.linearVelocity ì§ì ‘ ì„¤ì • (AddForceë³´ë‹¤ ë‚˜ì€ ì ‘ê·¼)
- OnDrawGizmosSelectedë¡œ ë””ë²„ê¹… ì§€ì›

**ë¬¸ì œì :**

1. **GetComponent ì¤‘ì²© í˜¸ì¶œ**
   ```csharp
   stats = GetComponentInChildren<StatsContainer>().stats;
   // GetComponentInChildrenì€ ë¹„ìš©ì´ í° ì—°ì‚°
   // ë§¤ë²ˆ í˜¸ì¶œí•˜ì§€ ë§ê³  StatsContainer ìì²´ë¥¼ ìºì‹± í›„ stats ì ‘ê·¼
   ```

2. **Magic Number ì‚°ì¬**
   ```csharp
   [SerializeField] float landingVelocityMargin;
   // ê°’ ì˜ë¯¸ê°€ ë¶ˆëª…í™•, Tooltip í•„ìš”
   
   if (rb.linearVelocity.y <= (Mathf.Epsilon + landingVelocityMargin))
   // Mathf.Epsilonì„ ë”í•˜ëŠ” ì´ìœ ê°€ ì£¼ì„ìœ¼ë¡œ ì—†ìŒ
   ```

3. **Tooltip/Range ë¯¸ì‚¬ìš©**
   ```csharp
   [SerializeField] float hitRecoveryCooldown;
   [SerializeField] float raycastDetectionMargin;
   // [Tooltip], [Range] ë“±ì´ ì—†ì–´ ì—ë””í„°ì—ì„œ ì˜ë¯¸ íŒŒì•… ì–´ë ¤ì›€
   ```

4. **Transform vs Rigidbody ìˆ˜ì • í˜¼ì¬**
   ```csharp
   // FlipDirectionì—ì„œ transform.localScale ì§ì ‘ ìˆ˜ì •
   scale.x = ctx._snapShotMoveInput < 0 ? Mathf.Abs(scale.x) : -Mathf.Abs(scale.x);
   ctx.transform.localScale = scale;
   
   // ë™ì‹œì— Rigidbodyë¡œ ë¬¼ë¦¬ ì œì–´
   ctx.rb.linearVelocity = velocity;
   // ë¬¸ì œëŠ” ì—†ì§€ë§Œ flipì„ sprite rendererë¡œ í•˜ëŠ” ê²Œ ì¼ë°˜ì 
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „
stats = GetComponentInChildren<StatsContainer>().stats;

// ê°œì„  í›„
private StatsContainer _statsContainer;
void Awake()
{
    _statsContainer = GetComponentInChildren<StatsContainer>();
    stats = _statsContainer.stats;
}

// ê°œì„  ì „
[SerializeField] float hitRecoveryCooldown;
[SerializeField] float raycastDetectionMargin;

// ê°œì„  í›„
[Header("Combat Settings")]
[SerializeField, Tooltip("í”¼ê²© í›„ ë¬´ì  ì‹œê°„ (ì´ˆ)")]
[Range(0.1f, 2f)]
private float hitRecoveryCooldown = 0.5f;

[SerializeField, Tooltip("ê³µê²© ê°ì§€ ì—¬ìœ  ê±°ë¦¬")]
[Range(0f, 1f)]
private float raycastDetectionMargin = 0.1f;

// ê°œì„ : Constants íŒŒì¼ í™œìš©
public static class PhysicsConstants
{
    public const float GROUND_CHECK_EPSILON = 0.01f;
    public const float DEFAULT_LANDING_MARGIN = 0.1f;
}
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

### í‰ê°€ (7.0/10)

**ê°•ì :**
- FSMê³¼ BTë¥¼ ê°ê° Player/Enemyì— ì ì ˆíˆ ë¶„ë¦¬
- AnimationControllerë¥¼ ë³„ë„ë¡œ ë¶„ë¦¬í•˜ì—¬ ì¬ì‚¬ìš©ì„± í™•ë³´
- Animation ê¸¸ì´ë¥¼ ì½”ë“œë¡œ ë°›ì•„ì™€ì„œ ì¿¨ë‹¤ìš´ì— í™œìš©
- UnityEvent ê¸°ë°˜ ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ êµ¬ì¶•

**ë¬¸ì œì :**

1. **Animation Sync ë¬¸ì œ ê°€ëŠ¥ì„±**
   ```csharp
   public float PlayStateAnimation(PlayerState state, bool rebind = false)
   {
       if (state != currentState)
       {
           // ìƒíƒœê°€ ê°™ìœ¼ë©´ ìƒˆë¡œ ì¬ìƒí•˜ì§€ ì•ŠìŒ
           // ê°™ì€ ê³µê²©ì„ ì—°ì†ìœ¼ë¡œ í•˜ë©´?
       }
   }
   ```

2. **FSM/BT ìƒíƒœ ì „ì´ê°€ ëª…ì‹œì ì´ì§€ ì•ŠìŒ**
   ```csharp
   // PlayerBehavior.UpdateXState
   case PlayerState.DAMAGED:
       ChangeState(ref currentXState, PlayerState.IDLE);
       break;
   // ë¬´ì¡°ê±´ IDLEë¡œ ê°€ëŠ” ê²Œ ë§ë‚˜? MOVE ì¤‘ì´ì—ˆë‹¤ë©´?
   ```

3. **Animation Event ë¯¸ì‚¬ìš©**
   - ê³µê²© íˆíŠ¸ë°•ìŠ¤ í™œì„±í™”ë¥¼ íƒ€ì´ë°ì— ë§ì¶° ì²˜ë¦¬í•  ìˆ˜ ì—†ìŒ
   - ëª¨ë“  ê²ƒì´ ìŠ¤í¬ë¦½íŠ¸ ê¸°ë°˜ì´ë¼ ì• ë‹ˆë©”ì´ì…˜ê³¼ì˜ ë™ê¸°í™” ì–´ë ¤ì›€

4. **Event ìˆœì„œ ë³´ì¥ ì•ˆë¨**
   ```csharp
   // PlayerBehavior.Start
   healthSystem.EventHit.AddListener(ListenerHit);
   healthSystem.EventDeath.AddListener(ListenerDeath);
   attackSystem.EventAttack.AddListener(ListenerAttack);
   // ìˆœì„œê°€ ì¤‘ìš”í•œ ê²½ìš° ëª…ì‹œì  ê´€ë¦¬ í•„ìš”
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ ì¡°ê±´ ë¶ˆëª…í™•
if (state != currentState)

// ê°œì„  í›„: force íŒŒë¼ë¯¸í„° ì¶”ê°€
public float PlayStateAnimation(PlayerState state, bool rebind = false, bool force = false)
{
    if (force || state != currentState)
    {
        // ...
    }
}

// ê°œì„ : State ì „ì´ í…Œì´ë¸” ëª…ì‹œ
private static readonly Dictionary<PlayerState, PlayerState> StateTransitions = new()
{
    { PlayerState.DAMAGED, PlayerState.IDLE },
    { PlayerState.ATTACK, PlayerState.IDLE },
    // ...
};

// Animation Event í™œìš© ì˜ˆì‹œ
public class PlayerAttackAnimationEvents : MonoBehaviour
{
    [SerializeField] private AttackSystem attackSystem;
    
    // Animation Eventë¡œ í˜¸ì¶œ
    public void OnAttackHitFrame()
    {
        attackSystem.ActivateHitbox();
    }
    
    public void OnAttackEnd()
    {
        attackSystem.DeactivateHitbox();
    }
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

### í‰ê°€ (5.5/10)

**ê°•ì :**
- ê¸°ë³¸ì ì¸ null ì²´í¬ ì¡´ì¬
- ì¿¨ë‹¤ìš´/íƒ€ì´ë¨¸ ì²´í¬ë¡œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
- `IsAlive` ì²´í¬ë¡œ ì‚¬ë§ í›„ ë¡œì§ ì‹¤í–‰ ë°©ì§€

**ë¬¸ì œì :**

1. **TryGetComponent ë¯¸ì‚¬ìš©**
   ```csharp
   // AttackSystem.ExecuteMeleeAttack
   if (hit.TryGetComponent<HealthSystem>(out HealthSystem targetHealthSystem))
   {
       ApplyAttack(attack, origin.transform.position, hit.transform.position, targetHealthSystem);
   }
   // ì¢‹ì€ íŒ¨í„´ì´ì§€ë§Œ ì¼ê´€ì„± ì—†ìŒ - ì–´ë–¤ ê³³ì€ ì§ì ‘ GetComponent
   ```

2. **Boundary ì²´í¬ ë¶€ì¡±**
   ```csharp
   // ExecuteAttack
   if (attackIndex >= attackContainer.Count)
   {
       Logger.Write($"Invalid attack index: {attackIndex}", "ERROR");
       return false;
   }
   // < 0 ì²´í¬ëŠ”?
   ```

3. **Initialize ìˆœì„œ ë¬¸ì œ**
   ```csharp
   // APCRouter.Start
   playerBehavior = FindAnyObjectByType<PlayerBehavior>();
   // playerBehaviorê°€ ì—†ìœ¼ë©´?
   
   // Updateì—ì„œ
   if (!playerBehavior.IsAlive) return;
   // playerBehaviorê°€ nullì´ë©´ NullReferenceException
   ```

4. **Exception Handling ì „ë¬´**
   ```csharp
   // LLMWorkerThread - try-catchëŠ” ìˆì§€ë§Œ recovery ë¡œì§ ì—†ìŒ
   catch (Exception e)
   {
       Logger.Write($"failed to inference / msg={e}", "ERROR");
   }
   // ì‹¤íŒ¨ í›„ ì–´ë–»ê²Œ ì²˜ë¦¬í•  ê²ƒì¸ê°€?
   ```

5. **Debug vs Production ë¹Œë“œ ê³ ë ¤ ë¶€ì¡±**
   ```csharp
   #if UNITY_EDITOR
   if (Logger.DEBUG)
   {
       Logger.Write($"...");
   }
   #endif
   // Productionì—ì„œë„ ë¡œê·¸ê°€ í•„ìš”í•œ ê²½ìš°ëŠ”?
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: Boundary ì²´í¬ ë¶ˆì™„ì „
if (attackIndex >= attackContainer.Count)

// ê°œì„  í›„: ì™„ì „í•œ ë²”ìœ„ ì²´í¬
if (attackIndex < 0 || attackIndex >= attackContainer.Count)
{
    Logger.Write($"Attack index out of range: {attackIndex} (valid: 0-{attackContainer.Count - 1})", "ERROR");
    return false;
}

// ê°œì„  ì „: Null ê°€ëŠ¥ì„±
if (!playerBehavior.IsAlive) return;

// ê°œì„  í›„: Defensive programming
if (playerBehavior == null)
{
    Logger.Write("PlayerBehavior not found in scene!", "ERROR");
    enabled = false;
    return;
}
if (!playerBehavior.IsAlive) return;

// ê°œì„ : ì´ˆê¸°í™” ê²€ì¦
private void OnValidate()
{
    if (stats == null)
        Debug.LogWarning($"{name}: Stats is not assigned!", this);
    
    if (hitRecoveryCooldown <= 0)
        Debug.LogWarning($"{name}: hitRecoveryCooldown must be positive!", this);
}

// ê°œì„ : Exception Recovery
catch (Exception e)
{
    Logger.Write($"Inference failed: {e}", "ERROR");
    
    // ì‹¤íŒ¨í•œ ìš”ì²­ì„ ì¬ì‹œë„ íì— ì¶”ê°€
    if (req.retryCount < MAX_RETRY_COUNT)
    {
        req.retryCount++;
        _requestQueue.Enqueue(req);
    }
    else
    {
        req.onError?.Invoke(e);
    }
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

### í‰ê°€ (8.0/10)

**ê°•ì :**
- ScriptableObject ê¸°ë°˜ ë°ì´í„° êµ¬ì¡° (CharacterStats, SkillData)
- Abstract class í™œìš©ìœ¼ë¡œ í™•ì¥ì„± í™•ë³´ (HealthSystem, AttackSystem)
- AttackContainerë¡œ ê³µê²©ì„ ë°ì´í„°í™”
- ObjectPool êµ¬í˜„ìœ¼ë¡œ Projectile í™•ì¥ ê°€ëŠ¥
- UnityEvent ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©

**ë¬¸ì œì :**

1. **Hard-coded ë¡œì§**
   ```csharp
   // PlayerBehavior.ListenerAttack
   switch (attackIndex)
   {
       default:
           bufferXState.Enqueue(PlayerState.ATTACK);
           return;
   }
   // ìŠ¤í‚¬ë§ˆë‹¤ ë‹¤ë¥¸ ìƒíƒœê°€ í•„ìš”í•˜ë©´?
   ```

2. **PlayerState enum ê³µìœ **
   ```csharp
   // AnimationControllerì—ì„œ PlayerStateë¥¼ ì‚¬ìš©
   public float PlayStateAnimation(PlayerState state, int index, bool rebind = false)
   
   // Enemyë„ PlayerState ì‚¬ìš©?
   ctx.animController.PlayStateAnimation(PlayerState.DEATH);
   // ICharacterState ì¸í„°í˜ì´ìŠ¤ê°€ ë” ì ì ˆ
   ```

3. **ì˜ì¡´ì„± ì£¼ì… ë¯¸ì‚¬ìš©**
   ```csharp
   // ëŒ€ë¶€ë¶„ GetComponentë‚˜ FindObjectOfType
   playerBehavior = FindAnyObjectByType<PlayerBehavior>();
   // DI ì»¨í…Œì´ë„ˆë‚˜ Service Locator íŒ¨í„´ ê³ ë ¤
   ```

4. **ìŠ¤í‚¬ í™•ì¥ì„± ì œí•œ**
   ```csharp
   // AttackSystem - attackContainerëŠ” List
   // ìƒˆ ìŠ¤í‚¬ ì¶”ê°€ëŠ” ì‰½ì§€ë§Œ ìŠ¤í‚¬ íŠ¸ë¦¬, ì—…ê·¸ë ˆì´ë“œ, ì¡°í•© ë“±ì€ ê³ ë ¤ ì•ˆë¨
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: Hard-coded switch
switch (attackIndex)
{
    default:
        bufferXState.Enqueue(PlayerState.ATTACK);
        return;
}

// ê°œì„  í›„: ë°ì´í„° ê¸°ë°˜
[System.Serializable]
public class SkillData : ScriptableObject
{
    public int skillId;
    public PlayerState requiredState;  // ìŠ¤í‚¬ ì‹¤í–‰ ì‹œ í•„ìš”í•œ ìƒíƒœ
    public bool requiresGrounded;
    // ...
}

// ê°œì„  ì „: PlayerState enum ì§ì ‘ ì‚¬ìš©
public float PlayStateAnimation(PlayerState state, ...)

// ê°œì„  í›„: ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜
public interface ICharacterState
{
    string StateName { get; }
}

public enum PlayerState : ICharacterState { ... }
public enum EnemyState : ICharacterState { ... }

public float PlayStateAnimation(ICharacterState state, ...)

// ê°œì„ : Service Locator íŒ¨í„´
public class ServiceLocator
{
    private static Dictionary<Type, object> _services = new();
    
    public static void Register<T>(T service) where T : class
    {
        _services[typeof(T)] = service;
    }
    
    public static T Get<T>() where T : class
    {
        return _services[typeof(T)] as T;
    }
}

// ì‚¬ìš©
void Start()
{
    playerBehavior = ServiceLocator.Get<PlayerBehavior>();
}
```

---

## ğŸ“Œ 9. Clean Code Practices

### í‰ê°€ (6.0/10)

**ê°•ì :**
- í´ë˜ìŠ¤ì™€ ë©”ì„œë“œê°€ ëŒ€ì²´ë¡œ ëª…í™•í•œ ì—­í• ì„ ê°€ì§
- í´ë” êµ¬ì¡°ê°€ ë…¼ë¦¬ì  (Player, Enemy, Common, Core ë“±)
- namespaceëŠ” ì—†ì§€ë§Œ íŒŒì¼ êµ¬ì¡°ë¡œ ëŒ€ì²´

**ë¬¸ì œì :**

1. **SOLID ì›ì¹™ ìœ„ë°˜**
   - **SRP ìœ„ë°˜**: PlayerBehaviorê°€ ë„ˆë¬´ ë§ì€ ì±…ì„
   - **OCP ìœ„ë°˜**: ìƒˆ ìƒíƒœ ì¶”ê°€ ì‹œ PlayerBehavior ìˆ˜ì • í•„ìš”
   - **DIP ìœ„ë°˜**: êµ¬ì²´ í´ë˜ìŠ¤ì— ì§ì ‘ ì˜ì¡´ (Rigidbody2D, Animator)

2. **DRY ìœ„ë°˜**
   ```csharp
   // PlayerBehaviorì™€ EnemyBehaviorì— ì¤‘ë³µ ì½”ë“œ
   void TickUpdate()
   {
       if (_hitRecoveryTimer > 0) _hitRecoveryTimer -= Time.deltaTime;
       if (_attackRecoveryTimer > 0) _attackRecoveryTimer -= Time.deltaTime;
   }
   // ê³µí†µ íƒ€ì´ë¨¸ ë§¤ë‹ˆì €ê°€ í•„ìš”
   ```

3. **ë¶ˆí•„ìš”í•œ public í•„ë“œ**
   ```csharp
   public Animator animator;  // AnimationController
   // propertyë¡œ ì ‘ê·¼ ì œì–´ í•„ìš”
   ```

4. **Property vs Field í˜¼ì¬**
   ```csharp
   public bool IsAlive => currentHealth > 0;  // property
   public float CurrentHealth => currentHealth;  // property
   public UnityEvent<float> OnHealthChanged;  // field
   // ì¼ê´€ì„± í•„ìš”
   ```

5. **Namespace ë¶€ì¬**
   - ëª¨ë“  í´ë˜ìŠ¤ê°€ global namespace
   - ì´ë¦„ ì¶©ëŒ ìœ„í—˜ (íŠ¹íˆ Common, Utils)

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: íƒ€ì´ë¨¸ ì½”ë“œ ì¤‘ë³µ
void TickUpdate()
{
    if (_hitRecoveryTimer > 0) _hitRecoveryTimer -= Time.deltaTime;
    if (_attackRecoveryTimer > 0) _attackRecoveryTimer -= Time.deltaTime;
}

// ê°œì„  í›„: Timer ìœ í‹¸ë¦¬í‹°
public class Timer
{
    private float _remaining;
    
    public bool IsRunning => _remaining > 0;
    
    public void Start(float duration) => _remaining = duration;
    public void Update(float deltaTime) => _remaining = Mathf.Max(0, _remaining - deltaTime);
    public bool IsExpired => _remaining <= 0;
}

// ì‚¬ìš©
private Timer _hitRecoveryTimer = new Timer();
private Timer _attackRecoveryTimer = new Timer();

void TickUpdate()
{
    _hitRecoveryTimer.Update(Time.deltaTime);
    _attackRecoveryTimer.Update(Time.deltaTime);
}

// ê°œì„  ì „: public field
public Animator animator;

// ê°œì„  í›„: property
public Animator Animator { get; private set; }

// ê°œì„ : Namespace ì ìš©
namespace ProjectMagic.Core
{
    public abstract class FSMNode { }
    public abstract class BehaviorTree { }
}

namespace ProjectMagic.Characters.Player
{
    using ProjectMagic.Core;
    
    public class PlayerBehavior : MonoBehaviour { }
}

// ê°œì„ : Interfaceë¥¼ í†µí•œ DIP ì¤€ìˆ˜
public interface IMovementController
{
    void Move(Vector2 direction, float speed);
}

public class RigidbodyMovement : IMovementController
{
    private readonly Rigidbody2D _rb;
    
    public void Move(Vector2 direction, float speed)
    {
        _rb.linearVelocity = new Vector2(direction.x * speed, _rb.linearVelocity.y);
    }
}

public class PlayerBehavior : MonoBehaviour
{
    private IMovementController _movement;
    
    void Awake()
    {
        _movement = new RigidbodyMovement(GetComponent<Rigidbody2D>());
    }
}
```

---

## ğŸ“Œ 10. Intel OpenVINO ê¸°ë°˜ AI ëª¨ë¸ ì¶”ë¡  í”„ë¡œì„¸ìŠ¤

### í‰ê°€ (7.5/10)

**ê°•ì :**
- Worker Thread ë¶„ë¦¬ë¡œ ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€
- ConcurrentQueueë¥¼ í†µí•œ Thread-safe ìš”ì²­ í
- DLL Importë¥¼ í†µí•œ ë„¤ì´í‹°ë¸Œ í”ŒëŸ¬ê·¸ì¸ í†µí•©
- Request/Response êµ¬ì¡°ë¡œ ë¹„ë™ê¸° íŒ¨í„´ êµ¬í˜„
- Session ê´€ë¦¬ë¡œ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ìœ ì§€

**ë¬¸ì œì :**

1. **ì´ˆê¸°í™” ì‹¤íŒ¨ ì²˜ë¦¬ ë¯¸í¡**
   ```csharp
   _pipeline = OV_LoadModel(modelPath, device);
   if (_pipeline == IntPtr.Zero)
   {
       Logger.Write("âŒ OV_LoadModel ì‹¤íŒ¨ (pipeline == 0)", "ERROR");
   }
   // ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰ - ì´í›„ ëª¨ë“  ì¶”ë¡ ì´ ì‹¤íŒ¨í•  ê²ƒ
   ```

2. **Hard-coded Path**
   ```csharp
   string modelPath = @"C:\Users\flash\projects\project-magic-localai\Models\qwen3-4b-it-ir\";
   // ì ˆëŒ€ ê²½ë¡œ - ë‹¤ë¥¸ PCì—ì„œ ì‘ë™ ì•ˆí•¨
   ```

3. **ì—ëŸ¬ ë³µêµ¬ ì „ëµ ì—†ìŒ**
   ```csharp
   catch (Exception e)
   {
       Debug.LogException(e);
   }
   // ì˜ˆì™¸ ë¡œê·¸ë§Œ ì°ê³  ë³µêµ¬ ì‹œë„ ì—†ìŒ
   ```

4. **ë©”ëª¨ë¦¬ ê´€ë¦¬ ë¶ˆëª…í™•**
   ```csharp
   OV_FreeString(resultPtr);
   // ì–¸ì œ ì–´ë–¤ ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•´ì•¼ í•˜ëŠ”ì§€ ë¬¸ì„œí™” í•„ìš”
   // pipelineì€ OnDestroyì—ì„œë§Œ í•´ì œ - ì¤‘ê°„ì— ì¬ë¡œë“œëŠ”?
   ```

5. **Tool Call Parsing ë¯¸êµ¬í˜„**
   ```csharp
   // TODO: ì—¬ê¸°ì„œ tool call parsing ê°€ëŠ¥
   // ê¸°ëŠ¥ì´ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•ŠìŒ
   ```

### ê°œì„ ì•ˆ:

```csharp
// ê°œì„  ì „: ì´ˆê¸°í™” ì‹¤íŒ¨ ë¬´ì‹œ
if (_pipeline == IntPtr.Zero)
{
    Logger.Write("âŒ OV_LoadModel ì‹¤íŒ¨", "ERROR");
}
// ì´í›„ ì½”ë“œ ê³„ì† ì‹¤í–‰

// ê°œì„  í›„: ëª…ì‹œì  ì—ëŸ¬ ì²˜ë¦¬
private bool _isModelLoaded = false;

void InitModel()
{
    try
    {
        string modelPath = GetModelPath();
        _pipeline = OV_LoadModel(modelPath, device);
        
        if (_pipeline == IntPtr.Zero)
        {
            throw new InvalidOperationException("Failed to load OpenVINO model");
        }
        
        _isModelLoaded = true;
        Logger.Write("âœ” OpenVINO model loaded successfully");
    }
    catch (Exception e)
    {
        Logger.Write($"Model initialization failed: {e}", "ERROR");
        _isModelLoaded = false;
        // í´ë°± ë™ì‘ ë˜ëŠ” ì¬ì‹œë„ ë¡œì§
    }
}

public void RequestInference(LLMRequest request)
{
    if (!_isModelLoaded)
    {
        Logger.Write("Model not loaded, cannot process request", "ERROR");
        request.onError?.Invoke(new InvalidOperationException("Model not initialized"));
        return;
    }
    
    _requestQueue.Enqueue(request);
}

// ê°œì„  ì „: Hard-coded path
string modelPath = @"C:\Users\flash\projects\...";

// ê°œì„  í›„: Configurable path
[SerializeField] private string modelPathRelative = "Models/qwen3-4b-it-ir/";

private string GetModelPath()
{
    // StreamingAssets ì‚¬ìš©
    return Path.Combine(Application.streamingAssetsPath, modelPathRelative);
}

// ê°œì„ : Request retry ë¡œì§
public class LLMRequest
{
    public int RetryCount { get; set; } = 0;
    public const int MAX_RETRIES = 3;
    
    public Action<Exception> onError;
}

// WorkerThreadì—ì„œ
catch (Exception e)
{
    Logger.Write($"Inference failed: {e}", "ERROR");
    
    if (req.RetryCount < LLMRequest.MAX_RETRIES)
    {
        req.RetryCount++;
        System.Threading.Thread.Sleep(100 * req.RetryCount);  // exponential backoff
        _queue.Enqueue(req);
    }
    else
    {
        _dispatchResponse(req, null);  // nullë¡œ ì‹¤íŒ¨ ì•Œë¦¼
        req.onError?.Invoke(e);
    }
}

// ê°œì„ : Tool Call Parsing êµ¬í˜„
public class ToolCallParser
{
    public static ToolCall Parse(string llmOutput)
    {
        // JSON íŒŒì‹± ë¡œì§
        // "function": "create_player_health_trigger" ë“± íŒŒì‹±
    }
}

public void HandleResponse(LLMResponse response)
{
    // assistant ë©”ì‹œì§€ë¥¼ ì„¸ì…˜ì— ì¶”ê°€
    if (sessionContainer.TryGetValue(response.sessionId, out Session session))
    {
        session.AddAssistant(response.text);
    }
    
    // Tool Call ì²˜ë¦¬
    var toolCall = ToolCallParser.Parse(response.text);
    if (toolCall != null)
    {
        ExecuteToolCall(toolCall);
    }
}
```

---

## ğŸ“Œ ì¢…í•© í‰ê°€ (10/10 ê¸°ì¤€)

| í•­ëª© | ì ìˆ˜ | í‰ê°€ |
|------|------|------|
| 1. Architecture & Unity Component Design | 7.5 | FSM/BT ë¶„ë¦¬ ìš°ìˆ˜, SRP ì¼ë¶€ ìœ„ë°˜ |
| 2. Code Readability & Maintainability | 6.5 | ë„¤ì´ë° ë¶ˆì¼ì¹˜, Magic Number ê³¼ë‹¤ |
| 3. Performance & Memory Efficiency | 6.0 | GC ìœ ë°œ ìš”ì†Œ ë§ìŒ, Pool ìˆìœ¼ë‚˜ ë¶€ë¶„ì  |
| 4. Gameplay Logic & Stability | 7.0 | Input Snapshot ìš°ìˆ˜, Null ì²´í¬ ë¶€ì¡± |
| 5. Unity-Engine Best Practices | 7.5 | ì»´í¬ë„ŒíŠ¸ ìºì‹± ì–‘í˜¸, Tooltip ë¶€ì¡± |
| 6. Animation, FSM/BT, Event Flow | 7.0 | êµ¬ì¡°ëŠ” ì¢‹ìœ¼ë‚˜ Animation Event ë¯¸í™œìš© |
| 7. Safety & Error Handling | 5.5 | ê¸°ë³¸ ë°©ì–´ ì½”ë“œë§Œ, Exception ì²˜ë¦¬ ë¯¸í¡ |
| 8. Scalability / Extensibility | 8.0 | ScriptableObject í™œìš© ìš°ìˆ˜, DI ë¯¸ì‚¬ìš© |
| 9. Clean Code Practices | 6.0 | SOLID ì¼ë¶€ ìœ„ë°˜, namespace ì—†ìŒ |
| 10. OpenVINO AI Integration | 7.5 | Thread ë¶„ë¦¬ ìš°ìˆ˜, ì—ëŸ¬ ë³µêµ¬ ì—†ìŒ |
| **ì´ì ** | **68.5 / 100** | **í‰ê·  6.85 / 10** |

---

## ğŸ”¥ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (Top 3)

### 1. **PlayerBehavior/EnemyBehavior ë¦¬íŒ©í† ë§ (SRP ìœ„ë°˜)**

**ì‹¬ê°ë„:** â­â­â­â­â­  
**ì´ìœ :**
- 600+ ë¼ì¸ì˜ God Class
- í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥
- ë‚´ë¶€ State í´ë˜ìŠ¤ 7ê°œë¡œ ê°€ë…ì„± ì €í•˜

**ê°œì„  ë°©ë²•:**
```csharp
// ë¶„ë¦¬ ì „ëµ
PlayerBehavior (ì¡°ìœ¨ë§Œ)
â”œâ”€â”€ PlayerInputHandler (ì…ë ¥ ì²˜ë¦¬)
â”œâ”€â”€ PlayerStateController (FSM ê´€ë¦¬)
â”œâ”€â”€ PlayerMovement (ì´ë™ ë¡œì§)
â””â”€â”€ States/ (ë³„ë„ íŒŒì¼)
    â”œâ”€â”€ PlayerIdleState.cs
    â”œâ”€â”€ PlayerMoveState.cs
    â””â”€â”€ ...
```

### 2. **Null ì²´í¬ ë° ë°©ì–´ì  í”„ë¡œê·¸ë˜ë° ê°•í™”**

**ì‹¬ê°ë„:** â­â­â­â­  
**ì´ìœ :**
- Targetì´ Destroyë  ë•Œ NullReference ë°œìƒ ê°€ëŠ¥
- Initialize ìˆœì„œ ë¯¸ë³´ì¥
- FindObjectOfType ê²°ê³¼ ì²´í¬ ì•ˆí•¨

**ê°œì„  ë°©ë²•:**
- ëª¨ë“  FindObject ê²°ê³¼ì— null ì²´í¬ ì¶”ê°€
- OnValidate()ë¡œ Inspector í•„ë“œ ê²€ì¦
- Required ì»´í¬ë„ŒíŠ¸ë¥¼ RequireComponent ì†ì„±ìœ¼ë¡œ ëª…ì‹œ

### 3. **GC ìµœì í™” (ë§¤ í”„ë ˆì„ Allocation)**

**ì‹¬ê°ë„:** â­â­â­â­  
**ì´ìœ :**
- Loggerì—ì„œ string interpolation ê³¼ë‹¤ ì‚¬ìš©
- Enum.ToString() ë§¤ í”„ë ˆì„ í˜¸ì¶œ
- BehaviorTree ì „ì²´ ìˆœíšŒ ì‹œ string ìƒì„±

**ê°œì„  ë°©ë²•:**
```csharp
// Conditional Compilation
#if UNITY_EDITOR && DEBUG_VERBOSE
Logger.Write($"State: {state}");
#endif

// StringBuilder í™œìš©
private StringBuilder _logBuilder = new StringBuilder(256);

// Enum Caching
private static readonly string[] StateNames = Enum.GetNames(typeof(PlayerState));
```

---

## ğŸ”§ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Top 3)

### 1. **ì˜ì¡´ì„± ì£¼ì… (DI) í”„ë ˆì„ì›Œí¬ ë„ì…**

**ì˜ˆìƒ ê¸°ê°„:** 2-3ì£¼  
**íš¨ê³¼:**
- FindObjectOfType ì œê±°ë¡œ ì„±ëŠ¥ í–¥ìƒ
- í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ì¦ê°€
- ì»´í¬ë„ŒíŠ¸ ê°„ ê²°í•©ë„ ê°ì†Œ

**êµ¬í˜„ ì˜ˆì‹œ:**
```csharp
// VContainer ë˜ëŠ” Zenject ì‚¬ìš©
public class PlayerInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        Container.Bind<IHealthSystem>().To<PlayerHealth>().AsSingle();
        Container.Bind<IAttackSystem>().To<PlayerAttack>().AsSingle();
        Container.Bind<IMovementController>().To<RigidbodyMovement>().AsSingle();
    }
}
```

### 2. **ì• ë‹ˆë©”ì´ì…˜ ì´ë²¤íŠ¸ ê¸°ë°˜ ì „íˆ¬ ì‹œìŠ¤í…œ**

**ì˜ˆìƒ ê¸°ê°„:** 1-2ì£¼  
**íš¨ê³¼:**
- ê³µê²© íƒ€ì´ë° ì •í™•ë„ ì¦ê°€
- ì• ë‹ˆë©”ì´ì…˜-ì½”ë“œ ë™ê¸°í™” ê°œì„ 
- VFX/SFX íƒ€ì´ë° ìë™í™”

**êµ¬í˜„ ë°©í–¥:**
- Animation Eventë¡œ hitbox í™œì„±í™”/ë¹„í™œì„±í™”
- ì• ë‹ˆë©”ì´ì…˜ì—ì„œ ë°ë¯¸ì§€ íƒ€ì´ë° ì œì–´
- Root Motion í™œìš© ê²€í† 

### 3. **Namespace êµ¬ì¡°í™” ë° Assembly Definition**

**ì˜ˆìƒ ê¸°ê°„:** 1ì£¼  
**íš¨ê³¼:**
- ì»´íŒŒì¼ ì‹œê°„ ë‹¨ì¶•
- ì´ë¦„ ì¶©ëŒ ë°©ì§€
- ì•„í‚¤í…ì²˜ ëª…í™•í™”

**êµ¬ì¡° ì˜ˆì‹œ:**
```
ProjectMagic.Core (Core.asmdef)
â”œâ”€â”€ FSM, BT, Interfaces

ProjectMagic.Common (Common.asmdef)
â”œâ”€â”€ HealthSystem, AttackSystem
â””â”€â”€ depends on Core

ProjectMagic.Characters (Characters.asmdef)
â”œâ”€â”€ Player, Enemy
â””â”€â”€ depends on Core, Common

ProjectMagic.AI (AI.asmdef)
â”œâ”€â”€ LLM, OpenVINO
â””â”€â”€ depends on Core
```

---

## âœ¨ ì˜í•œ ì  (Best Parts, Top 3)

### 1. **FSMê³¼ Behavior Treeì˜ ì ì ˆí•œ ë¶„ë¦¬ ì‚¬ìš©**

- Playerì—ëŠ” ëª…í™•í•œ ìƒíƒœ ì „ì´ê°€ í•„ìš”í•˜ë¯€ë¡œ FSM
- Enemyì—ëŠ” ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ì˜ì‚¬ê²°ì •ì´ í•„ìš”í•˜ë¯€ë¡œ BT
- ê°ê°ì˜ íŠ¹ì„±ì— ë§ëŠ” íŒ¨í„´ ì„ íƒìœ¼ë¡œ í™•ì¥ì„± í™•ë³´
- FSMNode, BTNode ì¶”ìƒí™”ë¡œ ì¬ì‚¬ìš© ê°€ëŠ¥

### 2. **ScriptableObject ê¸°ë°˜ ë°ì´í„° ì£¼ë„ ì„¤ê³„**

- CharacterStats, SkillDataë¥¼ SOë¡œ ê´€ë¦¬
- ì½”ë“œ ìˆ˜ì • ì—†ì´ ë°¸ëŸ°ì‹± ê°€ëŠ¥
- í”„ë¦¬íŒ¹ ê¸°ë°˜ ê°œë°œ ê°€ëŠ¥
- ëŸ°íƒ€ì„ ë©”ëª¨ë¦¬ íš¨ìœ¨ì 

### 3. **OpenVINO í†µí•© ì•„í‚¤í…ì²˜**

- Worker Threadë¡œ ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ë°©ì§€
- ConcurrentQueueë¡œ Thread-safe êµ¬í˜„
- Request/Response íŒ¨í„´ìœ¼ë¡œ ë¹„ë™ê¸° ì²˜ë¦¬
- Session ê´€ë¦¬ë¡œ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ìœ ì§€
- Unity GameObjectì™€ Native Pluginì˜ ê¹”ë”í•œ ë¶„ë¦¬

---

## ğŸ“Š ê°œì„  ë¡œë“œë§µ (ìš°ì„ ìˆœìœ„)

### Phase 1 (ì¦‰ì‹œ - 1ì£¼)
1. Null ì²´í¬ ë° Validation ì¶”ê°€
2. Logger string interpolationì„ conditional compilationìœ¼ë¡œ
3. Magic Number ìƒìˆ˜í™”
4. Tooltip/Range ì†ì„± ì¶”ê°€

### Phase 2 (1-2ì£¼)
1. PlayerBehavior State í´ë˜ìŠ¤ ë¶„ë¦¬
2. Timer ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ ë„ì…
3. Namespace ì ìš©
4. AttackSystem GC ìµœì í™”

### Phase 3 (2-4ì£¼)
1. DI í”„ë ˆì„ì›Œí¬ ë„ì…
2. Animation Event ê¸°ë°˜ ì „íˆ¬
3. Assembly Definition êµ¬ì„±
4. Unit Test ì¸í”„ë¼ êµ¬ì¶•

### Phase 4 (ì¥ê¸°)
1. ECS ì „í™˜ ê²€í† 
2. Addressable Assets
3. ë©€í‹°í”Œë ˆì´ì–´ ëŒ€ì‘ ì„¤ê³„
4. Tool Call ì‹œìŠ¤í…œ ì™„ì„±

---

## ğŸ“ ìµœì¢… ì½”ë©˜íŠ¸

ì „ë°˜ì ìœ¼ë¡œ **Unity ê²Œì„ ê°œë°œì˜ í•µì‹¬ íŒ¨í„´ê³¼ êµ¬ì¡°ë¥¼ ì˜ ì´í•´í•˜ê³  ìˆëŠ” ì½”ë“œ**ì…ë‹ˆë‹¤. FSM/BT ë¶„ë¦¬, ScriptableObject í™œìš©, OpenVINO í†µí•© ë“± **ì•„í‚¤í…ì²˜ì  ì„ íƒì´ ë§¤ìš° ìš°ìˆ˜**í•©ë‹ˆë‹¤.

ë‹¤ë§Œ, **ì„¸ë¶€ì ì¸ ì½”ë“œ í’ˆì§ˆ (Readability, Performance, Safety)** ì¸¡ë©´ì—ì„œ ê°œì„ ì˜ ì—¬ì§€ê°€ ë§ìŠµë‹ˆë‹¤. íŠ¹íˆ:
- God Class ë¶„ë¦¬
- GC Allocation ìµœì í™”
- ë°©ì–´ì  í”„ë¡œê·¸ë˜ë° ê°•í™”

ì´ ì„¸ ê°€ì§€ë§Œ ê°œì„ í•´ë„ **ì „ì²´ ì½”ë“œ í’ˆì§ˆì´ 8.0/10 ì´ìƒ**ìœ¼ë¡œ ìƒìŠ¹í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤.

**í˜„ì¬ ìƒíƒœ:** í”„ë¡œí† íƒ€ì…/MVP ìˆ˜ì¤€ìœ¼ë¡œ ì¶©ë¶„í•˜ì§€ë§Œ, í”„ë¡œë•ì…˜ ì¶œì‹œ ì „ì—ëŠ” ë¦¬íŒ©í† ë§ì´ í•„ìš”í•©ë‹ˆë‹¤.  
**ê¶Œì¥ ì‚¬í•­:** Phase 1-2ë¥¼ ë¨¼ì € ì™„ë£Œí•˜ê³ , ê²Œì„ ì»¨í…ì¸  ê°œë°œê³¼ ë³‘í–‰í•˜ë©° Phase 3-4ë¥¼ ì§„í–‰í•˜ì„¸ìš”.

---

**í‰ê°€ì:** GitHub Copilot (Claude Sonnet 4.5)  
**í‰ê°€ ê¸°ì¤€:** Unity C# Code Evaluation Prompt (10ê°€ì§€ í•­ëª©)
