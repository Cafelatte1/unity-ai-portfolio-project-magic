# ğŸ® Unity C# Code Quality Evaluation Report
**Date**: 2025-12-11  
**Project**: Project-Magic  
**Evaluated Codebase**: `Assets/Scripts/`

---

## ğŸ“Œ 1. Architecture & Unity Component Design

### âœ… í‰ê°€
- **SRP ì¤€ìˆ˜ë„**: 7/10
  - ê¸ì •ì : `PlayerBehavior`, `EnemyBehavior` ë“±ì´ FSM/BT íŒ¨í„´ì„ ì‚¬ìš©í•´ ìƒíƒœ ë¡œì§ì„ ë¶„ë¦¬
  - ê¸ì •ì : `AttackSystem`, `HealthSystem` ë“± ê³µí†µ ì‹œìŠ¤í…œì´ ì¶”ìƒ í´ë˜ìŠ¤ë¡œ ì˜ ë¶„ë¦¬ë¨
  - ë¬¸ì œì : `PlayerBehavior`ê°€ 420+ ë¼ì¸ìœ¼ë¡œ ë¹„ëŒ€í•¨ (ì…ë ¥ ì²˜ë¦¬, FSM, ì• ë‹ˆë©”ì´ì…˜, ë¬¼ë¦¬ ë“± ì—¬ëŸ¬ ì±…ì„ ë³´ìœ )
  
- **Unity ìƒëª…ì£¼ê¸° ì‚¬ìš©**: 8/10
  - `Awake`ì—ì„œ ì»´í¬ë„ŒíŠ¸ ìºì‹±, `Start`ì—ì„œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡, `FixedUpdate`ì—ì„œ ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ ë“± ì ì ˆíˆ ë¶„ë¦¬
  - `Update`ì™€ `FixedUpdate` ì—­í• ì´ ì˜ êµ¬ë¶„ë¨
  
- **Composition vs Inheritance**: 8/10
  - `AttackSystem`, `HealthSystem` ì¶”ìƒ í´ë˜ìŠ¤ ìƒì† êµ¬ì¡° ì–‘í˜¸
  - FSM/BT ë…¸ë“œ êµ¬ì¡°ê°€ composition íŒ¨í„´ì„ ì˜ í™œìš©
  - nested classë¡œ FSM stateë¥¼ êµ¬í˜„í•œ ë¶€ë¶„ì€ ê°€ë…ì„±ì€ ì¢‹ìœ¼ë‚˜ ì¬ì‚¬ìš©ì„±ì´ ë‚®ìŒ

- **êµ¬ì¡°ì  í™•ì¥ì„±**: 7/10
  - ScriptableObjectë¥¼ ì‚¬ìš©í•œ ë°ì´í„° ê¸°ë°˜ ì„¤ê³„(`CharacterStats`, `SkillData`) ìš°ìˆ˜
  - UnityEventë¥¼ í†µí•œ ëŠìŠ¨í•œ ê²°í•©(`EventHit`, `EventDeath`, `EventAttack`) ì–‘í˜¸
  - DI íŒ¨í„´ì€ ë¶€ì¬ (FindFirstObjectByType ì‚¬ìš©)

### âŒ ë¬¸ì œì 
1. **PlayerBehaviorê°€ ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°€ì§**: ì…ë ¥, ìƒíƒœê´€ë¦¬, ë¬¼ë¦¬, ì• ë‹ˆë©”ì´ì…˜ ì œì–´ë¥¼ ëª¨ë‘ ë‹´ë‹¹
2. **Nested class state íŒ¨í„´ì˜ í•œê³„**: ê° stateê°€ nested classë¡œ êµ¬í˜„ë˜ì–´ ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì¬ì‚¬ìš© ë¶ˆê°€
3. **APCRouterë¥¼ FindFirstObjectByTypeìœ¼ë¡œ ì°¾ìŒ**: DI íŒ¨í„´ ëŒ€ì‹  ì§ì ‘ ê²€ìƒ‰

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// ì…ë ¥ ì²˜ë¦¬ë¥¼ ë³„ë„ í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬
public class PlayerInputHandler : MonoBehaviour
{
    public UnityEvent<float> OnMoveInput;
    public UnityEvent OnJumpInput;
    public UnityEvent OnAttackInput;
    
    public void OnMove(InputValue value) => OnMoveInput?.Invoke(value.Get<float>());
    public void OnJump(InputValue value) => OnJumpInput?.Invoke();
    public void OnAttack(InputValue value) => OnAttackInput?.Invoke();
}

// FSM Stateë¥¼ ë³„ë„ íŒŒì¼ë¡œ ë¶„ë¦¬í•˜ì—¬ ì¬ì‚¬ìš©ì„± ì¦ê°€
public class PlayerMoveState : FSMNode
{
    private PlayerBehavior ctx;
    public PlayerMoveState(PlayerBehavior ctx) { this.ctx = ctx; }
    // ... êµ¬í˜„
}
```

---

## ğŸ“Œ 2. Code Readability & Maintainability

### âœ… í‰ê°€ (7.5/10)
- **ë„¤ì´ë° ê·œì¹™**: 8/10
  - ëŒ€ë¶€ë¶„ camelCase, PascalCaseë¥¼ ì¼ê´€ë˜ê²Œ ì‚¬ìš©
  - private í•„ë“œì— underscore prefix ì‚¬ìš© (`_moveInput`, `_jumpInput`) - ì¼ê´€ì„± ìˆìŒ
  - enumì€ PascalCaseë¡œ í†µì¼ë¨
  
- **ì˜ë¯¸ ì „ë‹¬ë ¥**: 8/10
  - `PlayerBehavior`, `AttackSystem`, `HealthSystem` ë“± ëª…í™•í•œ ë„¤ì´ë°
  - `CheckGrounded()`, `FlipDirection()`, `UpdateVelocity()` ë“± ë©”ì„œë“œëª…ì´ ì§ê´€ì 
  - ì¼ë¶€ ì•½ì–´ ì‚¬ìš©: `ctx` (context), `rb` (rigidbody), `apc` (companion?)
  
- **ì£¼ì„/XML**: 4/10
  - XML ë¬¸ì„œ ì£¼ì„ì´ ê±°ì˜ ì—†ìŒ
  - ë³µì¡í•œ ë¡œì§ì— ì¸ë¼ì¸ ì£¼ì„ ë¶€ì¡±
  - `[Header]` attributeë¡œ Inspector ê°€ë…ì„±ì€ í™•ë³´
  
- **ì¤‘ë³µ ì œê±°**: 6/10
  - `FlipDirection()`ì´ `PlayerBehavior`, `EnemyBehavior`ì— ì¤‘ë³µ
  - `GetComponentInChildren<StatsContainer>().stats` íŒ¨í„´ì´ ì—¬ëŸ¬ íŒŒì¼ì— ë°˜ë³µ
  
- **ëª¨ë“ˆí™”**: 6/10
  - ë©”ì„œë“œ í¬ê¸°ëŠ” ëŒ€ì²´ë¡œ ì ì ˆ
  - `PlayerBehavior` í´ë˜ìŠ¤ê°€ 420+ ë¼ì¸ìœ¼ë¡œ ë„ˆë¬´ í¼

### âŒ ë¬¸ì œì 
1. XML ë¬¸ì„œ ì£¼ì„ì´ ì „ë¬´í•¨
2. `FlipDirection`, `UpdateVelocity` ë“± ì¤‘ë³µ ë¡œì§
3. Magic number: `1e-1`, `0.2f`, `Mathf.Epsilon` ë“± ìƒìˆ˜í™”ë˜ì§€ ì•ŠìŒ
4. ë³µì¡í•œ Physics2D ê³„ì‚°ì— ì„¤ëª… ì£¼ì„ ë¶€ì¡±

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// ê³µí†µ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ë¡œ ì¤‘ë³µ ì œê±°
public static class MovementUtils
{
    private const float DISTANCE_THRESHOLD = 0.1f;
    private const float RAYCAST_RADIUS = 0.2f;
    
    /// <summary>
    /// ìºë¦­í„°ì˜ ë°©í–¥ì„ ì¢Œìš° ë°˜ì „í•©ë‹ˆë‹¤.
    /// </summary>
    public static void FlipDirection(Transform transform)
    {
        Vector3 scale = transform.localScale;
        scale.x = -scale.x;
        transform.localScale = scale;
    }
    
    /// <summary>
    /// ë‘ ìœ„ì¹˜ ê°„ ê±°ë¦¬ê°€ ì„ê³„ê°’ ì´ë‚´ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    /// </summary>
    public static bool IsWithinDistance(Vector3 from, Vector3 to, float threshold = DISTANCE_THRESHOLD)
    {
        return Vector3.Distance(from, to) <= threshold;
    }
}

// XML ë¬¸ì„œí™”
/// <summary>
/// í”Œë ˆì´ì–´ì˜ í–‰ë™ì„ ê´€ë¦¬í•˜ëŠ” ë©”ì¸ ì»¨íŠ¸ë¡¤ëŸ¬ì…ë‹ˆë‹¤.
/// FSM íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ Xì¶•/Yì¶• ìƒíƒœë¥¼ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬í•©ë‹ˆë‹¤.
/// </summary>
public class PlayerBehavior : MonoBehaviour
{
    // ...
}
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

### âœ… í‰ê°€ (8/10)
- **Update ìµœì í™”**: 8/10
  - `Update` ë‚´ì—ì„œ `IsAlive` ì²´í¬ë¡œ ë¶ˆí•„ìš”í•œ ì—°ì‚° ë°©ì§€
  - Timer ì—…ë°ì´íŠ¸ë§Œ ìˆ˜í–‰í•˜ëŠ” `TickUpdate()` ë¶„ë¦¬ - ê¹”ë”í•¨
  - Enemyì˜ ê²½ìš° ë§¤ í”„ë ˆì„ BTë¥¼ evaluateí•˜ì§€ë§Œ state machineì´ íš¨ìœ¨ì 
  
- **GC Allocation**: 9/10
  - **ë§¤ìš° ìš°ìˆ˜**: `ObjectPool<T>` ì œë„¤ë¦­ í’€ë§ ì‹œìŠ¤í…œ êµ¬í˜„
  - Dictionary/QueueëŠ” Awakeì—ì„œ ì´ˆê¸°í™”ë˜ì–´ ëŸ°íƒ€ì„ í• ë‹¹ ì—†ìŒ
  - `EvaluateResult` struct ì‚¬ìš©ìœ¼ë¡œ boxing íšŒí”¼
  - Linq ì‚¬ìš© ì—†ìŒ - GC-friendly
  
- **ê°ì²´ ì¬ì‚¬ìš©**: 9/10
  - `ObjectPool<SkillLogic>` ì œë„¤ë¦­ í’€ë§ì´ íˆ¬ì‚¬ì²´/ìŠ¤í‚¬ ì²˜ë¦¬
  - í’€ì´ ë¶€ì¡±í•  ê²½ìš° ìë™ í™•ì¥ (dynamic allocation)
  
- **Physics ìµœì í™”**: 7/10
  - `FixedUpdate`ì—ì„œ ë¬¼ë¦¬ ì²˜ë¦¬ (ì˜¬ë°”ë¦„)
  - `BoxCollider2D.IsTouchingLayers` ì‚¬ìš© - íš¨ìœ¨ì 
  - `Physics2D.OverlapCircle/Box` ì‚¬ìš© - ìºì‹± ì—†ìŒ (ë§¤ í”„ë ˆì„ í• ë‹¹)
  
- **GetComponent ìºì‹±**: 9/10
  - ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë¥¼ `Awake`ì—ì„œ ìºì‹±
  - `TryGetComponent` ì‚¬ìš©ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬

### âŒ ë¬¸ì œì 
1. **Physics2D overlap ê²°ê³¼ ìºì‹± ì—†ìŒ**: `ExecuteMeleeAttack`ì—ì„œ ë§¤ë²ˆ `OverlapCircle` í˜¸ì¶œ
2. **String concatenation in logging**: Loggerì—ì„œ ë¬¸ìì—´ ë³´ê°„ ì‚¬ìš©ìœ¼ë¡œ GC ë°œìƒ ê°€ëŠ¥
3. **FindFirstObjectByType ì‚¬ìš©**: `HealthSystem.Start()`ì—ì„œ ëŸ°íƒ€ì„ ê²€ìƒ‰

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// Physics ì¿¼ë¦¬ ê²°ê³¼ë¥¼ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ë°°ì—´ë¡œ ìºì‹±
public class AttackSystem : MonoBehaviour
{
    private Collider2D[] hitResults = new Collider2D[10]; // ì¬ì‚¬ìš© ë°°ì—´
    
    protected virtual void ExecuteMeleeAttack(...)
    {
        // OverlapCircleNonAlloc ì‚¬ìš©ìœ¼ë¡œ GC ì œê±°
        int hitCount = Physics2D.OverlapCircleNonAlloc(
            attackBox,
            hitAreaRadius,
            hitResults,
            targetLayerMask
        );
        
        for (int i = 0; i < hitCount; i++)
        {
            if (hitResults[i].TryGetComponent<HealthSystem>(out var healthSystem))
            {
                ApplyAttack(attack, origin.position, hitResults[i].transform.position, healthSystem);
            }
        }
    }
}

// Loggerì—ì„œ conditional attribute ì‚¬ìš©
public static class Logger
{
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    public static void Write(string message, string level = "INFO")
    {
        // Release ë¹Œë“œì—ì„œëŠ” ì™„ì „íˆ ì œê±°ë¨
        Debug.Log($"[{level}] {message}");
    }
}
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

### âœ… í‰ê°€ (7/10)
- **ì…ë ¥ ì²˜ë¦¬**: 8/10
  - Input System (new) ì‚¬ìš© - í˜„ëŒ€ì 
  - Snapshot íŒ¨í„´ ì‚¬ìš©: `_snapShotMoveInput`, `_snapShotjumpInput`ìœ¼ë¡œ Update/FixedUpdate ë™ê¸°í™”
  - ì í”„ ì…ë ¥ ë²„í¼ë§: `_jumpInput` flag ì‚¬ìš©
  
- **ìƒíƒœ ì „ì´**: 8/10
  - FSM (Player)ê³¼ BT (Enemy) í˜¼ìš© - ê°ê° ì ì ˆí•¨
  - ë²„í¼ í ì‹œìŠ¤í…œ (`bufferXState`, `bufferYState`)ìœ¼ë¡œ ìƒíƒœ ì „í™˜ ì•ˆì •ì 
  - Xì¶•/Yì¶• ë…ë¦½ ìƒíƒœ ê´€ë¦¬ - ìš°ìˆ˜í•œ ì„¤ê³„
  
- **íƒ€ì´ë°/ë™ì‹œì„±**: 7/10
  - Recovery timerë¥¼ í†µí•œ ì¿¨ë‹¤ìš´ ê´€ë¦¬
  - `_hitRecoveryTimer > 0` ì²´í¬ë¡œ í”¼ê²© ì¤‘ í–‰ë™ ì œí•œ
  - `_attackRecoveryTimer > 0` ì²´í¬ë¡œ ê³µê²© ì¤‘ ì¤‘ë³µ ë°©ì§€
  
- **Null/Exception ë°©ì–´**: 6/10
  - `TryGetComponent` ì¼ë¶€ ì‚¬ìš©
  - `IsAlive` ì²´í¬
  - í•˜ì§€ë§Œ `GetComponentInChildren<StatsContainer>().stats`ì—ì„œ null ì²´í¬ ì—†ìŒ
  
- **Edge Case**: 6/10
  - Ground check, wall check êµ¬í˜„ë¨
  - í•˜ì§€ë§Œ Raycast marginì´ í•˜ë“œì½”ë”© (`raycastDetectionMargin`)
  - ê³µì¤‘ ê³µê²©, ë‚™í•˜ ì¤‘ ìƒíƒœ ë³€í™” ë“± edge case ì²˜ë¦¬ ë¶€ì¡±

### âŒ ë¬¸ì œì 
1. **GetComponentInChildren null ì²´í¬ ì—†ìŒ**: í•„ìˆ˜ ì»´í¬ë„ŒíŠ¸ ëˆ„ë½ ì‹œ í¬ë˜ì‹œ
2. **ê³µê²© ì¤‘ ì´ë™ ì œí•œ ë¶ˆì™„ì „**: `_attackRecoveryTimer` ì²´í¬ê°€ ì¼ë¶€ Stateì—ë§Œ ì ìš©
3. **Jump buffer ì œí•œ ì—†ìŒ**: `_jumpInput` flagê°€ í•œ í”„ë ˆì„ë§Œ ìœ ì§€ë˜ì–´ ì…ë ¥ ëˆ„ë½ ê°€ëŠ¥
4. **Physicsì™€ Transform í˜¼ìš©**: ì¼ë¶€ ì½”ë“œì—ì„œ `transform.position` ì§ì ‘ ìˆ˜ì •

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// í•„ìˆ˜ ì»´í¬ë„ŒíŠ¸ null ì²´í¬
void Awake()
{
    var statsContainer = GetComponentInChildren<StatsContainer>();
    if (statsContainer == null)
    {
        Logger.Write("StatsContainer not found!", "ERROR");
        enabled = false;
        return;
    }
    stats = statsContainer.stats;
    
    // ... ë‚˜ë¨¸ì§€ ì»´í¬ë„ŒíŠ¸ë„ ë™ì¼í•˜ê²Œ ì²´í¬
}

// Jump buffer queueë¡œ ë³€ê²½ (ì—¬ëŸ¬ í”„ë ˆì„ ì…ë ¥ ë³´ì¡´)
public class PlayerBehavior : MonoBehaviour
{
    private Queue<float> jumpInputBuffer = new Queue<float>();
    private const float JUMP_BUFFER_TIME = 0.15f;
    
    public void OnJump(InputValue value)
    {
        if (value.isPressed)
        {
            jumpInputBuffer.Enqueue(Time.time);
        }
    }
    
    private bool TryConsumeJumpInput()
    {
        while (jumpInputBuffer.Count > 0)
        {
            float inputTime = jumpInputBuffer.Peek();
            if (Time.time - inputTime <= JUMP_BUFFER_TIME)
            {
                jumpInputBuffer.Dequeue();
                return true;
            }
            jumpInputBuffer.Dequeue(); // ì˜¤ë˜ëœ ì…ë ¥ ì œê±°
        }
        return false;
    }
}

// ê³µê²© ì¤‘ ì´ë™ ì œí•œ ì¼ê´€ì„± í™•ë³´
class StateMove : FSMNode
{
    public override void Update()
    {
        FlipDirection();
        // ê³µê²© ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€
        if (ctx._hitRecoveryTimer <= 0 && ctx._attackRecoveryTimer <= 0)
        {
            UpdateVelocity();
        }
    }
}
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

### âœ… í‰ê°€ (8.5/10)
- **GetComponent ìºì‹±**: 10/10
  - ëª¨ë“  `GetComponent` í˜¸ì¶œì´ `Awake`ì—ì„œ ìˆ˜í–‰ë˜ê³  í•„ë“œì— ìºì‹±ë¨
  - ëŸ°íƒ€ì„ ì¤‘ GetComponent í˜¸ì¶œ ì—†ìŒ
  
- **Time.deltaTime ë³´ì •**: 9/10
  - ëª¨ë“  timerì— `Time.deltaTime` ì ìš©
  - ì´ë™ì— `moveSpeed * Time.deltaTime` ë¯¸ì ìš© (velocity ì§ì ‘ ì„¤ì •ì´ë¯€ë¡œ ë¶ˆí•„ìš”)
  
- **Physics/Transform ë¶„ë¦¬**: 7/10
  - ëŒ€ë¶€ë¶„ Rigidbody2D ì‚¬ìš© (ì˜¬ë°”ë¦„)
  - ì¼ë¶€ `transform.position` ì§ì ‘ ìˆ˜ì • (APCBehavior)
  
- **SerializeField/Header**: 9/10
  - ëª¨ë“  Inspector ë…¸ì¶œ í•„ë“œì— `[SerializeField]` ì‚¬ìš©
  - `[Header]` attributeë¡œ ê·¸ë£¹í•‘ - ê°€ë…ì„± ìš°ìˆ˜
  - `[Tooltip]` ë¯¸ì‚¬ìš© - ê°œì„  ì—¬ì§€
  
- **Magic Number**: 5/10
  - ì—¬ì „íˆ ë§ì€ í•˜ë“œì½”ë”©: `1e-1`, `0.2f`, `Mathf.Epsilon`
  - ì¼ë¶€ëŠ” SerializeFieldë¡œ ë…¸ì¶œë˜ì—ˆìœ¼ë‚˜ ì˜ë¯¸ìˆëŠ” const ìƒìˆ˜ë¡œ ì •ì˜ í•„ìš”
  
- **Prefab ì¤‘ì‹¬**: 8/10
  - ScriptableObject ê¸°ë°˜ ë°ì´í„° ì„¤ê³„
  - Skill prefab ì‹œìŠ¤í…œ

### âŒ ë¬¸ì œì 
1. **Tooltip ë¶€ì¬**: Inspectorì—ì„œ ê° í•„ë“œì˜ ì˜ë¯¸ íŒŒì•… ì–´ë ¤ì›€
2. **Magic number ê³¼ë‹¤**: `1e-1`, `0.2f` ë“± ì˜ë¯¸ ë¶ˆëª…í™•
3. **APCBehaviorì—ì„œ transform.position ì§ì ‘ ìˆ˜ì •**: Rigidbodyê°€ ìˆë‹¤ë©´ physics í†µí•´ ì´ë™í•´ì•¼ í•¨

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
public class PlayerBehavior : MonoBehaviour
{
    [Header("Ground Detection")]
    [SerializeField, Tooltip("ì°©ì§€ íŒì •ì„ ìœ„í•œ ì†ë„ ì—¬ìœ ê°’")]
    private float landingVelocityMargin = 0.1f;
    
    [SerializeField, Tooltip("ì§€ë©´ìœ¼ë¡œ ì¸ì‹í•  ë ˆì´ì–´")]
    private LayerMask layerGround;
    
    [SerializeField, Tooltip("ì§€ë©´ ê°ì§€ì— ì‚¬ìš©í•  ì½œë¼ì´ë”")]
    private BoxCollider2D colliderGround;
    
    // ìƒìˆ˜ ì •ì˜
    private const float MIN_DISTANCE_THRESHOLD = 0.1f;
    private const float RAYCAST_RADIUS = 0.2f;
    
    // ... ë‚˜ë¨¸ì§€ ì½”ë“œ
}

// APCBehavior - Physics ê¸°ë°˜ ì´ë™ìœ¼ë¡œ ë³€ê²½
public class APCBehavior : MonoBehaviour
{
    private Rigidbody2D rb;
    
    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        // ...
    }
    
    private void UpdatePosition()
    {
        // Lerp ëŒ€ì‹  MovePosition ì‚¬ìš© (Physics ì‹œë®¬ë ˆì´ì…˜ê³¼ í˜¸í™˜)
        Vector2 newPos = Vector2.Lerp(
            rb.position, followPos,
            stats.moveSpeed * shieldFollowSpeedMultiplier * Time.fixedDeltaTime
        );
        rb.MovePosition(newPos);
    }
}
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

### âœ… í‰ê°€ (8/10)
- **Animator ë™ê¸°í™”**: 8/10
  - `AnimationController` ë³„ë„ í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬ (ì½”ë“œ ë¯¸í™•ì¸ì´ë‚˜ ì‚¬ìš© íŒ¨í„´ ì–‘í˜¸)
  - `PlayStateAnimation()` ë©”ì„œë“œê°€ clip ê¸¸ì´ë¥¼ ë°˜í™˜í•˜ì—¬ íƒ€ì´ë° ë™ê¸°í™”
  - `rebind` íŒŒë¼ë¯¸í„°ë¡œ ì• ë‹ˆë©”ì´ì…˜ ì¬ì‹œì‘ ì œì–´
  
- **FSM/BT êµ¬ì¡°**: 9/10
  - Player: Xì¶•/Yì¶• ë…ë¦½ FSM - ë§¤ìš° ìš°ìˆ˜í•œ ì„¤ê³„
  - Enemy: Behavior Tree (Selector/Sequence/Action) - í™•ì¥ì„± ë†’ìŒ
  - ìƒíƒœ ì „ì´ ë¡œì§ì´ ëª…í™•í•˜ê³  ì¶”ì  ê°€ëŠ¥
  
- **Animation Event**: ì ìˆ˜ ë¶ˆê°€ (ì½”ë“œ ë¯¸í™•ì¸)
  - í˜„ì¬ ì½”ë“œì—ì„œ Animation Event ì‚¬ìš© í”ì  ì—†ìŒ
  
- **Root Motion vs Velocity**: 8/10
  - Velocity ê¸°ë°˜ ì´ë™ ì‚¬ìš© - physicsì™€ ì˜ í†µí•©ë¨
  - Root motionì€ ë¯¸ì‚¬ìš© (ë‹¨ìˆœí•œ 2D ê²Œì„ì— ì í•©)
  
- **Event Flow**: 8/10
  - UnityEvent ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©
  - `EventHit`, `EventDeath`, `EventAttack`, `EventShield` ë“± ëª…í™•í•œ ì´ë²¤íŠ¸

### âŒ ë¬¸ì œì 
1. **ê³µê²© ì• ë‹ˆë©”ì´ì…˜ ì¤‘ ì´ë™ ì œí•œ ë¶ˆì™„ì „**: StateMoveì—ì„œ `_attackRecoveryTimer` ì²´í¬ ëˆ„ë½
2. **Animation clip ê¸¸ì´ ì˜ì¡´ì„±**: `PlayStateAnimation()`ì´ clip ê¸¸ì´ë¥¼ ë°˜í™˜í•˜ëŠ”ë°, clipì´ ë³€ê²½ë˜ë©´ ê²Œì„ ë¡œì§ë„ ì˜í–¥ë°›ìŒ
3. **BT evaluate ë§¤ í”„ë ˆì„ ì‹¤í–‰**: ìµœì í™” ì—¬ì§€ (ì¡°ê±´ ìºì‹±, ì£¼ê¸°ì  ì‹¤í–‰ ë“±)

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// ê³µê²© ì¤‘ ì´ë™ ì™„ì „ ì°¨ë‹¨
class StateMove : FSMNode
{
    public override void Update()
    {
        FlipDirection();
        
        // ê³µê²© ì¤‘ì—ëŠ” ì´ë™ ë¶ˆê°€ (ì¼ê´€ì„± í™•ë³´)
        if (ctx._hitRecoveryTimer <= 0 && ctx._attackRecoveryTimer <= 0)
        {
            UpdateVelocity();
        }
        else
        {
            // ê³µê²© ì¤‘ì—ëŠ” ì†ë„ë¥¼ 0ìœ¼ë¡œ
            Vector2 velocity = ctx.rb.linearVelocity;
            velocity.x = 0;
            ctx.rb.linearVelocity = velocity;
        }
    }
}

// BT ì‹¤í–‰ ì£¼ê¸° ìµœì í™”
public class EnemyBehavior : MonoBehaviour
{
    private float btUpdateInterval = 0.1f; // 0.1ì´ˆë§ˆë‹¤ ì‹¤í–‰
    private float btUpdateTimer = 0f;
    
    void FixedUpdate()
    {
        btUpdateTimer += Time.fixedDeltaTime;
        if (btUpdateTimer >= btUpdateInterval)
        {
            btUpdateTimer = 0f;
            var (selectorResult, actionPath) = selectorRoot.Evaluate();
            Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}");
        }
    }
}

// Animation ê¸¸ì´ë¥¼ ScriptableObjectì— ì €ì¥í•˜ì—¬ ë°ì´í„° ê¸°ë°˜ìœ¼ë¡œ ë³€ê²½
[CreateAssetMenu(fileName = "Animation Config", menuName = "Game/Animation Config")]
public class AnimationConfig : ScriptableObject
{
    public float attackDuration;
    public float damagedDuration;
    // ...
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

### âœ… í‰ê°€ (6/10)
- **Null ë°©ì–´**: 6/10
  - ì¼ë¶€ `TryGetComponent` ì‚¬ìš© (SkillLogic, AttackSystem)
  - `IsAlive` ì²´í¬
  - **ì¹˜ëª…ì **: `GetComponentInChildren<StatsContainer>().stats` ì²´í¬ ì—†ìŒ
  
- **Input ë¹„ë™ê¸° ì²˜ë¦¬**: 7/10
  - Snapshot íŒ¨í„´ìœ¼ë¡œ Update/FixedUpdate ë™ê¸°í™” ìš°ìˆ˜
  - Jump bufferëŠ” ë‹¨ìˆœ flag ë°©ì‹ (ê°œì„  ì—¬ì§€)
  
- **Boundary ì²´í¬**: 7/10
  - Ground check, wall check êµ¬í˜„
  - Patrol range ì²´í¬
  - í•˜ì§€ë§Œ ì†ë„ ì œí•œ, ìœ„ì¹˜ í´ë¨í•‘ ì—†ìŒ
  
- **Initialize ìˆœì„œ**: 7/10
  - Awake/Start ë¶„ë¦¬ ì ì ˆ
  - Event ë¦¬ìŠ¤ë„ˆëŠ” Startì—ì„œ ë“±ë¡
  - í•˜ì§€ë§Œ Singleton patternì—ì„œ Instance í˜¸ì¶œ ìˆœì„œ ì˜ì¡´ì„± ìˆìŒ

### âŒ ë¬¸ì œì 
1. **í•„ìˆ˜ ì»´í¬ë„ŒíŠ¸ null ì²´í¬ ì „ë¬´**: `GetComponentInChildren` ì‹¤íŒ¨ ì‹œ NullReferenceException
2. **Array bounds ì²´í¬ ì—†ìŒ**: `ExecuteAttack(attackIndex)` ì—ì„œ ë²”ìœ„ ì²´í¬ ìˆìœ¼ë‚˜, ë¡œê·¸ë§Œ ì¶œë ¥
3. **Singleton patternì˜ ìˆœì„œ ì˜ì¡´ì„±**: Instanceê°€ ì—†ìœ¼ë©´ ìë™ ìƒì„±í•˜ì§€ë§Œ, DontDestroyOnLoadë¡œ ì—¬ëŸ¬ ì”¬ì—ì„œ ì¤‘ë³µ ê°€ëŠ¥ì„±
4. **Physics collision ì—ëŸ¬ ì²˜ë¦¬ ì—†ìŒ**: Colliderê°€ ì—†ìœ¼ë©´ ì¡°ìš©íˆ ì‹¤íŒ¨

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// Required Component Attribute + Validation
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(AnimationController))]
public class PlayerBehavior : MonoBehaviour
{
    void Awake()
    {
        if (!TryGetComponentInChildren(out StatsContainer container))
        {
            Debug.LogError($"[{gameObject.name}] StatsContainer not found! Disabling component.", this);
            enabled = false;
            return;
        }
        stats = container.stats;
        
        if (!TryGetComponentInChildren(out rb))
        {
            Debug.LogError($"[{gameObject.name}] Rigidbody2D not found!", this);
            enabled = false;
            return;
        }
        
        // ... ë‚˜ë¨¸ì§€ ì»´í¬ë„ŒíŠ¸ë„ ë™ì¼
    }
    
    private bool TryGetComponentInChildren<T>(out T component) where T : Component
    {
        component = GetComponentInChildren<T>();
        return component != null;
    }
}

// AttackSystemì—ì„œ ë” ì—„ê²©í•œ ê²€ì¦
public virtual bool ExecuteAttack(int attackIndex, Transform origin, LayerMask targetLayerMask)
{
    if (attackIndex < 0 || attackIndex >= attackContainer.Count)
    {
        Debug.LogError($"Invalid attack index: {attackIndex} (valid range: 0-{attackContainer.Count - 1})");
        return false;
    }
    
    if (origin == null)
    {
        Debug.LogError("Attack origin is null!");
        return false;
    }
    
    // ... ë‚˜ë¨¸ì§€ ë¡œì§
}

// Singleton ê°œì„ 
public abstract class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
    private static T _instance;
    private static readonly object _lock = new object();
    
    public static T Instance
    {
        get
        {
            if (_instance != null) return _instance;
            
            lock (_lock)
            {
                _instance = FindFirstObjectByType<T>();
                if (_instance != null) return _instance;
                
                Debug.LogWarning($"Singleton<{typeof(T).Name}> not found in scene. Creating new instance.");
                var obj = new GameObject($"[Singleton] {typeof(T).Name}");
                _instance = obj.AddComponent<T>();
                DontDestroyOnLoad(obj);
                return _instance;
            }
        }
    }
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

### âœ… í‰ê°€ (8/10)
- **ìºë¦­í„° í™•ì¥ì„±**: 9/10
  - ScriptableObject ê¸°ë°˜ `CharacterStats` - ë§¤ìš° ìš°ìˆ˜
  - ìƒì† êµ¬ì¡° (`AttackSystem`, `HealthSystem`) ëª…í™•
  - ìƒˆ ìºë¦­í„° ì¶”ê°€ ì‹œ ScriptableObject assetë§Œ ìƒì„±í•˜ë©´ ë¨
  
- **ìŠ¤í‚¬/ë¬´ê¸° í™•ì¥ì„±**: 8/10
  - `SkillData` ScriptableObject ë°°ì—´ ì‚¬ìš©
  - `AttackContainer` ë¦¬ìŠ¤íŠ¸ë¡œ ë‹¤ì¤‘ ê³µê²© ì§€ì›
  - `AttackType` enumìœ¼ë¡œ íƒ€ì… ë¶„ê¸°
  
- **í–‰ë™ í™•ì¥ì„±**: 8/10
  - BT êµ¬ì¡°ê°€ ìƒˆ í–‰ë™ ë…¸ë“œ ì¶”ê°€ì— ìš©ì´
  - FSM nested classëŠ” ì¬ì‚¬ìš© ì–´ë ¤ì›€
  
- **Hard-coded vs Data-driven**: 8/10
  - ëŒ€ë¶€ë¶„ì˜ íŒŒë¼ë¯¸í„°ê°€ ScriptableObject ë˜ëŠ” SerializeField
  - ì¼ë¶€ magic number ì—¬ì „íˆ ì¡´ì¬
  
- **Event-driven**: 8/10
  - UnityEvent ê¸°ë°˜ ì‹œìŠ¤í…œ - í™•ì¥ì„± ìš°ìˆ˜
  - Observer íŒ¨í„´ í™œìš©
  
- **DI ê°€ëŠ¥ì„±**: 4/10
  - DI íŒ¨í„´ ë¯¸ì‚¬ìš©
  - `FindFirstObjectByType` ì§ì ‘ í˜¸ì¶œ (ê²°í•©ë„ ë†’ìŒ)

### âŒ ë¬¸ì œì 
1. **FSM Stateê°€ nested class**: ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì¬ì‚¬ìš© ë¶ˆê°€
2. **AttackType enum í•˜ë“œì½”ë”©**: ìƒˆ íƒ€ì… ì¶”ê°€ ì‹œ switch ë¬¸ ìˆ˜ì • í•„ìš”
3. **DI íŒ¨í„´ ë¶€ì¬**: Singletonê³¼ FindObjectOfTypeìœ¼ë¡œ ì˜ì¡´ì„± í•´ê²°

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// Stateë¥¼ ë³„ë„ íŒŒì¼ë¡œ ë¶„ë¦¬í•˜ì—¬ ì¬ì‚¬ìš©ì„± ì¦ê°€
// States/PlayerMoveState.cs
public class PlayerMoveState : FSMNode
{
    private IMoveable entity;
    private IFlippable entity;
    
    public PlayerMoveState(IMoveable moveable, IFlippable flippable)
    {
        this.entity = moveable;
        this.flippable = flippable;
    }
    
    public override void OnEnter() { /* ... */ }
    public override void Update() { /* ... */ }
    public override void OnExit() { /* ... */ }
}

// Interface ê¸°ë°˜ ì„¤ê³„ë¡œ í™•ì¥ì„± ì¦ê°€
public interface IMoveable
{
    float MoveSpeed { get; }
    Rigidbody2D Rigidbody { get; }
    float MoveInput { get; }
}

public interface IFlippable
{
    Transform Transform { get; }
    void Flip();
}

// AttackTypeì„ Strategy íŒ¨í„´ìœ¼ë¡œ ë³€ê²½
public abstract class AttackStrategy
{
    public abstract void Execute(AttackContainer attack, Transform origin, LayerMask targetMask);
}

public class MeleeAttackStrategy : AttackStrategy
{
    public override void Execute(AttackContainer attack, Transform origin, LayerMask targetMask)
    {
        // Melee ë¡œì§
    }
}

public class ProjectileAttackStrategy : AttackStrategy
{
    public override void Execute(AttackContainer attack, Transform origin, LayerMask targetMask)
    {
        // Projectile ë¡œì§
    }
}

// AttackSystemì—ì„œ ì‚¬ìš©
public class AttackSystem : MonoBehaviour
{
    private Dictionary<AttackType, AttackStrategy> strategies;
    
    void Awake()
    {
        strategies = new Dictionary<AttackType, AttackStrategy>
        {
            { AttackType.Melee, new MeleeAttackStrategy() },
            { AttackType.Projectile, new ProjectileAttackStrategy() },
            { AttackType.Aoe, new AoeAttackStrategy() }
        };
    }
    
    public bool ExecuteAttack(int attackIndex, Transform origin, LayerMask targetMask)
    {
        var attack = attackContainer[attackIndex];
        strategies[attack.attackType].Execute(attack, origin, targetMask);
        // ...
    }
}

// ê°„ë‹¨í•œ Service Locator íŒ¨í„´ìœ¼ë¡œ DI ëŒ€ì²´
public class ServiceLocator
{
    private static Dictionary<Type, object> services = new Dictionary<Type, object>();
    
    public static void Register<T>(T service)
    {
        services[typeof(T)] = service;
    }
    
    public static T Get<T>()
    {
        if (services.TryGetValue(typeof(T), out var service))
            return (T)service;
        return default;
    }
}

// ì‚¬ìš©
public class HealthSystem : MonoBehaviour
{
    void Start()
    {
        apcRouter = ServiceLocator.Get<APCRouter>();
        if (apcRouter != null)
            apcRouter.EventShield.AddListener(ListenerActiveShield);
    }
}
```

---

## ğŸ“Œ 9. Clean Code Practices

### âœ… í‰ê°€ (7/10)
- **SOLID ì›ì¹™**:
  - **S (Single Responsibility)**: 6/10 - PlayerBehaviorê°€ ë„ˆë¬´ ë§ì€ ì±…ì„
  - **O (Open/Closed)**: 8/10 - ìƒì† êµ¬ì¡°ì™€ ScriptableObjectë¡œ í™•ì¥ ìš©ì´
  - **L (Liskov Substitution)**: 8/10 - ì¶”ìƒ í´ë˜ìŠ¤ ì‚¬ìš© ì ì ˆ
  - **I (Interface Segregation)**: 4/10 - Interface ê±°ì˜ ë¯¸ì‚¬ìš©
  - **D (Dependency Inversion)**: 4/10 - êµ¬ì²´ í´ë˜ìŠ¤ì— ì§ì ‘ ì˜ì¡´
  
- **DRY/KISS/YAGNI**: 7/10
  - ì¼ë¶€ ì¤‘ë³µ (FlipDirection, UpdateVelocity)
  - ëŒ€ì²´ë¡œ ë‹¨ìˆœí•˜ê³  ëª…í™•í•œ ì½”ë“œ
  - ê³¼ë„í•œ ì„¤ê³„ ì—†ìŒ (YAGNI ì¤€ìˆ˜)
  
- **public í•„ë“œ**: 9/10
  - ê±°ì˜ ëª¨ë“  í•„ë“œê°€ private/protected + SerializeField
  - public í•„ë“œ ìµœì†Œí™”
  
- **Property vs Field**: 7/10
  - ì¼ë¶€ property ì‚¬ìš© (`IsAlive`, `CurrentHealth`)
  - ëŒ€ë¶€ë¶„ì€ ì—¬ì „íˆ field ì‚¬ìš©
  
- **Namespace**: 0/10
  - **ì¹˜ëª…ì **: namespace ì „í˜€ ë¯¸ì‚¬ìš©
  - ëª¨ë“  í´ë˜ìŠ¤ê°€ global namespaceì— ì¡´ì¬
  
- **í´ë” êµ¬ì¡°**: 8/10
  - ê¸°ëŠ¥ë³„ í´ë” êµ¬ì¡° (Player, Enemy, Common, Core ë“±)
  - ScriptableObject ë³„ë„ í´ë”

### âŒ ë¬¸ì œì 
1. **Namespace ë¶€ì¬**: ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ì—ì„œ ì´ë¦„ ì¶©ëŒ ê°€ëŠ¥
2. **Interface ë¯¸ì‚¬ìš©**: í…ŒìŠ¤íŠ¸ ë° í™•ì¥ì„± ì €í•´
3. **ì¼ë¶€ ì¤‘ë³µ ì½”ë“œ**: FlipDirection, UpdateVelocity ë“±

### ğŸ’¡ ê°œì„ ì•ˆ
```csharp
// Namespace ë„ì…
namespace ProjectMagic.Player
{
    public class PlayerBehavior : MonoBehaviour { /* ... */ }
    public class PlayerAttack : AttackSystem { /* ... */ }
    public class PlayerHealth : HealthSystem { /* ... */ }
}

namespace ProjectMagic.Enemy
{
    public class EnemyBehavior : MonoBehaviour { /* ... */ }
    public class EnemyAttack : AttackSystem { /* ... */ }
}

namespace ProjectMagic.Core
{
    public abstract class FSMNode { /* ... */ }
    public interface BTNode { /* ... */ }
}

namespace ProjectMagic.Common
{
    public abstract class AttackSystem : MonoBehaviour { /* ... */ }
    public abstract class HealthSystem : MonoBehaviour { /* ... */ }
}

// Interface ë„ì…
namespace ProjectMagic.Core
{
    public interface IHealth
    {
        float MaxHealth { get; }
        float CurrentHealth { get; }
        bool IsAlive { get; }
        void TakeDamage(float damage, Vector2 knockback);
    }
    
    public interface IDamageable
    {
        void TakeDamage(float damage, Vector2 knockback);
    }
    
    public interface IAttacker
    {
        bool ExecuteAttack(int attackIndex, Transform origin, LayerMask targetMask);
    }
}

// êµ¬í˜„
namespace ProjectMagic.Common
{
    public abstract class HealthSystem : MonoBehaviour, IHealth, IDamageable
    {
        public float MaxHealth => stats.maxHealth;
        public float CurrentHealth => currentHealth;
        public bool IsAlive => currentHealth > 0;
        
        public virtual void TakeDamage(float damage, Vector2 knockback)
        {
            // ...
        }
    }
}

// Property í™œìš© ì¦ê°€
public class PlayerBehavior : MonoBehaviour
{
    // Fieldë¥¼ backing fieldë¡œ ë³€ê²½
    private float _moveInput;
    public float MoveInput
    {
        get => _moveInput;
        private set => _moveInput = value;
    }
    
    // Computed property
    public bool IsMoving => Mathf.Abs(_moveInput) > Mathf.Epsilon;
    public bool IsGrounded => colliderGround.IsTouchingLayers(layerGround.value);
}
```

---

## ğŸ“Œ 10. ì¢…í•© ì ìˆ˜ ë° ê°œì„  ìš°ì„ ìˆœìœ„

### ğŸ“Š í•­ëª©ë³„ ì ìˆ˜ (10ì  ë§Œì )

| í•­ëª© | ì ìˆ˜ | ì£¼ìš” í‰ê°€ |
|-----|------|---------|
| 1. Architecture & Unity Component Design | 7.5 | FSM/BT êµ¬ì¡° ìš°ìˆ˜, SRP ê°œì„  í•„ìš” |
| 2. Code Readability & Maintainability | 7.5 | ë„¤ì´ë° ì¼ê´€ì„± ì–‘í˜¸, XML ì£¼ì„ ë¶€ì¬ |
| 3. Performance & Memory Efficiency | 8.0 | í’€ë§ ì‹œìŠ¤í…œ ìš°ìˆ˜, GC-friendly |
| 4. Gameplay Logic & Stability | 7.0 | ì…ë ¥ ì²˜ë¦¬ ì•ˆì •ì , null ì²´í¬ ë¶€ì¡± |
| 5. Unity-Engine Best Practices | 8.5 | ì»´í¬ë„ŒíŠ¸ ìºì‹± ì™„ë²½, Tooltip ë¶€ì¬ |
| 6. Animation, FSM/BT, Event Flow | 8.0 | FSM ì„¤ê³„ ìš°ìˆ˜, BT ìµœì í™” ì—¬ì§€ |
| 7. Safety & Error Handling | 6.0 | ë°©ì–´ ì½”ë“œ ë¶€ì¡±, ì´ˆê¸°í™” ê²€ì¦ í•„ìš” |
| 8. Scalability / Extensibility | 8.0 | ScriptableObject ìš°ìˆ˜, DI ë¶€ì¬ |
| 9. Clean Code Practices | 7.0 | êµ¬ì¡° ì–‘í˜¸, Namespace ì „ë¬´ |
| 10. ì¢…í•© í‰ê°€ | **7.5/10** | **ì¤€ìˆ˜í•œ í’ˆì§ˆ, ì•ˆì •ì„± ê°œì„  í•„ìš”** |

---

### ğŸš¨ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (Critical)

1. **Namespace ë„ì…** ğŸ”´
   - **í˜„ì¬**: ëª¨ë“  í´ë˜ìŠ¤ê°€ global namespace
   - **ë¬¸ì œ**: ì´ë¦„ ì¶©ëŒ ìœ„í—˜, ëŒ€ê·œëª¨ í”„ë¡œì íŠ¸ í™•ì¥ ë¶ˆê°€
   - **ê°œì„ **: `ProjectMagic.Player`, `ProjectMagic.Enemy`, `ProjectMagic.Core` ë“± ë„ì…
   - **ìš°ì„ ìˆœìœ„**: ìµœê³  (ì „ì²´ ì½”ë“œë² ì´ìŠ¤ ì˜í–¥)

2. **í•„ìˆ˜ ì»´í¬ë„ŒíŠ¸ Null ì²´í¬** ğŸ”´
   - **í˜„ì¬**: `GetComponentInChildren<StatsContainer>().stats` ê²€ì¦ ì—†ìŒ
   - **ë¬¸ì œ**: ì»´í¬ë„ŒíŠ¸ ëˆ„ë½ ì‹œ NullReferenceExceptionìœ¼ë¡œ í¬ë˜ì‹œ
   - **ê°œì„ **: `TryGetComponent` + ì—ëŸ¬ ë¡œê¹… + `enabled = false`
   - **ìš°ì„ ìˆœìœ„**: ìµœê³  (ëŸ°íƒ€ì„ ì•ˆì •ì„±)

3. **XML ë¬¸ì„œí™” ì£¼ì„** ğŸŸ¡
   - **í˜„ì¬**: ì£¼ì„ì´ ê±°ì˜ ì—†ìŒ
   - **ë¬¸ì œ**: ì½”ë“œ ì´í•´ì™€ ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€, íŒ€ í˜‘ì—… ì €í•´
   - **ê°œì„ **: public/protected ë©¤ë²„ì— `///` ì£¼ì„ ì¶”ê°€
   - **ìš°ì„ ìˆœìœ„**: ë†’ìŒ (ìœ ì§€ë³´ìˆ˜ì„±)

---

### ğŸ”§ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ

1. **PlayerBehavior ì±…ì„ ë¶„ë¦¬** (2-3ì£¼)
   - `PlayerInputHandler`: ì…ë ¥ ì²˜ë¦¬ ì „ë‹´
   - `PlayerStateController`: FSM ê´€ë¦¬ ì „ë‹´
   - `PlayerMovement`: ë¬¼ë¦¬/ì´ë™ ë¡œì§ ì „ë‹´
   - í˜„ì¬ 420+ ë¼ì¸ì„ 3ê°œ í´ë˜ìŠ¤ë¡œ ë¶„í• 

2. **Interface ê¸°ë°˜ ì„¤ê³„ ë„ì…** (2-4ì£¼)
   - `IHealth`, `IDamageable`, `IAttacker` ì¸í„°í˜ì´ìŠ¤ ì •ì˜
   - í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ì¦ê°€, ì˜ì¡´ì„± ì—­ì „
   - Strategy íŒ¨í„´ìœ¼ë¡œ AttackType ì²˜ë¦¬ ë³€ê²½

3. **Service Locator ë˜ëŠ” DI Container ë„ì…** (1-2ì£¼)
   - `FindFirstObjectByType` ì˜ì¡´ì„± ì œê±°
   - Singleton íŒ¨í„´ ê°œì„ 
   - ìœ ë‹› í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± ì¦ê°€

---

### ğŸŒŸ ì˜í•œ ì  (Best Parts)

1. **Object Pooling ì‹œìŠ¤í…œ** â­â­â­
   - ì œë„¤ë¦­ `ObjectPool<T>` êµ¬í˜„ì´ ë§¤ìš° ìš°ìˆ˜
   - GC í• ë‹¹ ìµœì†Œí™”, ëŸ°íƒ€ì„ ì„±ëŠ¥ ìµœì í™”
   - ìë™ í™•ì¥ ê¸°ëŠ¥ìœ¼ë¡œ ìœ ì—°ì„± í™•ë³´
   - **ì°¸ê³  ê°€ì¹˜**: ë‹¤ë¥¸ í”„ë¡œì íŠ¸ì—ë„ ì ìš© ê°€ëŠ¥í•œ ì¬ì‚¬ìš© ì½”ë“œ

2. **X/Yì¶• ë…ë¦½ FSM (PlayerBehavior)** â­â­â­
   - ìˆ˜í‰/ìˆ˜ì§ ì´ë™ì„ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì„¤ê³„ê°€ íƒì›”
   - ì í”„í•˜ë©´ì„œ ì´ë™, ê³µê²©í•˜ë©´ì„œ ë‚™í•˜ ë“± ë³µì¡í•œ ìƒíƒœ ì¡°í•© ì²˜ë¦¬ ìš©ì´
   - ë²„í¼ íë¥¼ í†µí•œ ìƒíƒœ ì „í™˜ ì•ˆì •ì„± í™•ë³´
   - **ì°¸ê³  ê°€ì¹˜**: 2D ì•¡ì…˜ ê²Œì„ì˜ ëª¨ë²” ì‚¬ë¡€

3. **ScriptableObject ê¸°ë°˜ ë°ì´í„° ì„¤ê³„** â­â­â­
   - `CharacterStats`, `SkillData` ë“±ì´ ë°ì´í„°ì™€ ë¡œì§ ì™„ì „ ë¶„ë¦¬
   - ê²Œì„ ë°¸ëŸ°ìŠ¤ ì¡°ì •ì´ ì½”ë“œ ìˆ˜ì • ì—†ì´ ê°€ëŠ¥
   - ìƒˆ ìºë¦­í„°/ìŠ¤í‚¬ ì¶”ê°€ê°€ ë§¤ìš° ì‰¬ì›€
   - **ì°¸ê³  ê°€ì¹˜**: Unity í”„ë¡œì íŠ¸ì˜ í™•ì¥ì„± ëª¨ë²” ì‚¬ë¡€

---

### ğŸ“ ìµœì¢… ì´í‰

**ì „ë°˜ì ìœ¼ë¡œ ì¤€ìˆ˜í•œ í’ˆì§ˆì˜ Unity C# ì½”ë“œë² ì´ìŠ¤**ì…ë‹ˆë‹¤. íŠ¹íˆ ë‹¤ìŒ ë¶€ë¶„ì´ ì¸ìƒì ì…ë‹ˆë‹¤:

#### âœ… ê°•ì 
- **Performance-conscious**: Object pooling, component caching, GC-friendly ì½”ë“œ
- **Design patterns**: FSM, Behavior Tree, Observer (UnityEvent) ì ì ˆíˆ í™œìš©
- **Data-driven architecture**: ScriptableObject ê¸°ë°˜ ì„¤ê³„ë¡œ í™•ì¥ì„± í™•ë³´
- **Physics-based gameplay**: Rigidbody2D ì¤‘ì‹¬ ì„¤ê³„, FixedUpdate ë¶„ë¦¬ ì ì ˆ

#### âš ï¸ ê°œì„  í•„ìš”
- **ì•ˆì •ì„±**: Null ì²´í¬, ì—ëŸ¬ í•¸ë“¤ë§ ê°•í™” í•„ìˆ˜
- **ê°€ë…ì„±**: Namespace ë„ì…, XML ì£¼ì„ ì¶”ê°€ ì‹œê¸‰
- **í™•ì¥ì„±**: Interface ë° DI íŒ¨í„´ ë„ì…ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ìš©ì´ì„± ì¦ê°€ í•„ìš”
- **ìœ ì§€ë³´ìˆ˜ì„±**: PlayerBehavior ë“± ë¹„ëŒ€í•œ í´ë˜ìŠ¤ ë¶„í• 

#### ğŸ¯ ê¶Œì¥ ì‘ì—… ìˆœì„œ
1. **Week 1**: Namespace ë„ì… + Null ì²´í¬ ì¶”ê°€ (ì•ˆì •ì„± í™•ë³´)
2. **Week 2-3**: XML ì£¼ì„ ì‘ì„± (ìœ ì§€ë³´ìˆ˜ì„± ì¦ëŒ€)
3. **Week 4-6**: PlayerBehavior ë¦¬íŒ©í† ë§ (SRP ì¤€ìˆ˜)
4. **Week 7-8**: Interface ë„ì… + Service Locator (í™•ì¥ì„± ì¦ëŒ€)

í˜„ì¬ ìƒíƒœë¡œë„ **ì†Œê·œëª¨ í”„ë¡œì íŠ¸ëŠ” ì¶©ë¶„íˆ ì¶œì‹œ ê°€ëŠ¥**í•˜ë‚˜, íŒ€ í™•ì¥ ë° ì¥ê¸° ìœ ì§€ë³´ìˆ˜ë¥¼ ê³ ë ¤í•˜ë©´ ìœ„ ê°œì„ ì‚¬í•­ ì ìš©ì„ ê°•ë ¥íˆ ê¶Œì¥í•©ë‹ˆë‹¤.

---

**ì‘ì„±ì**: GitHub Copilot (Claude Sonnet 4.5)  
**í‰ê°€ ëŒ€ìƒ**: `Assets/Scripts/` (Player, Enemy, Common, Core, APC ë“±)  
**í‰ê°€ ê¸°ì¤€**: Unity C# Code Evaluation Prompt (10ê°œ ë¶€ë¬¸)
