# Unity C# Code Quality Evaluation Report
**í”„ë¡œì íŠ¸**: project-magic  
**í‰ê°€ì¼**: 2025-12-08 20:09  
**í‰ê°€ ë²”ìœ„**: Assets/Scripts í´ë” í•µì‹¬ ë¡œì§

---

## ğŸ“Œ 1. Architecture & Unity Component Design

### í‰ê°€
- **SRP(Single Responsibility) ì¤€ìˆ˜**: â­â­â­â­â˜† (4/5)
  - `HealthSystem`, `AttackSystem`, `SkillLogic` ë“± ê° ì‹œìŠ¤í…œì´ ëª…í™•íˆ ë¶„ë¦¬ë¨
  - `PlayerBehavior`, `EnemyBehavior`ëŠ” ë‹¤ì†Œ ë¹„ëŒ€í•˜ì§€ë§Œ FSM/BT íŒ¨í„´ìœ¼ë¡œ êµ¬ì¡°í™” ì‹œë„
  
- **Unity ìƒëª…ì£¼ê¸° í™œìš©**: â­â­â­â­â˜† (4/5)
  - `Awake`ì—ì„œ ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”, `Start`ì—ì„œ ì´ë²¤íŠ¸ ë“±ë¡, `FixedUpdate`ì—ì„œ ë¬¼ë¦¬ ë¡œì§ ë“± ì ì ˆíˆ ë¶„ë¦¬
  - `TickUpdate()` íŒ¨í„´ìœ¼ë¡œ deltaTime ê¸°ë°˜ íƒ€ì´ë¨¸ ì²˜ë¦¬ë¥¼ ë³„ë„ ë©”ì„œë“œë¡œ ë¶„ë¦¬ (Good!)

- **Composition vs. Inheritance**: â­â­â­â­â­ (5/5)
  - `HealthSystem`, `AttackSystem`ì„ abstract baseë¡œ êµ¬ì„±í•˜ê³  Player/Enemyê°€ ìƒì†ë°›ëŠ” êµ¬ì¡°
  - `FSMNode`, `BTNode` ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ composition íŒ¨í„´ ìš°ìˆ˜
  - ScriptableObject(`CharacterStats`, `SkillData`)ë¥¼ í†µí•œ ë°ì´í„° ê¸°ë°˜ ì„¤ê³„ íƒì›”

### ë¬¸ì œì 
1. **PlayerBehaviorê°€ 420ì¤„ë¡œ ê³¼ë„í•˜ê²Œ í¼**: ë‚´ë¶€ì— 7ê°œì˜ FSM State í´ë˜ìŠ¤ë¥¼ nested classë¡œ êµ¬í˜„í•˜ì—¬ ë‹¨ì¼ íŒŒì¼ì´ ë¹„ëŒ€í•¨
2. **EnemyBehaviorë„ 473ì¤„ë¡œ ê±°ëŒ€**: BT Action í´ë˜ìŠ¤ë“¤ì„ ëª¨ë‘ nested classë¡œ í¬í•¨
3. **AttackSystemì˜ ì±…ì„ ê³¼ë‹¤**: ê³µê²© ì‹¤í–‰, ì˜¤ë¸Œì íŠ¸ í’€ ê´€ë¦¬, íˆíŠ¸ ê²€ì¶œ ë“± ì—¬ëŸ¬ ì—­í•  í˜¼ì¬

### ê°œì„ ì•ˆ
```csharp
// í˜„ì¬: PlayerBehavior.cs ë‚´ë¶€ì— ëª¨ë“  Stateê°€ nested classë¡œ ì¡´ì¬
class StateMove : FSMNode { ... }
class StateIdle : FSMNode { ... }

// ê°œì„ : ê° Stateë¥¼ ë³„ë„ íŒŒì¼ë¡œ ë¶„ë¦¬
// Assets/Scripts/Player/States/StateMove.cs
public class PlayerStateMove : FSMNode 
{
    private readonly PlayerBehavior ctx;
    public PlayerStateMove(PlayerBehavior ctx) => this.ctx = ctx;
    // ...
}
```

**ScriptableObject ê¸°ë°˜ í™•ì¥ì„±**: Event-driven êµ¬ì¡° ë¶€ë¶„ì ìœ¼ë¡œ í™œìš© ì¤‘ì´ë‚˜, Command íŒ¨í„´ì´ë‚˜ Strategy íŒ¨í„´ ë„ì… ì‹œ ë”ìš± ìœ ì—°í•œ í™•ì¥ ê°€ëŠ¥

---

## ğŸ“Œ 2. Code Readability & Maintainability

### í‰ê°€
- **ë„¤ì´ë° ê·œì¹™ ì¼ê´€ì„±**: â­â­â­â­â˜† (4/5)
  - ì¼ë°˜ì ìœ¼ë¡œ camelCase(í•„ë“œ), PascalCase(ë©”ì„œë“œ/í´ë˜ìŠ¤) ì¤€ìˆ˜
  - private í•„ë“œ underscore prefix(`_moveInput`, `_hitForce`) ì¼ê´€ì„± ìˆìŒ
  - BUT: ì¼ë¶€ protected í•„ë“œê°€ underscore ì—†ì´ ì‚¬ìš©ë¨ (`stats`, `rb`, `animController`)

- **ì˜ë¯¸ ì „ë‹¬ë ¥**: â­â­â­â­â˜† (4/5)
  - ëŒ€ë¶€ë¶„ì˜ ë³€ìˆ˜/ë©”ì„œë“œ ì´ë¦„ì´ ëª…í™• (`ExecuteAttack`, `CalculateKnockback`, `CheckGrounded`)
  - BUT: `YPosAdjust`, `hitAreaRadius` ê°™ì€ magic number ì„±ê²© ë³€ìˆ˜ëŠ” ì„¤ëª… ë¶€ì¡±

- **ì£¼ì„/XML ë¬¸ì„œí™”**: â­â­â˜†â˜†â˜† (2/5)
  - **ì¹˜ëª…ì  ë¬¸ì œ**: XML ì£¼ì„ì´ ì „í˜€ ì—†ìŒ
  - ì¼ë¶€ ì¸ë¼ì¸ ì£¼ì„ë§Œ ì¡´ì¬ (`// for UI`, `// attack type routing`)
  - public APIì— ëŒ€í•œ ì„¤ëª…ì´ ì „ë¬´í•˜ì—¬ íƒ€ ê°œë°œì í˜‘ì—… ì‹œ ì´í•´ ë‚œì´ë„ ë†’ìŒ

- **ì¤‘ë³µ ì œê±°**: â­â­â­â˜†â˜† (3/5)
  - `CalculateKnockback` ë¡œì§ì´ `AttackSystem`ê³¼ `SkillLogic`ì— ì¤‘ë³µ ì¡´ì¬
  - `FlipDirection()` ë¡œì§ì´ `StateMove`(Player)ì™€ ì—¬ëŸ¬ Enemy Actionì— ë°˜ë³µ
  - `AttackSystem_old.cs` ê°™ì€ ë ˆê±°ì‹œ íŒŒì¼ì´ ë°©ì¹˜ë¨

### ë¬¸ì œì 
1. **XML ë¬¸ì„œí™” ì „ë¬´**: public ë©”ì„œë“œ/í”„ë¡œí¼í‹°ì— ëŒ€í•œ ì„¤ëª… ì—†ìŒ
2. **í•˜ë“œì½”ë”©ëœ Magic Number**: `Mathf.Epsilon`, `0.2f`(CircleCast radius) ë“±
3. **ì£¼ì„ ë¶€ì¡±**: ë³µì¡í•œ FSM/BT ë¡œì§ ì „í™˜ ì¡°ê±´ì— ì„¤ëª… ì—†ìŒ

### ê°œì„ ì•ˆ
```csharp
// Before
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)

// After
/// <summary>
/// ìºë¦­í„°ì—ê²Œ ë°ë¯¸ì§€ë¥¼ ì ìš©í•˜ê³  ë„‰ë°± íš¨ê³¼ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
/// ë¬´ì  ìƒíƒœì´ê±°ë‚˜ ì´ë¯¸ ì‚¬ë§í•œ ê²½ìš° ë¬´ì‹œë©ë‹ˆë‹¤.
/// </summary>
/// <param name="rawDamage">ë°©ì–´ë ¥ ì ìš© ì „ ì›ë³¸ ë°ë¯¸ì§€</param>
/// <param name="knockbackDirection">ë„‰ë°± ë°©í–¥ ë° í˜ (ê¸°ë³¸ê°’: Vector2.zero)</param>
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
```

```csharp
// Magic number ì œê±°
private const float PLAYER_DETECTION_RADIUS = 0.2f;
RaycastHit2D hitArea = Physics2D.CircleCast(origin, PLAYER_DETECTION_RADIUS, ...);
```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

### í‰ê°€
- **Update/FixedUpdate ìµœì í™”**: â­â­â­â­â˜† (4/5)
  - `FixedUpdate`ì—ì„œ ë¬¼ë¦¬ ê¸°ë°˜ ìƒíƒœ ì—…ë°ì´íŠ¸, `Update`ì—ì„œ íƒ€ì´ë¨¸ ê°ì†Œ - ì ì ˆí•œ ë¶„ë¦¬
  - `TickUpdate()` íŒ¨í„´ìœ¼ë¡œ timer ì—…ë°ì´íŠ¸ë¥¼ í†µí•© ê´€ë¦¬ (Good!)
  - BUT: `EnemyBehavior.FixedUpdate`ì—ì„œ ë§¤ í”„ë ˆì„ BT í‰ê°€ëŠ” ë¹„ìš©ì´ ë†’ì„ ìˆ˜ ìˆìŒ

- **GC ë°œìƒ ìš”ì†Œ**: â­â­â­â˜†â˜† (3/5)
  - **ì¢‹ì€ ì **: ObjectPool í™œìš©ìœ¼ë¡œ Skill/Projectile ì¬ì‚¬ìš©
  - **ë‚˜ìœ ì **: 
    - `Logger.Write`ì—ì„œ ë§¤ë²ˆ `StackTrace` ìƒì„± (ì‹¬ê°í•œ GC ë¶€ë‹´!)
    - BT Evaluate ì‹œ `new EvaluateResult(...)` ë§¤ í”„ë ˆì„ ìƒì„±
    - ë¬¸ìì—´ ë³´ê°„(`$"{action}/{role}"`) ë‚¨ë°œ

- **ê°ì²´ ì¬ì‚¬ìš©**: â­â­â­â­â˜† (4/5)
  - `ObjectPool<T>` ì œë„¤ë¦­ êµ¬í˜„ ìš°ìˆ˜
  - ìŠ¤í‚¬ í”„ë¦¬íŒ¹ ì¬ì‚¬ìš© êµ¬ì¡° ì™„ë¹„
  - BUT: Poolì´ ë¹„ì—ˆì„ ë•Œ ë¬´ì œí•œ ìƒì„±ë˜ëŠ” êµ¬ì¡° (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥ì„±)

- **Physics ìµœì í™”**: â­â­â­â­â˜† (4/5)
  - `LayerMask` í™œìš©ìœ¼ë¡œ ì¶©ëŒ ê²€ì‚¬ ëŒ€ìƒ ì œí•œ
  - `BoxCollider2D.IsTouchingLayers` í™œìš© ì ì ˆ
  - BUT: Enemyê°€ ë§¤ í”„ë ˆì„ CircleCast/OverlapBox ìˆ˜í–‰ - ìºì‹± í•„ìš”

### ë¬¸ì œì 
1. **Loggerì˜ StackTraceê°€ ì¹˜ëª…ì **: DEBUG ëª¨ë“œì—ì„œ ë§¤ ë¡œê·¸ë§ˆë‹¤ StackTrace ìƒì„±ì€ ì—„ì²­ë‚œ ì„±ëŠ¥ ì €í•˜
   ```csharp
   // Logger.cs - ë§¤ í˜¸ì¶œë§ˆë‹¤ StackTrace ìƒì„±!
   StackTrace trace = new StackTrace();
   StackFrame caller = trace.GetFrame(1);
   ```

2. **BT/FSM í‰ê°€ ì‹œ struct ë¯¸í™œìš©**: `EvaluateResult`ê°€ classì¼ ê²½ìš° ë§¤ í”„ë ˆì„ í™ í• ë‹¹

3. **ë¬¸ìì—´ ì—°ì‚° ê³¼ë‹¤**: 
   ```csharp
   Logger.Write($"ActionDeath execute / object={ctx.gameObject.name}");
   // DEBUG=falseì¼ ë•Œë„ ë¬¸ìì—´ ë³´ê°„ ì‹¤í–‰ë¨
   ```

### ê°œì„ ì•ˆ
```csharp
// Logger ìµœì í™”
public static void Write(string log="No Message", string level="INFO")
{
    if (!DEBUG) return;  // ì¡°ê¸° ë°˜í™˜
    
    #if UNITY_EDITOR
    StackTrace trace = new StackTrace();
    StackFrame caller = trace.GetFrame(1);
    var method = caller.GetMethod();
    UnityEngine.Debug.Log($"{level} / {method.DeclaringType.Name}.{method.Name} / {log}");
    #else
    UnityEngine.Debug.Log($"{level} / {log}");
    #endif
}
```

```csharp
// EvaluateResultë¥¼ structë¡œ ë³€ê²½
public struct EvaluateResult  // class â†’ struct
{
    public BTNode.State state;
    public string actionRole;
    
    public EvaluateResult(BTNode.State state, string actionRole)
    {
        this.state = state;
        this.actionRole = actionRole;
    }
}
```

```csharp
// Enemyì˜ Physics ì¿¼ë¦¬ ìºì‹±
private RaycastHit2D _cachedPlayerDetection;
private float _detectionCacheTimer;
private const float DETECTION_CACHE_INTERVAL = 0.2f;

// ë§¤ í”„ë ˆì„ì´ ì•„ë‹Œ 0.2ì´ˆë§ˆë‹¤ë§Œ raycast ìˆ˜í–‰
```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

### í‰ê°€
- **ì…ë ¥ ì²˜ë¦¬ ì•ˆì •ì„±**: â­â­â­â­â­ (5/5)
  - **ë§¤ìš° ìš°ìˆ˜**: Input Snapshot íŒ¨í„´ êµ¬í˜„ (`_snapShotMoveInput`, `_snapShotjumpInput`)
  - `FixedUpdate`ì—ì„œ ì…ë ¥ ìŠ¤ëƒ…ìƒ·ì„ ì €ì¥í•˜ê³  ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ - í›Œë¥­í•œ ë™ê¸°í™” ì „ëµ
  - `OnJump`ì—ì„œ InFlight ì¤‘ ì¤‘ë³µ ì í”„ ë°©ì§€

- **ìƒíƒœ ì „ì´ ì•ˆì •ì„±**: â­â­â­â­â˜† (4/5)
  - FSM: Queue ê¸°ë°˜ ë²„í¼(`bufferXState`, `bufferYState`)ë¡œ ìƒíƒœ ì „í™˜ ìˆœì„œ ë³´ì¥
  - BT: Selector/Sequence íŒ¨í„´ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ í–‰ë™ ì„ íƒ
  - BUT: BTì—ì„œ Running ìƒíƒœ ì²˜ë¦¬ê°€ ë¶ˆëª…í™• (ActionChaseê°€ Running ë°˜í™˜ í›„ ë‹¤ìŒ í”„ë ˆì„ ë™ì‘ ë¶ˆí™•ì‹¤)

- **ë™ì‹œì„± ë¬¸ì œ ë°©ì–´**: â­â­â­â­â˜† (4/5)
  - `_hitRecoveryTimer`, `_attackRecoveryTimer`ë¡œ ì¿¨ë‹¤ìš´ ê´€ë¦¬ ìš°ìˆ˜
  - ë¬´ì  ì‹œê°„(`invincibleTimer`) ì²˜ë¦¬ ì ì ˆ
  - BUT: `_jumpInput` í”Œë˜ê·¸ê°€ ì—¬ëŸ¬ ê³³ì—ì„œ ìˆ˜ì •ë˜ì–´ race condition ê°€ëŠ¥ì„± ì¡´ì¬

- **null/exception ë°©ì–´**: â­â­â­â˜†â˜† (3/5)
  - ì¼ë¶€ `TryGetComponent` í™œìš© (Good!)
  - BUT: `healthSystem.IsAlive` ì²´í¬ ì „ì— null ì²´í¬ ëˆ„ë½ëœ ê³³ ë‹¤ìˆ˜
  - `attackContainer[attackIndex]` ì ‘ê·¼ ì „ ë²”ìœ„ ê²€ì¦ì€ ìˆì§€ë§Œ ì˜ˆì™¸ ì²˜ë¦¬ ì—†ìŒ

### ë¬¸ì œì 
1. **ì í”„ ì…ë ¥ ì²˜ë¦¬ì˜ ì ì¬ì  ë²„ê·¸**:
   ```csharp
   // StateInFlight.OnEnter()ì—ì„œ _jumpInputì„ falseë¡œ ì„¤ì •
   ctx._jumpInput = false;
   
   // í•˜ì§€ë§Œ OnJump()ëŠ” ì–¸ì œë“  trueë¡œ ì„¤ì • ê°€ëŠ¥
   // â†’ íƒ€ì´ë° ì´ìŠˆ ë°œìƒ ê°€ëŠ¥
   ```

2. **Enemyì˜ _target null ì²´í¬ ëˆ„ë½**:
   ```csharp
   // ActionChaseì—ì„œ _targetì´ íŒŒê´´ëœ ê²½ìš° NullReferenceException ê°€ëŠ¥
   var direction = Mathf.Sign(ctx._target.position.x - ctx.transform.position.x);
   ```

3. **AttackSystemì˜ poolContainer null ì ‘ê·¼**:
   ```csharp
   // ExecuteAttackì—ì„œ poolContainer[attackIndex]ê°€ ì—†ì„ ê²½ìš° KeyNotFoundException
   ExecuteCustomAttack(..., poolContainer[attackIndex]);
   ```

### ê°œì„ ì•ˆ
```csharp
// PlayerBehavior - ì…ë ¥ ì²˜ë¦¬ ê°œì„ 
private bool _jumpRequested;
public void OnJump(InputValue value)
{
    if (value.isPressed && currentYState != PlayerState.InFlight)
        _jumpRequested = true;
}

void FixedUpdate()
{
    _snapShotjumpInput = _jumpRequested ? 1.0f : 0.0f;
    _jumpRequested = false;  // ë§¤ í”„ë ˆì„ ë¦¬ì…‹
    // ...
}
```

```csharp
// EnemyBehavior - null ì•ˆì „ì„± ê°•í™”
class ActionChase : ActionNode
{
    public override EvaluateResult Evaluate()
    {
        if (ctx._target == null || !ctx._target.gameObject.activeInHierarchy) 
            return new EvaluateResult(BTNode.State.Failure, this.GetType().ToString());
        // ...
    }
}
```

```csharp
// AttackSystem - Dictionary ì•ˆì „ ì ‘ê·¼
if (!poolContainer.ContainsKey(attackIndex))
{
    Logger.Write($"Pool not found for attack index: {attackIndex}", "ERROR");
    return false;
}
ExecuteCustomAttack(..., poolContainer[attackIndex]);
```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

### í‰ê°€
- **GetComponent ìºì‹±**: â­â­â­â­â­ (5/5)
  - ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë¥¼ `Awake`ì—ì„œ ìºì‹± (`rb`, `animController`, `healthSystem` ë“±)
  - ëŸ°íƒ€ì„ GetComponent í˜¸ì¶œ ì „ë¬´ - ì™„ë²½í•œ ìµœì í™”

- **Unity ê°ì²´ ì ‘ê·¼**: â­â­â­â­â˜† (4/5)
  - Rigidbody2D, Animator, Collider ëª¨ë‘ ìºì‹±ë¨
  - BUT: `transform.localScale`ì„ ë§¤ í”„ë ˆì„ ìˆ˜ì • ì‹œ `Vector3` ì„ì‹œ ë³€ìˆ˜ í• ë‹¹ ë°œìƒ

- **Time.deltaTime ë³´ì •**: â­â­â­â­â­ (5/5)
  - ëª¨ë“  íƒ€ì´ë¨¸ ê°ì†Œì— `Time.deltaTime` ì ìš©
  - ì†ë„ ê³„ì‚°ì— ì¼ê´€ë˜ê²Œ ì ìš© (`velocity.x = _snapShotMoveInput * stats.moveSpeed`)

- **Physics/Transform ì¶©ëŒ**: â­â­â­â­â˜† (4/5)
  - `rb.linearVelocity`ë¡œ ì†ë„ ì œì–´, `rb.AddForce`ë¡œ ë„‰ë°± ì ìš© - ì ì ˆ
  - BUT: `transform.localScale`ì„ í†µí•œ Flip ì²˜ë¦¬ê°€ physicsì™€ í˜¼ì¬ (ê¶Œì¥: SpriteRenderer.flipX ì‚¬ìš©)

- **SerializeField í™œìš©**: â­â­â­â­â˜† (4/5)
  - ëŒ€ë¶€ë¶„ì˜ ì„¤ì •ê°’ì´ `[SerializeField]`ë¡œ ë…¸ì¶œ
  - `[Header]` ì‚¬ìš©ìœ¼ë¡œ ì¸ìŠ¤í™í„° ê°€ë…ì„± í–¥ìƒ
  - BUT: `[Tooltip]` í™œìš© ì „ë¬´ - ë””ìì´ë„ˆ/ê¸°íšìë¥¼ ìœ„í•œ ì„¤ëª… ë¶€ì¡±

- **Magic Number ì œê±°**: â­â­â˜†â˜†â˜† (2/5)
  - ë§ì€ ìƒìˆ˜ê°€ í•˜ë“œì½”ë”©: `0.2f`, `1f`, `Mathf.Epsilon + landingVelocityMargin`
  - ì¼ë¶€ëŠ” SerializeFieldë¡œ ë…¸ì¶œë˜ë‚˜ ì˜ë¯¸ ì „ë‹¬ ë¶ˆëª…í™•

### ë¬¸ì œì 
1. **Tooltip ë¶€ì¬**: 
   ```csharp
   [SerializeField] float landingVelocityMargin;  
   // ì´ê²Œ ë­”ì§€ ë””ìì´ë„ˆê°€ ì•Œ ìˆ˜ ì—†ìŒ
   ```

2. **Transform.localScale ë‚¨ìš©**:
   ```csharp
   // í˜„ì¬: ìºë¦­í„° ë°©í–¥ ì „í™˜
   scale.x = ctx._snapShotMoveInput < 0 ? Mathf.Abs(scale.x) : -Mathf.Abs(scale.x);
   ctx.transform.localScale = scale;
   // â†’ ë§¤ë²ˆ Vector3 ì„ì‹œ í• ë‹¹
   ```

3. **Legacy íŒŒì¼ ë°©ì¹˜**: `AttackSystem_old.cs` ê°™ì€ ë¯¸ì‚¬ìš© íŒŒì¼ ì¡´ì¬

### ê°œì„ ì•ˆ
```csharp
[Header("Ground Detection")]
[SerializeField] 
[Tooltip("ì°©ì§€ íŒì • ì‹œ velocity.y í—ˆìš© ì˜¤ì°¨ (í´ìˆ˜ë¡ ë¹ ë¥¸ ì°©ì§€ ê°ì§€)")]
float landingVelocityMargin = 0.1f;

[SerializeField]
[Tooltip("Ground ë ˆì´ì–´ ì²´í¬ìš© ì½œë¼ì´ë”")]
BoxCollider2D colliderGround;
```

```csharp
// SpriteRenderer ì‚¬ìš© ê¶Œì¥
private SpriteRenderer spriteRenderer;

void Awake()
{
    spriteRenderer = GetComponentInChildren<SpriteRenderer>();
}

// Flip ì²˜ë¦¬
spriteRenderer.flipX = _snapShotMoveInput < 0;
```

```csharp
// Constants í´ë˜ìŠ¤ í™œìš©
public static class GameplayConstants
{
    public const float PLAYER_DETECTION_RADIUS = 0.2f;
    public const float KNOCKBACK_Y_FACTOR = 1f;
    public const float MIN_VELOCITY_THRESHOLD = 0.001f;
}
```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

### í‰ê°€
- **Animator Sync**: â­â­â­â˜†â˜† (3/5)
  - `AnimationController.PlayStateAnimation()`ìœ¼ë¡œ ìƒíƒœ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
  - ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ë¥¼ ë°˜í™˜í•˜ì—¬ recovery timer ì„¤ì • - ì¢‹ì€ ì•„ì´ë””ì–´
  - BUT: `rebind: true` íŒŒë¼ë¯¸í„°ì˜ ì˜ë¯¸ê°€ ë¶ˆëª…í™•, ì• ë‹ˆë©”ì´ì…˜ ì´ë²¤íŠ¸ ë™ê¸°í™” ì—¬ë¶€ ë¶ˆí™•ì‹¤

- **Attack ì¤‘ ì›€ì§ì„ ì œì–´**: â­â­â­â­â˜† (4/5)
  - `_attackRecoveryTimer`ë¡œ ê³µê²© ì¤‘ ë‹¤ë¥¸ í–‰ë™ ì°¨ë‹¨ (Good!)
  - StateAttackì—ì„œ ë³„ë„ ë¡œì§ ì—†ì´ íƒ€ì´ë¨¸ë¡œ ê´€ë¦¬ - ê¹”ë”
  - BUT: ê³µê²© ì¤‘ ì´ë™ ì…ë ¥ ë¬´ì‹œ ì—¬ë¶€ê°€ ëª…ì‹œì ì´ì§€ ì•ŠìŒ (StateAttack.Update() ë¹„ì–´ìˆìŒ)

- **FSM/BT Transition êµ¬ì¡°**: â­â­â­â­â˜† (4/5)
  - FSM: X/Y ì¶• ë¶„ë¦¬ ìƒíƒœ ê´€ë¦¬ - ë…ì°½ì ì´ê³  ìœ ì—°í•¨
  - BT: Priority-based Selector êµ¬ì¡°ë¡œ ëª…í™•í•œ ìš°ì„ ìˆœìœ„
  - BUT: BTì˜ Running ìƒíƒœ í›„ì† ì²˜ë¦¬ ë¡œì§ ë¶ˆëª…í™•

- **Animation Event ì‚¬ìš©**: â­â­â­â˜†â˜† (3/5)
  - ì½”ë“œì—ì„œ Animation Event ì‚¬ìš© í”ì  ì—†ìŒ
  - AttackSystemì´ `EventAttack` UnityEventë¥¼ ë°œí–‰í•˜ì—¬ ê²°í•©ë„ ë‚®ì¶¤ (Good!)
  - BUT: ì‹¤ì œ ê³µê²© íˆíŠ¸ë°•ìŠ¤ í™œì„±í™”ë¥¼ ì• ë‹ˆë©”ì´ì…˜ ì´ë²¤íŠ¸ë¡œ ì²˜ë¦¬í•˜ëŠ”ì§€ ë¶ˆëª…í™•

### ë¬¸ì œì 
1. **AnimationControllerì˜ rebind ì˜ë¯¸ ë¶ˆëª…í™•**:
   ```csharp
   ctx.animController.PlayStateAnimation(PlayerState.DAMAGED, rebind: true);
   // rebindê°€ ì •í™•íˆ ë¬´ì—‡ì„ í•˜ëŠ”ì§€ ì£¼ì„/ë¬¸ì„œ ì—†ìŒ
   ```

2. **ê³µê²© ì¤‘ ì´ë™ ì œí•œ ë¶ˆëª…í™•**:
   ```csharp
   class StateAttack : FSMNode
   {
       public override void Update() { }  // ë¹„ì–´ìˆìŒ
       // ê³µê²© ì¤‘ ì´ë™ ì…ë ¥ì´ ë“¤ì–´ì˜¤ë©´ ì–´ë–»ê²Œ ë˜ëŠ”ê°€?
   }
   ```

3. **BT Running ìƒíƒœì˜ ëª¨í˜¸í•¨**:
   ```csharp
   // ActionChaseì—ì„œ Running ë°˜í™˜
   return new EvaluateResult(BTNode.State.Running, this.GetType().ToString());
   // ë‹¤ìŒ í”„ë ˆì„ì— ë‹¤ì‹œ ì´ ë…¸ë“œë¶€í„° ì‹œì‘? ì•„ë‹ˆë©´ ë£¨íŠ¸ë¶€í„°?
   ```

### ê°œì„ ì•ˆ
```csharp
// AnimationControllerì— XML ì£¼ì„ ì¶”ê°€
/// <summary>
/// ìƒíƒœì— ë§ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ ì¬ìƒí•©ë‹ˆë‹¤.
/// </summary>
/// <param name="state">ì¬ìƒí•  ìƒíƒœ</param>
/// <param name="rebind">trueì¼ ê²½ìš° Animatorë¥¼ ë¦¬ë°”ì¸ë”©í•˜ì—¬ ì• ë‹ˆë©”ì´ì…˜ì„ ì²˜ìŒë¶€í„° ì¬ìƒ</param>
/// <returns>ì• ë‹ˆë©”ì´ì…˜ í´ë¦½ì˜ ê¸¸ì´(ì´ˆ)</returns>
public float PlayStateAnimation(PlayerState state, bool rebind = false)
```

```csharp
// StateAttackì—ì„œ ì´ë™ ì°¨ë‹¨ ëª…ì‹œ
class StateAttack : FSMNode
{
    public override void Update()
    {
        // ê³µê²© ì¤‘ì—ëŠ” velocity.xë¥¼ 0ìœ¼ë¡œ ê³ ì •í•˜ì—¬ ì´ë™ ì°¨ë‹¨
        if (ctx._attackRecoveryTimer > 0)
        {
            Vector2 vel = ctx.rb.linearVelocity;
            vel.x = 0;
            ctx.rb.linearVelocity = vel;
        }
    }
}
```

```csharp
// BT Running ìƒíƒœ ì²˜ë¦¬ ëª…í™•í™” - Sequenceì— ì €ì¥
public class SequenceNode : BTNode
{
    private int currentIndex = 0;  // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ Action ì¸ë±ìŠ¤
    
    public EvaluateResult Evaluate()
    {
        for (int i = currentIndex; i < children.Count; i++)
        {
            var (state, role) = children[i].Evaluate();
            if (state == BTNode.State.Running)
            {
                currentIndex = i;  // ë‹¤ìŒ í”„ë ˆì„ì— ì—¬ê¸°ì„œ ì¬ê°œ
                return new EvaluateResult(state, role);
            }
            // Successë©´ ë‹¤ìŒ Actionìœ¼ë¡œ
            if (state == BTNode.State.Failure)
            {
                currentIndex = 0;
                return new EvaluateResult(state, role);
            }
        }
        currentIndex = 0;
        return new EvaluateResult(BTNode.State.Success, action);
    }
}
```

---

## ğŸ“Œ 7. Safety & Error Handling

### í‰ê°€
- **Null ë°©ì–´ ì½”ë“œ**: â­â­â­â˜†â˜† (3/5)
  - `healthSystem?.IsAlive` ê°™ì€ null ì¡°ê±´ ì—°ì‚°ì ì‚¬ìš©
  - `TryGetComponent` ì¼ë¶€ í™œìš©
  - BUT: ë§ì€ ê³³ì—ì„œ ì§ì ‘ ì ‘ê·¼ (`ctx._target.position`)

- **TryGetComponent í™œìš©**: â­â­â˜†â˜†â˜† (2/5)
  - `ExecuteMeleeAttack`ì—ì„œë§Œ ì‚¬ìš©
  - ëŒ€ë¶€ë¶„ `GetComponent`ë¡œ ì§ì ‘ íšë“ í›„ null ì²´í¬ ì—†ì´ ì‚¬ìš©

- **Input ë¹„ë™ê¸° ì²˜ë¦¬**: â­â­â­â­â­ (5/5)
  - Input Snapshot íŒ¨í„´ìœ¼ë¡œ ì™„ë²½íˆ í•´ê²°
  - `FixedUpdate`ì—ì„œ ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ì™€ ë™ê¸°í™” (ìµœìƒê¸‰!)

- **Boundary ì²´í¬**: â­â­â­â˜†â˜† (3/5)
  - `CheckGrounded()` ë©”ì„œë“œë¡œ ì§€ë©´ ì²´í¬
  - Enemyì˜ patrol ë²”ìœ„ ì²´í¬
  - BUT: ë§µ ê²½ê³„ ì´íƒˆ ë°©ì§€ ë¡œì§ ì—†ìŒ (ë‚™í•˜ ì‹œ ë¬´í•œ ì¶”ë½ ê°€ëŠ¥)

- **Initialize ìˆœì„œ ë¬¸ì œ**: â­â­â­â­â˜† (4/5)
  - `Awake`ì—ì„œ ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”, `Start`ì—ì„œ ì´ë²¤íŠ¸ ë“±ë¡ - ìˆœì„œ ëª…í™•
  - BUT: `FindFirstObjectByType<APCRouter>`ë¥¼ Startì—ì„œ í˜¸ì¶œ - ì”¬ì— ì—†ìœ¼ë©´ null

### ë¬¸ì œì 
1. **Target null ê²€ì¦ ë¶€ì¡±**:
   ```csharp
   // Enemyê°€ Playerë¥¼ ì¶”ì  ì¤‘ Playerê°€ ì‚¬ë§/ì‚­ì œë˜ë©´?
   var direction = Mathf.Sign(ctx._target.position.x - ctx.transform.position.x);
   // NullReferenceException ë°œìƒ
   ```

2. **APCRouter ì˜ì¡´ì„±**:
   ```csharp
   apcRouter = FindFirstObjectByType<APCRouter>();
   apcRouter.EventShield.AddListener(...);  // apcRouterê°€ nullì´ë©´ í¬ë˜ì‹œ
   ```

3. **ë°°ì—´ ë²”ìœ„ ê²€ì¦ ë¶ˆì¶©ë¶„**:
   ```csharp
   // SkillData ë°°ì—´ ì ‘ê·¼ ì‹œ ì˜ˆì™¸ ì²˜ë¦¬ ì—†ìŒ
   for(int i = 0; i < stats.skillDatas.Length; i++)
   {
       var skill = stats.skillDatas[i];
       // skillì´ nullì¼ ìˆ˜ ìˆìŒ
   }
   ```

### ê°œì„ ì•ˆ
```csharp
// Target null ì•ˆì „ì„±
class ActionChase : ActionNode
{
    public override EvaluateResult Evaluate()
    {
        if (ctx._target == null || !ctx._target.gameObject.activeInHierarchy)
        {
            ctx._target = null;  // ëª…ì‹œì ìœ¼ë¡œ null ì„¤ì •
            return new EvaluateResult(BTNode.State.Failure, this.GetType().ToString());
        }
        // ...
    }
}
```

```csharp
// APCRouter ì•ˆì „ ì²˜ë¦¬
protected virtual void Start()
{
    currentHealth = stats.maxHealth;
    apcRouter = FindFirstObjectByType<APCRouter>();
    if (apcRouter != null)
    {
        apcRouter.EventShield.AddListener(ListenerActiveShield);
    }
    else
    {
        Logger.Write("APCRouter not found in scene", "WARNING");
    }
}
```

```csharp
// SkillData null ê²€ì¦
for(int i = 0; i < stats.skillDatas.Length; i++)
{
    var skill = stats.skillDatas[i];
    if (skill == null)
    {
        Logger.Write($"SkillData at index {i} is null", "ERROR");
        continue;
    }
    attackContainer.Add(...);
}
```

---

## ğŸ“Œ 8. Scalability / Extensibility

### í‰ê°€
- **ìºë¦­í„° í™•ì¥ì„±**: â­â­â­â­â˜† (4/5)
  - `CharacterStats` ScriptableObjectë¡œ ìƒˆ ìºë¦­í„° ì¶”ê°€ ìš©ì´
  - `HealthSystem`, `AttackSystem` ìƒì† êµ¬ì¡°ë¡œ ì»¤ìŠ¤í„°ë§ˆì´ì§• ê°€ëŠ¥
  - BUT: PlayerBehaviorì˜ FSM Stateê°€ Player ì „ìš©ì´ë¼ ì¬ì‚¬ìš© ë¶ˆê°€

- **ìŠ¤í‚¬/í–‰ë™ í™•ì¥**: â­â­â­â­â­ (5/5)
  - `SkillData` ScriptableObjectë¡œ ìŠ¤í‚¬ ë°ì´í„° ê´€ë¦¬ - ì™„ë²½
  - `SkillLogic` ì¶”ìƒ í´ë˜ìŠ¤ ìƒì†ìœ¼ë¡œ ìƒˆ ìŠ¤í‚¬ íƒ€ì… ì¶”ê°€ ìš©ì´
  - AoE, Projectile ë“± êµ¬ì²´ í´ë˜ìŠ¤ë¡œ ë¶„ë¦¬ë¨

- **Hard-coded vs Data-driven**: â­â­â­â­â˜† (4/5)
  - ëŒ€ë¶€ë¶„ì˜ ìˆ˜ì¹˜ê°€ ScriptableObjectë¡œ ë°ì´í„°í™”
  - BUT: FSM/BT ì „í™˜ ì¡°ê±´ì´ í•˜ë“œì½”ë”© (ì˜ˆ: `Mathf.Abs(_snapShotMoveInput) > Mathf.Epsilon`)

- **Event-driven êµ¬ì¡°**: â­â­â­â­â˜† (4/5)
  - UnityEvent(`EventHit`, `EventDeath`, `EventAttack`) í™œìš© ìš°ìˆ˜
  - ê²°í•©ë„ ë‚®ì¶”ê³  í™•ì¥ì„± í™•ë³´
  - BUT: ì´ë²¤íŠ¸ ê¸°ë°˜ ìŠ¤í‚¬ ë°œë™ ê°™ì€ ê³ ê¸‰ íŒ¨í„´ì€ ë¯¸ì ìš©

- **ì˜ì¡´ì„± ì—­ì „(DI)**: â­â­â˜†â˜†â˜† (2/5)
  - ëŒ€ë¶€ë¶„ GetComponentë¡œ ì§ì ‘ ì˜ì¡´ì„± íšë“
  - Singleton(`ContainerController.Instance`) íŒ¨í„´ ì‚¬ìš©
  - ì§„ì •í•œ DI ì»¨í…Œì´ë„ˆë‚˜ Service Locator íŒ¨í„´ ë¯¸ì‚¬ìš©

### ë¬¸ì œì 
1. **FSM State ì¬ì‚¬ìš© ë¶ˆê°€**:
   ```csharp
   // PlayerBehavior ë‚´ë¶€ nested class
   class StateMove : FSMNode { ... }
   // Enemyë‚˜ ë‹¤ë¥¸ ìºë¦­í„°ëŠ” ì´ Stateë¥¼ ì¬ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
   ```

2. **BT Actionë„ Enemy ì „ìš©**:
   ```csharp
   // EnemyBehavior ë‚´ë¶€ nested class
   class ActionPatrol : ActionNode 
   {
       EnemyBehavior ctx;  // Enemyì— ê°•ê²°í•©
   }
   ```

3. **í•˜ë“œì½”ë”©ëœ ì „í™˜ ì¡°ê±´**:
   ```csharp
   if (Mathf.Abs(_snapShotMoveInput) > Mathf.Epsilon)
       ChangeState(ref currentXState, PlayerState.MOVE);
   // ì´ ì¡°ê±´ì„ ì™¸ë¶€ì—ì„œ ì„¤ì • ë¶ˆê°€
   ```

### ê°œì„ ì•ˆ
```csharp
// FSM Stateë¥¼ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ ë¶„ë¦¬
// Assets/Scripts/Core/FSM/States/MoveState.cs
public class MoveState : FSMNode
{
    private readonly IMovementContext ctx;
    
    public MoveState(IMovementContext ctx) => this.ctx = ctx;
    
    public override void Update()
    {
        ctx.UpdateVelocity();
        ctx.FlipDirection();
    }
}

// PlayerBehaviorì™€ EnemyBehaviorê°€ IMovementContext êµ¬í˜„
```

```csharp
// FSM ì „í™˜ ì¡°ê±´ì„ ScriptableObjectë¡œ ë°ì´í„°í™”
[CreateAssetMenu(fileName = "FSM Config", menuName = "Game/FSM Config")]
public class FSMConfig : ScriptableObject
{
    public float moveInputThreshold = 0.01f;
    public float landingVelocityMargin = 0.1f;
    // ...
}

// PlayerBehavior
if (Mathf.Abs(_snapShotMoveInput) > fsmConfig.moveInputThreshold)
    ChangeState(ref currentXState, PlayerState.MOVE);
```

```csharp
// DI íŒ¨í„´ ì ìš© ì˜ˆì‹œ (Zenject/VContainer ì—†ì´ ìˆ˜ë™ DI)
public class ServiceLocator
{
    private static readonly Dictionary<Type, object> services = new();
    
    public static void Register<T>(T service) => services[typeof(T)] = service;
    public static T Get<T>() => (T)services[typeof(T)];
}

// HealthSystem
protected virtual void Start()
{
    apcRouter = ServiceLocator.Get<APCRouter>();
    // ...
}
```

---

## ğŸ“Œ 9. Clean Code Practices

### í‰ê°€
- **SOLID ì›ì¹™**: â­â­â­â˜†â˜† (3/5)
  - **S (SRP)**: ë¶€ë¶„ì  ì¤€ìˆ˜, PlayerBehavior/EnemyBehaviorëŠ” ê³¼ë‹¤ ì±…ì„
  - **O (OCP)**: ScriptableObject + ìƒì† êµ¬ì¡°ë¡œ í™•ì¥ì— ì—´ë ¤ìˆìŒ âœ…
  - **L (LSP)**: HealthSystem/AttackSystem ìƒì† êµ¬ì¡° ì ì ˆ âœ…
  - **I (ISP)**: ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš© ë¶€ì¡± (BTNodeë§Œ interface)
  - **D (DIP)**: êµ¬ì²´ í´ë˜ìŠ¤ ì§ì ‘ ì˜ì¡´, DI ë¯¸ì‚¬ìš© âŒ

- **DRY/KISS/YAGNI**: â­â­â­â˜†â˜† (3/5)
  - **DRY**: `CalculateKnockback` ì¤‘ë³µ, `FlipDirection` ì¤‘ë³µ
  - **KISS**: FSM/BT êµ¬í˜„ì€ ë‹¨ìˆœëª…ë£Œí•˜ë‚˜ PlayerBehaviorëŠ” ë³µì¡
  - **YAGNI**: `_isChanneling` ê°™ì€ ë¯¸ì‚¬ìš© í•„ë“œ ì¡´ì¬

- **public í•„ë“œ ë…¸ì¶œ**: â­â­â­â­â˜† (4/5)
  - ëŒ€ë¶€ë¶„ `[SerializeField] private` ì‚¬ìš©
  - public propertyë¡œ í•„ìš”í•œ ê²ƒë§Œ ë…¸ì¶œ (`IsAlive`, `MaxHealth`)
  - BUT: ScriptableObject í•„ë“œê°€ ëª¨ë‘ public (ìº¡ìŠí™” ë¶€ì¡±)

- **property vs field**: â­â­â­â­â˜† (4/5)
  - readonly property ì ì ˆíˆ í™œìš© (`IsAlive`, `CurrentHealth`)
  - BUT: ScriptableObjectëŠ” ëª¨ë‘ public field

- **ë„¤ì„ìŠ¤í˜ì´ìŠ¤**: â­â˜†â˜†â˜†â˜† (1/5)
  - **ì¹˜ëª…ì **: ëª¨ë“  í´ë˜ìŠ¤ê°€ global namespace
  - ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì‚¬ìš© ì „ë¬´

### ë¬¸ì œì 
1. **ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë¶€ì¬**:
   ```csharp
   // ëª¨ë“  íŒŒì¼ì´ namespace ì—†ì´ ì‘ì„±ë¨
   public class PlayerBehavior : MonoBehaviour { ... }
   ```
   â†’ ë‹¤ë¥¸ í”„ë¡œì íŠ¸ì™€ ì¶©ëŒ ê°€ëŠ¥, ì½”ë“œ ì¡°ì§í™” ë¶ˆê°€

2. **ScriptableObject ìº¡ìŠí™” ë¶€ì¡±**:
   ```csharp
   [SerializeField] public float maxHealth;  // public + SerializeField ì¤‘ë³µ
   ```

3. **ë¯¸ì‚¬ìš© í•„ë“œ/ë©”ì„œë“œ**:
   ```csharp
   bool _isChanneling;  // ì„¤ì •ë§Œ ë˜ê³  ì‚¬ìš© ì•ˆ ë¨
   void ListenerAttack(int attackIndex) { }  // ë¹ˆ ë©”ì„œë“œ
   ```

### ê°œì„ ì•ˆ
```csharp
// ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë„ì…
namespace ProjectMagic.Player
{
    public class PlayerBehavior : MonoBehaviour { ... }
}

namespace ProjectMagic.Enemy
{
    public class EnemyBehavior : MonoBehaviour { ... }
}

namespace ProjectMagic.Core
{
    public abstract class FSMNode { ... }
    public interface BTNode { ... }
}
```

```csharp
// ScriptableObject ìº¡ìŠí™”
public class CharacterStats : ScriptableObject
{
    [Header("Health")]
    [SerializeField] private float _maxHealth;
    [SerializeField] private float _healthRegen;
    
    public float MaxHealth => _maxHealth;
    public float HealthRegen => _healthRegen;
}
```

```csharp
// ë¯¸ì‚¬ìš© ì½”ë“œ ì œê±°
// _isChanneling í•„ë“œ ì‚­ì œ
// ListenerAttack êµ¬í˜„ ë˜ëŠ” ì œê±°
```

**í´ë” êµ¬ì¡° í‰ê°€**: â­â­â­â­â˜† (4/5)
- ê¸°ëŠ¥ë³„ í´ë” ë¶„ë¦¬ ìš°ìˆ˜ (Player, Enemy, Core, Common, Skills)
- BUT: BossAlphaê°€ Enemy í•˜ìœ„ì— ìˆìœ¼ë‚˜ ë…ë¦½ì„±ì´ ë‚®ìŒ (ê³µí†µ ì½”ë“œ ì¬ì‚¬ìš© ë¶€ì¡±)

---

## ğŸ“Œ 10. ì¢…í•© ì ìˆ˜ ë° ê°œì„  ì œì•ˆ

### ì¢…í•© ì ìˆ˜í‘œ (10/10 ë§Œì )

| í•­ëª© | ì ìˆ˜ | í‰ê°€ |
|-----|------|-----|
| 1. Architecture & Component Design | 4.0 | FSM/BT/ScriptableObject êµ¬ì¡° ìš°ìˆ˜, SRP ë¶€ë¶„ì  ìœ„ë°˜ |
| 2. Readability & Maintainability | 3.0 | XML ì£¼ì„ ì „ë¬´, Magic number ë‹¤ìˆ˜ |
| 3. Performance & Memory | 3.5 | Loggerì˜ StackTraceê°€ ì¹˜ëª…ì , Pool í™œìš©ì€ ìš°ìˆ˜ |
| 4. Gameplay Logic & Stability | 4.0 | Input Snapshot íŒ¨í„´ íƒì›”, null ì²´í¬ ë¶€ì¡± |
| 5. Unity Best Practices | 4.0 | GetComponent ìºì‹± ì™„ë²½, Tooltip ë¶€ì¬ |
| 6. Animation & FSM/BT | 3.5 | êµ¬ì¡°ëŠ” ì¢‹ìœ¼ë‚˜ Running ìƒíƒœ ëª¨í˜¸ |
| 7. Safety & Error Handling | 3.0 | null ë°©ì–´ ë¶ˆì¶©ë¶„, Boundary ì²´í¬ ë¯¸í¡ |
| 8. Scalability / Extensibility | 4.0 | ScriptableObject í™œìš© ìš°ìˆ˜, DI ë¶€ì¬ |
| 9. Clean Code Practices | 2.5 | ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë¶€ì¬ê°€ ì¹˜ëª…ì  |
| **ì´ì ** | **3.5/5** | **ì–‘í˜¸ ìˆ˜ì¤€, ê°œì„  ì—¬ì§€ ë§ìŒ** |

---

### ğŸ”´ **ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (Critical)**

#### 1. Loggerì˜ StackTrace ì œê±° (Performance Critical!)
**ë¬¸ì œ**: ë§¤ ë¡œê·¸ë§ˆë‹¤ StackTrace ìƒì„±ìœ¼ë¡œ ì‹¬ê°í•œ ì„±ëŠ¥ ì €í•˜
```csharp
// Before (í˜„ì¬)
public static void Write(string log="No Message", string level="INFO")
{
    if (DEBUG)
    {
        StackTrace trace = new StackTrace();  // ë§¤ìš° ë¹„ìŒˆ!
        StackFrame caller = trace.GetFrame(1);
        var method = caller.GetMethod();
        UnityEngine.Debug.Log($"{level} / {method.DeclaringType.Name}.{method.Name} / {log}");  
    }
}

// After (ê°œì„ )
public static void Write(string log="No Message", string level="INFO")
{
    if (!DEBUG) return;
    
    #if UNITY_EDITOR
    // ì—ë””í„°ì—ì„œë§Œ StackTrace ì‚¬ìš©
    StackTrace trace = new StackTrace();
    StackFrame caller = trace.GetFrame(1);
    var method = caller.GetMethod();
    UnityEngine.Debug.Log($"{level} / {method.DeclaringType.Name}.{method.Name} / {log}");
    #else
    // ë¹Œë“œì—ì„œëŠ” ë‹¨ìˆœ ë¡œê·¸ë§Œ
    UnityEngine.Debug.Log($"[{level}] {log}");
    #endif
}
```

**ì˜ˆìƒ íš¨ê³¼**: í”„ë¡œíŒŒì¼ë§ ì‹œ CPU ì‚¬ìš©ëŸ‰ 30~50% ê°ì†Œ ê°€ëŠ¥

---

#### 2. XML ë¬¸ì„œí™” ì£¼ì„ ì¶”ê°€ (Maintainability Critical!)
**ë¬¸ì œ**: public APIì— ëŒ€í•œ ì„¤ëª…ì´ ì „í˜€ ì—†ì–´ í˜‘ì—… ì‹œ ì´í•´ ë‚œì´ë„ ë†’ìŒ

```csharp
// Before
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)

// After
/// <summary>
/// ìºë¦­í„°ì—ê²Œ ë°ë¯¸ì§€ë¥¼ ì ìš©í•˜ê³  ë„‰ë°± íš¨ê³¼ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
/// ë¬´ì  ìƒíƒœì´ê±°ë‚˜ ì´ë¯¸ ì‚¬ë§í•œ ê²½ìš° ë¬´ì‹œë©ë‹ˆë‹¤.
/// </summary>
/// <param name="rawDamage">ë°©ì–´ë ¥ ì ìš© ì „ ì›ë³¸ ë°ë¯¸ì§€ (1 ì´ìƒ)</param>
/// <param name="knockbackDirection">ë„‰ë°± ë°©í–¥ ë° í˜. Vector2.zeroë©´ ë„‰ë°± ì—†ìŒ</param>
/// <remarks>
/// ìµœì¢… ë°ë¯¸ì§€ = (rawDamage - defense) * (1 - damageReduction), ìµœì†Œ 1
/// í”¼ê²© ì‹œ EventHit ë°œìƒ, ì²´ë ¥ 0 ë„ë‹¬ ì‹œ EventDeath ë°œìƒ
/// </remarks>
public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
```

**ìš°ì„  ëŒ€ìƒ**: HealthSystem, AttackSystem, SkillLogic, FSMNode, BTNode

---

#### 3. ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë„ì… (Clean Code Critical!)
**ë¬¸ì œ**: ëª¨ë“  í´ë˜ìŠ¤ê°€ global namespaceë¡œ ì´ë¦„ ì¶©ëŒ ìœ„í—˜

```csharp
// í´ë” êµ¬ì¡°ì— ë§ì¶° ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë„ì…
namespace ProjectMagic.Core
{
    public abstract class FSMNode { ... }
    public interface BTNode { ... }
    public abstract class HealthSystem : MonoBehaviour { ... }
    public abstract class AttackSystem : MonoBehaviour { ... }
}

namespace ProjectMagic.Player
{
    using ProjectMagic.Core;
    public class PlayerBehavior : MonoBehaviour { ... }
    public class PlayerAttack : AttackSystem { ... }
}

namespace ProjectMagic.Enemy
{
    using ProjectMagic.Core;
    public class EnemyBehavior : MonoBehaviour { ... }
}

namespace ProjectMagic.Skills
{
    using ProjectMagic.Core;
    public class SkillLogic : MonoBehaviour { ... }
    public class AoeSkillLogic : SkillLogic { ... }
}
```

---

### ğŸŸ¡ **ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Refactoring)**

#### 1. PlayerBehavior/EnemyBehavior íŒŒì¼ ë¶„í• 
**ë¬¸ì œ**: ê°ê° 420ì¤„, 473ì¤„ë¡œ ê³¼ë„í•˜ê²Œ ë¹„ëŒ€

**ì œì•ˆ êµ¬ì¡°**:
```
Assets/Scripts/Player/
  PlayerBehavior.cs          (í•µì‹¬ ë¡œì§ë§Œ, ~150ì¤„)
  States/
    PlayerStateIdle.cs
    PlayerStateMove.cs
    PlayerStateInFlight.cs
    PlayerStateAttack.cs
    PlayerStateHit.cs
    PlayerStateDeath.cs

Assets/Scripts/Enemy/
  EnemyBehavior.cs           (í•µì‹¬ ë¡œì§ë§Œ, ~150ì¤„)
  Actions/
    EnemyActionDeath.cs
    EnemyActionDamaged.cs
    EnemyActionDetection.cs
    EnemyActionChase.cs
    EnemyActionAttack.cs
    EnemyActionPatrol.cs
    EnemyActionIdle.cs
```

**ì¥ì **:
- íŒŒì¼ë‹¹ 100~150ì¤„ ìœ ì§€ë¡œ ê°€ë…ì„± í–¥ìƒ
- State/Action ë‹¨ìœ„ ì¬ì‚¬ìš© ê°€ëŠ¥
- ë‹¤ë¥¸ ìºë¦­í„°ê°€ íŠ¹ì • State/Actionë§Œ ì°¨ìš© ê°€ëŠ¥

---

#### 2. EvaluateResultë¥¼ structë¡œ ë³€ê²½ (GC ìµœì í™”)
**ë¬¸ì œ**: BT í‰ê°€ ì‹œ ë§¤ í”„ë ˆì„ heap allocation ë°œìƒ

```csharp
// Before (class - heap allocation)
public class EvaluateResult
{
    public BTNode.State state;
    public string actionRole;
    
    public EvaluateResult(BTNode.State state, string actionRole)
    {
        this.state = state;
        this.actionRole = actionRole;
    }
}

// After (struct - stack allocation)
public readonly struct EvaluateResult
{
    public readonly BTNode.State State;
    public readonly string ActionRole;
    
    public EvaluateResult(BTNode.State state, string actionRole)
    {
        State = state;
        ActionRole = actionRole;
    }
    
    // Deconstruct ì§€ì›
    public void Deconstruct(out BTNode.State state, out string role)
    {
        state = State;
        role = ActionRole;
    }
}
```

**ì˜ˆìƒ íš¨ê³¼**: ì  10ë§ˆë¦¬ ê¸°ì¤€ ì´ˆë‹¹ GC ë°œìƒëŸ‰ 60~100 ê°ì†Œ

---

#### 3. ê³µí†µ ë¡œì§ ìœ í‹¸ë¦¬í‹°í™”
**ë¬¸ì œ**: `CalculateKnockback`, `FlipDirection` ë“± ì¤‘ë³µ ì½”ë“œ ì‚°ì¬

```csharp
// Assets/Scripts/Utils/CombatUtils.cs
namespace ProjectMagic.Utils
{
    public static class CombatUtils
    {
        /// <summary>
        /// ê³µê²©ìì™€ í”¼ê²©ì ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë„‰ë°± ë²¡í„°ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        /// </summary>
        public static Vector2 CalculateKnockback(Vector3 from, Vector3 to, Vector2 force)
        {
            Vector2 direction = new Vector2(Mathf.Sign(to.x - from.x), 1f);
            return direction * force;
        }
        
        /// <summary>
        /// Transformì˜ localScale.xë¥¼ ì¡°ì •í•˜ì—¬ ìºë¦­í„° ë°©í–¥ì„ ì „í™˜í•©ë‹ˆë‹¤.
        /// </summary>
        /// <param name="transform">ëŒ€ìƒ Transform</param>
        /// <param name="faceRight">trueë©´ ì˜¤ë¥¸ìª½, falseë©´ ì™¼ìª½</param>
        public static void FlipDirection(Transform transform, bool faceRight)
        {
            Vector3 scale = transform.localScale;
            scale.x = faceRight ? Mathf.Abs(scale.x) : -Mathf.Abs(scale.x);
            transform.localScale = scale;
        }
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
var knockback = CombatUtils.CalculateKnockback(originPos, hitPoint, attack.knockback);
CombatUtils.FlipDirection(transform, _snapShotMoveInput > 0);
```

---

### ğŸŸ¢ **Best Parts (ì˜í•œ ì )**

#### 1. â­ Input Snapshot íŒ¨í„´ êµ¬í˜„ (ìµœìƒê¸‰!)
```csharp
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput;
    _snapShotjumpInput = _jumpInput ? 1.0f : 0.0f;
    UpdateYState();
    UpdateXState();
}
```
**ì´ìœ **: Updateì™€ FixedUpdateì˜ íƒ€ì´ë° ë¶ˆì¼ì¹˜ ë¬¸ì œë¥¼ ì™„ë²½íˆ í•´ê²°. ê²Œì„í”Œë ˆì´ ì•ˆì •ì„± í™•ë³´.

---

#### 2. â­ ScriptableObject ê¸°ë°˜ ë°ì´í„° ì„¤ê³„
```csharp
[CreateAssetMenu(fileName = "New Character Stats", menuName = "Game/Character Stats")]
public class CharacterStats : ScriptableObject
{
    public float maxHealth;
    public float moveSpeed;
    public SkillData[] skillDatas;
    // ...
}
```
**ì´ìœ **: 
- ë””ìì´ë„ˆê°€ ì½”ë“œ ìˆ˜ì • ì—†ì´ ìºë¦­í„° ë°¸ëŸ°ìŠ¤ ì¡°ì • ê°€ëŠ¥
- ëŸ°íƒ€ì„ì— ë°ì´í„° ê³µìœ ë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì 
- ìƒˆ ìºë¦­í„° ì¶”ê°€ê°€ ë§¤ìš° ì‰¬ì›€

---

#### 3. â­ ObjectPool ì œë„¤ë¦­ êµ¬í˜„
```csharp
public class ObjectPool<T> where T : MonoBehaviour
{
    private readonly Queue<T> pool;
    public T Get() { ... }
    public void Return(T obj) { ... }
}
```
**ì´ìœ **:
- ìŠ¤í‚¬/íˆ¬ì‚¬ì²´ ì¬ì‚¬ìš©ìœ¼ë¡œ GC ë¶€ë‹´ ëŒ€í­ ê°ì†Œ
- ì œë„¤ë¦­ìœ¼ë¡œ ëª¨ë“  MonoBehaviour íƒ€ì… ì§€ì›
- í™•ì¥ ê°€ëŠ¥í•œ êµ¬ì¡°

---

## ğŸ“Š **ìµœì¢… í‰ê°€**

**ì „ì²´ ì½”ë“œ í’ˆì§ˆ**: â­â­â­â˜†â˜† (3.5/5) - **ì–‘í˜¸ ìˆ˜ì¤€**

**ê°•ì **:
- Unity ê²Œì„ ê°œë°œ í•µì‹¬ íŒ¨í„´(FSM, BT, ObjectPool, ScriptableObject) í™œìš© ìš°ìˆ˜
- Input ì²˜ë¦¬, Component ìºì‹± ë“± ê¸°ë³¸ê¸° íƒ„íƒ„
- í™•ì¥ ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜ ê¸°ë°˜ ë§ˆë ¨

**ì•½ì **:
- ë¬¸ì„œí™”(XML ì£¼ì„) ì „ë¬´
- Logger ì„±ëŠ¥ ë¬¸ì œ ì‹¬ê°
- ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë¶€ì¬ë¡œ ì½”ë“œ ì¡°ì§í™” ë¶€ì¡±
- null ì•ˆì „ì„± ë¯¸í¡

**ê²°ë¡ **: 
í˜„ì¬ ì½”ë“œëŠ” **í”„ë¡œí† íƒ€ì…/ì´ˆê¸° ê°œë°œ ë‹¨ê³„ë¡œì„œëŠ” í›Œë¥­**í•˜ë‚˜, íŒ€ í˜‘ì—…ì´ë‚˜ ì¥ê¸° ìœ ì§€ë³´ìˆ˜ë¥¼ ìœ„í•´ì„œëŠ” **ì¦‰ì‹œ ê°œì„  3ê°€ì§€(Logger, XML ì£¼ì„, ë„¤ì„ìŠ¤í˜ì´ìŠ¤)**ë¥¼ ë°˜ë“œì‹œ ì ìš©í•´ì•¼ í•¨. ì¤‘ì¥ê¸° ë¦¬íŒ©í† ë§(íŒŒì¼ ë¶„í• , GC ìµœì í™”)ì€ ê¸°ëŠ¥ ê°œë°œê³¼ ë³‘í–‰í•˜ë©° ì ì§„ì ìœ¼ë¡œ ì§„í–‰ ê¶Œì¥.

---

**í‰ê°€ì ì˜ê²¬**:  
ì´ ì •ë„ ìˆ˜ì¤€ì˜ ì•„í‚¤í…ì²˜ ì„¤ê³„ëŠ” Unity ì¤‘ê¸‰ ì´ìƒ ê°œë°œìì˜ ìˆ˜ì¤€ì…ë‹ˆë‹¤. ScriptableObject í™œìš©ê³¼ Input Snapshot íŒ¨í„´ì€ íŠ¹íˆ ì¸ìƒì ì´ë©°, FSM/BT êµ¬í˜„ë„ êµê³¼ì„œì ì…ë‹ˆë‹¤. ë‹¤ë§Œ ë¬¸ì„œí™”ì™€ ì„±ëŠ¥ ìµœì í™” ì¸¡ë©´ì—ì„œ ê°œì„ ì´ ì‹œê¸‰í•˜ë©°, ì´ë¥¼ í•´ê²°í•˜ë©´ **4.0~4.5/5 ìˆ˜ì¤€ì˜ ìƒê¸‰ ì½”ë“œ**ë¡œ ë°œì „ ê°€ëŠ¥í•©ë‹ˆë‹¤.
