Read [](file:///c%3A/Users/flash/projects/project-magic/Assets/Scripts/Player/PlayerBehavior.cs)

Read [](file:///c%3A/Users/flash/projects/project-magic/Assets/Scripts/Enemy/EnemyBehavior.cs#1-1), lines 1 to 309

Read [](file:///c%3A/Users/flash/projects/project-magic/Assets/Scripts/Animation/AnimationController.cs)

# ğŸ“Š Unity C# Code ì¢…í•© í‰ê°€ (CodeEvaluationPrompt ê¸°ì¤€)

---

## **[1. Architecture & Unity Component Design]** â­â­â­â­ (8/10)

### âœ… **ì¥ì :**
- **SRP ì¤€ìˆ˜ ìš°ìˆ˜**: `PlayerBehavior` (FSM), `EnemyBehavior` (BT), `HealthSystem`, `AttackSystem` ì±…ì„ ë¶„ë¦¬ ëª…í™•
- **Composition í™œìš©**: `GetComponent` ê¸°ë°˜ ëª¨ë“ˆ ì¡°ë¦½ (Rigidbody, AnimationController, HealthSystem)
- **ìƒëª…ì£¼ê¸° ì ì ˆ**: `Awake`(ì»´í¬ë„ŒíŠ¸ ìºì‹±) â†’ `Start`(ì´ˆê¸°í™”) â†’ `FixedUpdate`(ë¬¼ë¦¬) â†’ `Update`(íƒ€ì´ë¨¸)
- **Event-driven ì„¤ê³„**: `HealthSystem.EventHit`, `AttackSystem.EventAttack` â†’ ëŠìŠ¨í•œ ê²°í•©

### âŒ **ê°œì„ ì :**
```csharp
// âŒ PlayerBehaviorê°€ ê³µê²© ë¡œì§ ì§ì ‘ í˜¸ì¶œ
public void OnAttack(InputValue value)
{
    attackSystem.ExecuteAttack(0, this.transform, layerEnemy);
}
```
**ë¬¸ì œ:** Input ì²˜ë¦¬ê°€ PlayerBehaviorì— í˜¼ì¬

**ê°œì„ :**
```csharp
// PlayerInputHandler.cs (ìƒˆ í´ë˜ìŠ¤)
public class PlayerInputHandler : MonoBehaviour
{
    [SerializeField] PlayerBehavior behavior;
    [SerializeField] AttackSystem attackSystem;
    [SerializeField] LayerMask enemyLayer;
    
    public void OnAttack(InputValue value)
    {
        attackSystem.ExecuteAttack(0, transform, enemyLayer);
    }
    
    public void OnMove(InputValue value)
    {
        behavior.SetMoveInput(value.Get<float>());
    }
}
```

---

## **[2. Code Readability & Maintainability]** â­â­â­â­â­ (9/10)

### âœ… **ì¥ì :**
- **ë„¤ì´ë° ìš°ìˆ˜**: `CheckFlipDirection()`, `UpdateVelocity()`, `ListenerHit()` - ì˜ë¯¸ ëª…í™•
- **ì£¼ì„ ì ì ˆ**: `// condition1: íŒ¨íŠ¸ë¡¤ ë²”ìœ„ ì´ˆê³¼`, `// wall check`
- **FSM êµ¬ì¡° ëª…í™•**: Nested classë¡œ ìƒíƒœ ìº¡ìŠí™”
- **ì¤‘ë³µ ì œê±°**: `ChangeState()` ë©”ì„œë“œë¡œ ìƒíƒœ ì „í™˜ í†µí•©

### âš ï¸ **ì†Œì†Œí•œ ê°œì„ :**
```csharp
// âŒ ë¶ˆí•„ìš”í•œ ì¤‘ê´„í˜¸
void ListenerAttack(int attackIndex)
{
    if (_attackRecoveryTimer > 0) return;
    {  // â† ë¶ˆí•„ìš”
        switch (attackIndex)
        {
            case 0:
                bufferXState.Enqueue(PlayerState.ATTACK);
                return;
        }
    }
}
```

**ìˆ˜ì •:**
```csharp
void ListenerAttack(int attackIndex)
{
    if (_attackRecoveryTimer > 0) return;
    
    switch (attackIndex)
    {
        case 0:
            bufferXState.Enqueue(PlayerState.ATTACK);
            return;
    }
}
```

---

## **[3. Performance & Memory Efficiency]** â­â­â­â­ (8/10)

### âœ… **ì¥ì :**
- **Component ìºì‹±**: `Awake()`ì—ì„œ `GetComponent` 1íšŒë§Œ í˜¸ì¶œ
- **ì…ë ¥ ìŠ¤ëƒ…ìƒ·**: `FixedUpdate`ì—ì„œ `_snapShotMoveInput` ì €ì¥ â†’ Update/FixedUpdate ë¶„ë¦¬
- **GC ì¹œí™”ì **: `Queue<PlayerState>` ì¬ì‚¬ìš©, `Tuple` ëŒ€ì‹  struct ê°€ëŠ¥í•˜ì§€ë§Œ acceptable
- **Physics ìµœì í™”**: `FixedUpdate`ì—ì„œ `rb.linearVelocity` ì§ì ‘ ì„¤ì •

### âš ï¸ **ê°œì„ ì :**

**1. Tuple ëŒ€ì‹  struct (ì„ íƒì  ìµœì í™”)**
```csharp
// âŒ í˜„ì¬ (Tupleì€ GC ë°œìƒ)
public override Tuple<BTNode.State, string> Evaluate()

// âœ… ê°œì„ 
public struct EvaluateResult
{
    public BTNode.State state;
    public string actionName;
}

public override EvaluateResult Evaluate()
{
    return new EvaluateResult { state = BTNode.State.Success, actionName = "..." };
}
```

**2. ë§¤ í”„ë ˆì„ ì• ë‹ˆë©”ì´ì…˜ í˜¸ì¶œ (ì´ë¯¸ ì§€ì í•œ ë¶€ë¶„)**
```csharp
// âŒ ActionPatrol.Evaluate()ì—ì„œ ë§¤ë²ˆ í˜¸ì¶œ
ctx.animController.PlayStateAnimation(EnemyState.PATROL);
```
â†’ `AnimationController`ì— ì¤‘ë³µ ë°©ì§€ ë¡œì§ ì¶”ê°€ í•„ìš” (í˜„ì¬ ì½”ë“œì—ëŠ” ì—†ìŒ!)

**3. Logger.Write() ë§¤ í”„ë ˆì„ í˜¸ì¶œ**
```csharp
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    Logger.Write($"selectorResult={selectorResult}, actionPath={actionPath}"); // â† ë§¤ í”„ë ˆì„!
}
```
â†’ `#if UNITY_EDITOR` + `Logger.DEBUG` ì²´í¬ ì¶”ê°€

---

## **[4. Gameplay Logic & Stability]** â­â­â­â­â­ (10/10)

### âœ… **ì™„ë²½í•œ êµ¬í˜„:**

**1. ì…ë ¥ ì•ˆì •ì„±**
```csharp
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput; // âœ… ì…ë ¥ ìº¡ì²˜
    _snapShotjumpInput = _jumpInput;
    UpdateYState();
    UpdateXState();
}
```
â†’ Update/FixedUpdate íƒ€ì´ë° ì°¨ì´ í•´ê²°

**2. ìƒíƒœ ë²„í¼ ì‹œìŠ¤í…œ**
```csharp
void UpdateXState()
{
    while (bufferXState.Count > 0) // âœ… ì´ë²¤íŠ¸ ì¤‘ ìƒíƒœ ë³€ê²½ ì•ˆì „
    {
        var newState = bufferXState.Dequeue();
        ChangeState(ref currentXState, newState);
        if (currentXState == PlayerState.DEATH) return;
    }
}
```
â†’ FixedUpdate ì¤‘ ì™¸ë¶€ ì´ë²¤íŠ¸ë¡œ ì¸í•œ ìƒíƒœ ì¶©ëŒ ë°©ì§€

**3. ë¬´ì  ì‹œê°„ êµ¬í˜„**
```csharp
void ListenerHit(Vector2 knockback)
{
    if (_hitRecoveryTimer > 0) return; // âœ… ì—°ì† í”¼ê²© ë°©ì§€
    _hitForce = knockback;
    bufferXState.Enqueue(PlayerState.DAMAGED);
}
```

**4. ê³µê²© ì¿¨ë‹¤ìš´**
```csharp
case PlayerState.ATTACK:
    if (_attackRecoveryTimer <= 0) // âœ… ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê¸°ë°˜
        ChangeState(ref currentXState, PlayerState.IDLE);
    break;
```

**5. Edge Case ì²˜ë¦¬**
```csharp
// CheckFlipDirection() - ë²½, ë‚­ë– ëŸ¬ì§€, íŒ¨íŠ¸ë¡¤ ë²”ìœ„ ëª¨ë‘ ì²´í¬
// CheckGrounded() - ì§€ìƒ í™•ì¸
// landingVelocityMargin - ì°©ì§€ íŒì • ë§ˆì§„
```

---

## **[5. Unity-Engine Best Practices]** â­â­â­â­ (8/10)

### âœ… **ì¥ì :**
- **Component ìºì‹±**: âœ… `Awake()`ì—ì„œ 1íšŒë§Œ
- **SerializeField**: âœ… `[Header("Stats")]` í™œìš©
- **Time.deltaTime**: âœ… `TickUpdate()`ì—ì„œ ì ì ˆíˆ ì‚¬ìš©
- **Physics ë¶„ë¦¬**: âœ… `FixedUpdate`ì—ì„œ `rb.linearVelocity` ì„¤ì •
- **Gizmos**: âœ… `OnDrawGizmosSelected()` ë””ë²„ê¹… ì§€ì›

### âŒ **ê°œì„ ì :**

**1. Magic Number ì œê±°**
```csharp
// âŒ í˜„ì¬
pos.x += direction * (ctx.colliderGround.size.x + 0.05f); // â† 0.05f?
pos.y -= 0.05f;

// âœ… ê°œì„ 
[SerializeField] float groundCheckOffset = 0.05f;
pos.x += direction * (ctx.colliderGround.size.x + groundCheckOffset);
```

**2. Tooltip ì¶”ê°€**
```csharp
[SerializeField, Tooltip("ì°©ì§€ íŒì • ë§ˆì§„ (ë‚®ì„ìˆ˜ë¡ ë¯¼ê°)")]
float landingVelocityMargin;

[SerializeField, Tooltip("í”¼ê²© í›„ ë¬´ì  ì‹œê°„ (ì´ˆ)")]
float hitRecoveryCooldown;
```

---

## **[6. Animation, FSM/BT, Event Flow]** â­â­â­â­â­ (10/10)

### âœ… **ì™„ë²½í•œ ì„¤ê³„:**

**1. FSM ì „í™˜ ì•ˆì •ì„±**
```csharp
void ChangeState(ref PlayerState currentState, PlayerState newState)
{
    if (currentState == newState) return; // âœ… ì¤‘ë³µ ì „í™˜ ë°©ì§€
    
    stateContainer[currentState].OnExit();
    currentState = newState;
    stateContainer[currentState].OnEnter();
}
```

**2. Animation Sync**
```csharp
class StateAttack : FSMNode
{
    public override void OnEnter()
    {
        var clipTime = ctx.animController.PlayStateAnimation(PlayerState.ATTACK);
        ctx._attackRecoveryTimer = clipTime; // âœ… ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê¸°ë°˜ ì¿¨ë‹¤ìš´
    }
}
```
â†’ Codeì™€ Animation ì™„ë²½ ë™ê¸°í™”

**3. Attack ì¤‘ ì›€ì§ì„ ì°¨ë‹¨**
```csharp
case PlayerState.ATTACK:
    if (_attackRecoveryTimer <= 0)
        ChangeState(ref currentXState, PlayerState.IDLE);
    break;

case PlayerState.IDLE:
    if (Mathf.Abs(_snapShotMoveInput) > Mathf.Epsilon)
        ChangeState(ref currentXState, PlayerState.MOVE); // â† ATTACK ì¤‘ì—” ì§„ì… ë¶ˆê°€
    break;
```

**4. BT Transition**
```csharp
selectorRoot = new SelectorNode(
    new List<SequenceNode>()
    {
        sequenceContainer[EnemyState.DEATH],     // ìš°ì„ ìˆœìœ„ 1
        sequenceContainer[EnemyState.DAMAGED],   // ìš°ì„ ìˆœìœ„ 2
        sequenceContainer[EnemyState.PATROL],    // ìš°ì„ ìˆœìœ„ 3
        sequenceContainer[EnemyState.IDLE],      // ìš°ì„ ìˆœìœ„ 4
    }
);
```
â†’ ëª…í™•í•œ ìš°ì„ ìˆœìœ„ êµ¬ì¡°

---

## **[7. Safety & Error Handling]** â­â­â­ (6/10)

### âœ… **ì¥ì :**
- **IsAlive ì²´í¬**: `ListenerDeath()`ì—ì„œ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
- **ì¿¨ë‹¤ìš´ ì²´í¬**: ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì— ì¿¨ë‹¤ìš´ ê°€ë“œ
- **DEATH ì¡°ê¸° ë°˜í™˜**: ë²„í¼ ì ìš© ì¤‘ ì‚¬ë§ ì‹œ ì¦‰ì‹œ ì¢…ë£Œ

### âŒ **ê°œì„  í•„ìš”:**

**1. Null ë°©ì–´ ì—†ìŒ**
```csharp
void Awake()
{
    stats = GetComponentInChildren<StatsContainer>().stats; // âŒ null ê°€ëŠ¥
    rb = GetComponentInChildren<Rigidbody2D>(); // âŒ null ê°€ëŠ¥
}
```

**ê°œì„ :**
```csharp
void Awake()
{
    var statsContainer = GetComponentInChildren<StatsContainer>();
    if (statsContainer == null)
    {
        Debug.LogError($"StatsContainer not found on {gameObject.name}");
        enabled = false;
        return;
    }
    stats = statsContainer.stats;
    
    if (!TryGetComponent(out rb))
    {
        Debug.LogError($"Rigidbody2D not found on {gameObject.name}");
        enabled = false;
    }
}
```

**2. AnimationController null ì²´í¬**
```csharp
public float PlayStateAnimation(PlayerState state)
{
    int index = this.selectType == AnimationSelectType.First ? 0 : GetRandomIndex(state);
    _prefabs.PlayAnimation(state, index); // âŒ _prefabs null ê°€ëŠ¥
    return _prefabs.GetClipTime(state, index);
}
```

---

## **[8. Scalability / Extensibility]** â­â­â­â­â­ (10/10)

### âœ… **ì™„ë²½í•œ í™•ì¥ì„±:**

**1. ìƒˆ ìƒíƒœ ì¶”ê°€ ìš©ì´**
```csharp
// 1. Enumì— ì¶”ê°€
public enum PlayerState { IDLE, MOVE, ATTACK, ROLL } // â† ROLL ì¶”ê°€

// 2. FSMNode êµ¬í˜„
class StateRoll : FSMNode { ... }

// 3. BuildStateControllerì— ë“±ë¡
{PlayerState.ROLL, new StateRoll(this)}

// 4. switchì— ì¶”ê°€
case PlayerState.ROLL:
    if (rollTimer <= 0) ChangeState(ref currentXState, PlayerState.IDLE);
    break;
```

**2. ë°ì´í„° ê¸°ë°˜ ì„¤ê³„**
```csharp
CharacterStats stats; // â† ScriptableObject
[SerializeField] float hitRecoveryCooldown; // â† Inspector ì¡°ì •
```

**3. Event-driven**
```csharp
healthSystem.EventHit.AddListener(ListenerHit);
attackSystem.EventAttack.AddListener(ListenerAttack);
```
â†’ ì‹œìŠ¤í…œ ê°„ ê²°í•©ë„ ë‚®ìŒ

**4. BT í™•ì¥**
```csharp
// Chase ì¶”ê°€ ì‹œ
sequenceContainer[EnemyState.CHASE] = new SequenceNode(
    new List<ActionNode>
    {
        new ActionFindPlayer(this),
        new ActionChasePlayer(this),
    },
    EnemyState.CHASE.ToString()
);
```

---

## **[9. Clean Code Practices]** â­â­â­â­ (8/10)

### âœ… **SOLID ì›ì¹™:**
- **SRP**: âœ… PlayerBehavior, EnemyBehavior ì±…ì„ ëª…í™•
- **OCP**: âœ… FSMNode, ActionNode ìƒì†ìœ¼ë¡œ í™•ì¥
- **LSP**: âœ… StateHit, StateMove ë“± ì •ìƒ ì¹˜í™˜ ê°€ëŠ¥
- **ISP**: âœ… FSMNode ì¸í„°í˜ì´ìŠ¤ ê°„ê²°
- **DIP**: âœ… Event ê¸°ë°˜ ì˜ì¡´ì„± ì—­ì „

### âœ… **DRY/KISS:**
- `ChangeState()` ë©”ì„œë“œë¡œ ì¤‘ë³µ ì œê±°
- Nested classë¡œ ì‘ì§‘ë„ ë†’ì„

### âŒ **ê°œì„ ì :**

**1. Public í•„ë“œ**
```csharp
public bool IsAlive { get; private set; } // âœ… Property ì‚¬ìš© (ì¢‹ìŒ)
public Animator animator; // âŒ AnimationControllerì—ì„œ public
```

**2. ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì—†ìŒ**
```csharp
// âŒ í˜„ì¬
public class PlayerBehavior : MonoBehaviour

// âœ… ê°œì„ 
namespace ProjectMagic.Player
{
    public class PlayerBehavior : MonoBehaviour
}
```

---

## **[10. ì¢…í•© ì ìˆ˜ ë° ê°œì„  ìš°ì„ ìˆœìœ„]**

### **ğŸ“Š ë¶€ë¬¸ë³„ ì ìˆ˜ (í‰ê· : 8.3/10)**

| ë¶€ë¬¸ | ì ìˆ˜ | ì½”ë©˜íŠ¸ |
|------|------|--------|
| 1. Architecture | 8/10 | Input ì²˜ë¦¬ ë¶„ë¦¬ í•„ìš” |
| 2. Readability | 9/10 | ê±°ì˜ ì™„ë²½ |
| 3. Performance | 8/10 | ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë³µ í˜¸ì¶œ, Tuple GC |
| 4. Gameplay Logic | 10/10 | ì™„ë²½ |
| 5. Unity Best Practices | 8/10 | Magic number, Tooltip ì¶”ê°€ |
| 6. Animation/FSM/BT | 10/10 | ì™„ë²½ |
| 7. Safety | 6/10 | Null ì²´í¬ ë¶€ì¡± |
| 8. Scalability | 10/10 | ì™„ë²½ |
| 9. Clean Code | 8/10 | ë„¤ì„ìŠ¤í˜ì´ìŠ¤, public í•„ë“œ |

---

### **ğŸ”´ ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (High Priority)**

**1. AnimationController ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€**
```csharp
public class AnimationController : MonoBehaviour
{
    PlayerState currentState = PlayerState.IDLE;
    int currentIndex = -1;
    
    public float PlayStateAnimation(PlayerState state)
    {
        int index = this.selectType == AnimationSelectType.First ? 0 : GetRandomIndex(state);
        
        // âœ… ì¤‘ë³µ ë°©ì§€
        if (currentState == state && currentIndex == index)
            return _prefabs.GetClipTime(state, index);
        
        _prefabs.PlayAnimation(state, index);
        currentState = state;
        currentIndex = index;
        return _prefabs.GetClipTime(state, index);
    }
}
```

**2. Null ì•ˆì „ì„± ì¶”ê°€**
```csharp
void Awake()
{
    if (!TryGetComponent(out rb))
    {
        Debug.LogError($"Rigidbody2D missing on {gameObject.name}");
        enabled = false;
        return;
    }
    
    var statsContainer = GetComponentInChildren<StatsContainer>();
    if (statsContainer == null || statsContainer.stats == null)
    {
        Debug.LogError($"Stats missing on {gameObject.name}");
        enabled = false;
        return;
    }
    stats = statsContainer.stats;
}
```

**3. Logger ë§¤ í”„ë ˆì„ í˜¸ì¶œ ì œê±°**
```csharp
void FixedUpdate()
{
    var (selectorResult, actionPath) = selectorRoot.Evaluate();
    
#if UNITY_EDITOR
    if (Logger.DEBUG)
        Logger.Write($"BT: {selectorResult}, {actionPath}");
#endif
}
```

---

### **ğŸŸ¡ ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Medium Priority)**

**1. Input ì²˜ë¦¬ ë¶„ë¦¬**
```csharp
// PlayerInputHandler.cs
public class PlayerInputHandler : MonoBehaviour
{
    [SerializeField] PlayerBehavior behavior;
    [SerializeField] AttackSystem attackSystem;
    [SerializeField] LayerMask enemyLayer;
    
    public void OnMove(InputValue value) => behavior.SetMoveInput(value.Get<float>());
    public void OnJump(InputValue value) => behavior.SetJumpInput(value.isPressed);
    public void OnAttack(InputValue value) => attackSystem.ExecuteAttack(0, transform, enemyLayer);
}
```

**2. Magic Number ìƒìˆ˜í™”**
```csharp
public class EnemyBehavior : MonoBehaviour
{
    [SerializeField, Tooltip("ì§€ìƒ ì²´í¬ ì˜¤í”„ì…‹")]
    float groundCheckOffset = 0.05f;
    
    // CheckFlipDirection()ì—ì„œ ì‚¬ìš©
    pos.x += direction * (ctx.colliderGround.size.x + groundCheckOffset);
}
```

**3. ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì¶”ê°€**
```csharp
namespace ProjectMagic.Player
{
    public class PlayerBehavior : MonoBehaviour { }
}

namespace ProjectMagic.Enemy
{
    public class EnemyBehavior : MonoBehaviour { }
}
```

---

### **ğŸŸ¢ Best Parts (ì¥ì  3ê°€ì§€)**

**1. ì…ë ¥ ìŠ¤ëƒ…ìƒ· ì‹œìŠ¤í…œ** â­â­â­â­â­
```csharp
void FixedUpdate()
{
    _snapShotMoveInput = _moveInput; // Update/FixedUpdate ë¶„ë¦¬ ì™„ë²½
    _snapShotjumpInput = _jumpInput;
    UpdateYState();
    UpdateXState();
}
```
â†’ **ì—…ê³„ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤ ìˆ˜ì¤€**

**2. ìƒíƒœ ë²„í¼ ì‹œìŠ¤í…œ** â­â­â­â­â­
```csharp
Queue<PlayerState> bufferXState;
Queue<PlayerState> bufferYState;

void UpdateXState()
{
    while (bufferXState.Count > 0) // ì´ë²¤íŠ¸ ì¤‘ ìƒíƒœ ë³€ê²½ ì•ˆì „
    {
        var newState = bufferXState.Dequeue();
        ChangeState(ref currentXState, newState);
    }
}
```
â†’ **ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€ ì™„ë²½**

**3. ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ ê¸°ë°˜ ìƒíƒœ ì „í™˜** â­â­â­â­â­
```csharp
var clipTime = ctx.animController.PlayStateAnimation(PlayerState.ATTACK);
ctx._attackRecoveryTimer = clipTime; // ì• ë‹ˆë©”ì´ì…˜ê³¼ ì½”ë“œ ì™„ë²½ ë™ê¸°í™”
```
â†’ **Animation Event ì—†ì´ ìë™í™”**

---

## **ğŸ’¯ ìµœì¢… ì´í‰**

**ì¢…í•© ì ìˆ˜: 8.3 / 10** (ìƒê¸‰)

**ê°•ì :**
- âœ… FSM/BT ì„¤ê³„ ìš°ìˆ˜
- âœ… ì…ë ¥ ì²˜ë¦¬ ì•ˆì •ì„± ì™„ë²½
- âœ… ìƒíƒœ ë²„í¼ ì‹œìŠ¤í…œ í˜ì‹ ì 
- âœ… ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™” ìë™í™”
- âœ… í™•ì¥ì„± ë›°ì–´ë‚¨

**ì•½ì :**
- âš ï¸ Null ì•ˆì „ì„± ë¶€ì¡± (6/10)
- âš ï¸ ì• ë‹ˆë©”ì´ì…˜ ì¤‘ë³µ í˜¸ì¶œ (ì„±ëŠ¥)
- âš ï¸ Magic number ì¡´ì¬

**ë©´ì ‘ ì–´í•„:**
> "FSMê³¼ BTë¥¼ í™œìš©í•œ ìƒíƒœ ê´€ë¦¬ ì‹œìŠ¤í…œì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. íŠ¹íˆ ì…ë ¥ ìŠ¤ëƒ…ìƒ·ê³¼ ìƒíƒœ ë²„í¼ ì‹œìŠ¤í…œìœ¼ë¡œ Update/FixedUpdate íƒ€ì´ë° ì°¨ì´ì™€ ì´ë²¤íŠ¸ ì¤‘ ìƒíƒœ ì¶©ëŒ ë¬¸ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤. ì• ë‹ˆë©”ì´ì…˜ ê¸¸ì´ë¥¼ ë°˜í™˜ë°›ì•„ Animation Event ì—†ì´ ìƒíƒœ ì „í™˜ì„ ìë™í™”í–ˆê³ , X/Yì¶• ë…ë¦½ ìƒíƒœ ê´€ë¦¬ë¡œ ì í”„ ì¤‘ ê³µê²©, ê³µì¤‘ ì´ë™ ë“± ë³µì¡í•œ ì¡°ì‘ì´ ìì—°ìŠ¤ëŸ½ê²Œ êµ¬í˜„ë©ë‹ˆë‹¤."

**ì‹¤ë¬´ íˆ¬ì…:** âœ… ì¦‰ì‹œ ê°€ëŠ¥ (Null ì²´í¬ë§Œ ì¶”ê°€í•˜ë©´ ì™„ë²½)

**ì½”ë“œ í’ˆì§ˆ:** ìƒê¸‰ ~ ìµœìƒê¸‰ ìˆ˜ì¤€ ğŸš€