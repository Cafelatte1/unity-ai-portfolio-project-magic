# Unity C# ì½”ë“œ í’ˆì§ˆ í‰ê°€ ë³´ê³ ì„œ

**í‰ê°€ì¼ì‹œ:** 2025-12-04 14:36  
**í”„ë¡œì íŠ¸:** project-magic (2D Platformer Game)  
**Unity ë²„ì „:** 6000.0.61f1  
**í‰ê°€ ë²”ìœ„:** Assets/Scripts í´ë”ì˜ í•µì‹¬ ë¡œì§  

---

## ğŸ“Œ 1. Architecture & Unity Component Design

**ì ìˆ˜: 7.0/10**

### âœ… ì¥ì 
- **FSMê³¼ BehaviorTree êµ¬ì¡°ê°€ ëª…í™•í•˜ê²Œ ë¶„ë¦¬ë˜ì–´ ìˆìŒ**
  - `FSMNode` ì¶”ìƒ í´ë˜ìŠ¤ë¡œ í”Œë ˆì´ì–´ ìƒíƒœ ê´€ë¦¬
  - `BTNode` ì¸í„°í˜ì´ìŠ¤ë¡œ ì  AI ê´€ë¦¬
  - ê°ê°ì˜ ì‚¬ìš© ì‚¬ë¡€ì— ì í•©í•œ íŒ¨í„´ ì„ íƒ

- **SRP ì¤€ìˆ˜ê°€ ë¹„êµì  ì–‘í˜¸**
  - `HealthSystem`, `AttackSystem`, `AnimationController`ë¡œ ì±…ì„ ë¶„ë¦¬
  - ê° ì‹œìŠ¤í…œì´ ë…ë¦½ì ìœ¼ë¡œ ë™ì‘ ê°€ëŠ¥

- **ScriptableObject í™œìš©**
  - `CharacterStats`, `SkillData`ë¡œ ë°ì´í„° ê¸°ë°˜ ì„¤ê³„
  - ëŸ°íƒ€ì„ ë³€ê²½ ì—†ì´ ë°¸ëŸ°ìŠ¤ ì¡°ì • ê°€ëŠ¥

### âš ï¸ ë¬¸ì œì 
1. **PlayerBehaviorì˜ ì±…ì„ ê³¼ë‹¤**
   - ìƒíƒœ ê´€ë¦¬ + ì…ë ¥ ì²˜ë¦¬ + ë¬¼ë¦¬ ì²˜ë¦¬ë¥¼ ëª¨ë‘ ë‹´ë‹¹
   - Xì¶•/Yì¶• ìƒíƒœë¥¼ ë¶„ë¦¬í–ˆì§€ë§Œ ì—¬ì „íˆ í•˜ë‚˜ì˜ í´ë˜ìŠ¤ì— ì§‘ì¤‘

2. **Compositionë³´ë‹¤ ìƒì†ì— ì˜ì¡´**
   ```csharp
   // PlayerAttack.cs - ê±°ì˜ ë¹ˆ í´ë˜ìŠ¤
   public class PlayerAttack : AttackSystem
   {
       protected override void Start() { base.Start(); }
   }
   ```
   - ë‹¨ìˆœ ìƒì†ë§Œìœ¼ë¡œ í•´ê²°í•˜ë ¤ëŠ” ê²½í–¥
   - ì»´í¬ì§€ì…˜ íŒ¨í„´ í™œìš© ë¶€ì¡±

3. **Unity ìƒëª…ì£¼ê¸° ë©”ì„œë“œ ì‚¬ìš© ì ì ˆì„±**
   - `FixedUpdate`ì—ì„œ ì…ë ¥ ìŠ¤ëƒ…ìƒ·ë§Œ ì²˜ë¦¬ (ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ ì—†ìŒ)
   ```csharp
   void FixedUpdate()
   {
       _snapShotMoveInput = _moveInput;
       _snapShotjumpInput = _jumpInput;
       // ë¬¼ë¦¬ ì²˜ë¦¬ëŠ” Stateì˜ Update()ì—ì„œ ìˆ˜í–‰ë¨
   }
   ```
   - ë¬¼ë¦¬ ê´€ë ¨ ì½”ë“œê°€ Stateì˜ `Update()`ì—ì„œ ì‹¤í–‰ë˜ì–´ í”„ë ˆì„ ì˜ì¡´ì 

### ğŸ’¡ ê°œì„ ì•ˆ
1. **InputHandler ë¶„ë¦¬**
   ```csharp
   public class InputHandler : MonoBehaviour
   {
       public Vector2 MoveInput { get; private set; }
       public bool JumpInput { get; private set; }
       
       void Update()
       {
           MoveInput = /* Input System */;
           JumpInput = /* Input System */;
       }
   }
   ```

2. **ë¬¼ë¦¬ ì²˜ë¦¬ë¥¼ FixedUpdateë¡œ ì´ë™**
   - State íŒ¨í„´ ìœ ì§€í•˜ë˜, ë¬¼ë¦¬ ì—…ë°ì´íŠ¸ëŠ” FixedUpdateì—ì„œ ì¼ê´€ë˜ê²Œ ì²˜ë¦¬

---

## ğŸ“Œ 2. Code Readability & Maintainability

**ì ìˆ˜: 7.5/10**

### âœ… ì¥ì 
- **ë„¤ì´ë° ê·œì¹™ ì¼ê´€ì„± ìš°ìˆ˜**
  - PascalCase (í´ë˜ìŠ¤, ë©”ì„œë“œ)
  - camelCase (ì§€ì—­ ë³€ìˆ˜)
  - _camelCase (private í•„ë“œ)
  - ì¼ê´€ëœ ê·œì¹™ ì ìš©

- **í´ë” êµ¬ì¡°ê°€ ëª…í™•**
  ```
  Player/ Enemy/ Common/ Core/ Skills/ Utils/
  ```
  - ê¸°ëŠ¥ë³„ ë¶„ë¥˜ê°€ ì§ê´€ì 

### âš ï¸ ë¬¸ì œì 
1. **ë„ˆë¬´ í° ë©”ì„œë“œë“¤**
   ```csharp
   // EnemyBehavior.BuildStateController() - 88ì¤„
   void BuildStateController()
   {
       // Patrol Action
       var patrolAction = new ActionPatrol(this);
       // ... 80+ lines of BT construction
   }
   ```
   - ê°€ë…ì„± ì €í•˜
   - í…ŒìŠ¤íŠ¸ ë° ìœ ì§€ë³´ìˆ˜ ì–´ë ¤ì›€

2. **ì£¼ì„ ë¶€ì¡±**
   - ë³µì¡í•œ ë¡œì§ì— ëŒ€í•œ ì„¤ëª… ì—†ìŒ
   - XML ë¬¸ì„œí™” ì£¼ì„ ë¯¸ì‚¬ìš©

3. **í•˜ë“œì½”ë”©ëœ ìƒìˆ˜**
   ```csharp
   // ObjectPool.cs
   if (pool.Count > 0)  // 0ì€ ë§¤ì§ ë„˜ë²„
   ```

### ğŸ’¡ ê°œì„ ì•ˆ
1. **ë©”ì„œë“œ ë¶„í•´**
   ```csharp
   void BuildStateController()
   {
       selectorRoot = new SelectorNode(new List<BTNode>
       {
           BuildDeathSequence(),
           BuildDamagedSequence(),
           BuildAttackSequence(),
           BuildChaseSequence(),
           BuildPatrolSequence()
       });
   }
   
   private SequenceNode BuildDeathSequence() { /* ... */ }
   private SequenceNode BuildAttackSequence() { /* ... */ }
   ```

2. **XML ë¬¸ì„œí™” ì¶”ê°€**
   ```csharp
   /// <summary>
   /// ìºë¦­í„°ì˜ ì²´ë ¥ì„ ê´€ë¦¬í•˜ê³  ë°ë¯¸ì§€/ì‚¬ë§ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.
   /// </summary>
   public class HealthSystem : MonoBehaviour
   ```

---

## ğŸ“Œ 3. Performance & Memory Efficiency

**ì ìˆ˜: 6.5/10**

### âœ… ì¥ì 
- **ObjectPool êµ¬í˜„**
  - ìŠ¤í‚¬ ë°œì‚¬ì²´ ì¬ì‚¬ìš©ìœ¼ë¡œ GC ë¶€ë‹´ ê°ì†Œ
  - Genericìœ¼ë¡œ ë²”ìš©ì„± í™•ë³´

- **Component ìºì‹±**
  ```csharp
  void Awake()
  {
      rb = GetComponent<Rigidbody2D>();
      animController = GetComponent<AnimationController>();
  }
  ```

### âš ï¸ ë¬¸ì œì 
1. **ObjectPoolì˜ ì‹¬ê°í•œ ë²„ê·¸**
   ```csharp
   public T Get()
   {
       if (pool.Count > 0)
       {
           var obj = pool.Dequeue();
           return obj;
       }
       else
       {
           var obj = GameObject.Instantiate(prefab, ...);
           pool.Enqueue(obj);  // âŒ ì¦‰ì‹œ ë‹¤ì‹œ Enqueue!
           return obj;
       }
   }
   ```
   - ìƒˆë¡œ ìƒì„±í•œ ê°ì²´ë¥¼ ì¦‰ì‹œ í’€ì— ë°˜í™˜í•˜ëŠ” ì¹˜ëª…ì  ì˜¤ë¥˜
   - í’€ í¬ê¸°ê°€ ê³„ì† ì¦ê°€í•˜ê³  ê°™ì€ ê°ì²´ê°€ ì¤‘ë³µ ì‚¬ìš©ë  ìœ„í—˜

2. **Update()ì—ì„œ ë¶ˆí•„ìš”í•œ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸**
   ```csharp
   // PlayerBehavior.Update()
   void Update()
   {
       _attackRecoveryTimer -= Time.deltaTime;
       _hitRecoveryTimer -= Time.deltaTime;
       TickUpdate();
   }
   ```
   - ë§¤ í”„ë ˆì„ íƒ€ì´ë¨¸ ê°ì†Œ (ìƒíƒœ ê´€ê³„ì—†ì´)
   - ì¡°ê±´ë¶€ ì—…ë°ì´íŠ¸ë¡œ ê°œì„  ê°€ëŠ¥

3. **Boxing ê°€ëŠ¥ì„±**
   ```csharp
   Logger.Write($"XState changed from={fromXState.ToString()}");
   ```
   - enumì˜ ToString()ì€ ë°•ì‹± ë°œìƒ
   - ìì£¼ í˜¸ì¶œë˜ëŠ” Debug ë¡œê·¸ì—ì„œ GC ì••ë°•

4. **Physics2D.OverlapCircle ë§¤ í”„ë ˆì„ í˜¸ì¶œ**
   ```csharp
   // AttackSystem.ExecuteMeleeAttack()
   Collider2D hit = Physics2D.OverlapCircle(attackBox, hitAreaRadius, targetLayerMask);
   ```
   - ê³µê²© ì‹œì—ë§Œ í˜¸ì¶œë˜ì§€ë§Œ, NonAlloc ë²„ì „ ê³ ë ¤ í•„ìš”

### ğŸ’¡ ê°œì„ ì•ˆ
1. **ObjectPool ë²„ê·¸ ìˆ˜ì •**
   ```csharp
   public T Get()
   {
       if (pool.Count > 0)
       {
           return pool.Dequeue();
       }
       else
       {
           return GameObject.Instantiate(prefab, Vector3.zero, Quaternion.identity, parent);
       }
   }
   ```

2. **íƒ€ì´ë¨¸ ìµœì í™”**
   ```csharp
   void Update()
   {
       if (_attackRecoveryTimer > 0)
           _attackRecoveryTimer -= Time.deltaTime;
       if (_hitRecoveryTimer > 0)
           _hitRecoveryTimer -= Time.deltaTime;
   }
   ```

3. **Physics NonAlloc ì‚¬ìš©**
   ```csharp
   private Collider2D[] _hitResults = new Collider2D[10];
   
   int hitCount = Physics2D.OverlapCircleNonAlloc(
       attackBox, hitAreaRadius, _hitResults, targetLayerMask
   );
   ```

---

## ğŸ“Œ 4. Gameplay Logic & Stability

**ì ìˆ˜: 7.0/10**

### âœ… ì¥ì 
- **ì…ë ¥ ë²„í¼ë§ ì‹œìŠ¤í…œ**
   ```csharp
   private Queue<PlayerState> bufferXState;
   private Queue<PlayerState> bufferYState;
   ```
   - ì…ë ¥ ì†ì‹¤ ë°©ì§€
   - ë°˜ì‘ì„± í–¥ìƒ

- **ìŠ¤ëƒ…ìƒ· ì…ë ¥ ì²˜ë¦¬**
   ```csharp
   void FixedUpdate()
   {
       _snapShotMoveInput = _moveInput;
       _snapShotjumpInput = _jumpInput;
   }
   ```
   - í”„ë ˆì„ ê°„ ì…ë ¥ ì¼ê´€ì„± ë³´ì¥

### âš ï¸ ë¬¸ì œì 
1. **ë¬´ì  ì‹œê°„ ì¤‘ ë™ì‹œì„± ë¬¸ì œ ê°€ëŠ¥ì„±**
   ```csharp
   // HealthSystem.cs
   if (isInvincible || currentHealth <= 0) return;
   
   currentHealth = Mathf.Max(0, currentHealth - finalDamage);
   isInvincible = true;
   invincibleTimer = stats.invincibilityDuration;
   ```
   - ë¬´ì  íƒ€ì´ë¨¸ê°€ 0ì´ ë˜ê¸° ì „ì— ì—¬ëŸ¬ ê³µê²©ì´ ë™ì‹œì— ë“¤ì–´ì˜¬ ê²½ìš° ì²˜ë¦¬ ë¯¸í¡

2. **Ground Check ì‹ ë¢°ì„±**
   ```csharp
   bool CheckGrounded()
   {
       colliderGround = Physics2D.OverlapBox(...);
       return colliderGround != null;
   }
   ```
   - ë‹¨ìˆœ null ì²´í¬ë§Œìœ¼ë¡œ ì ‘ì§€ íŒë‹¨
   - ê²½ì‚¬ë©´, ëª¨ì„œë¦¬ ë“± ì—£ì§€ ì¼€ì´ìŠ¤ ì²˜ë¦¬ ì—†ìŒ

3. **ìƒíƒœ ì „ì´ ì¤‘ ë¬¼ë¦¬ ì¶©ëŒ**
   ```csharp
   // StateMove.cs
   private void UpdateVelocity()
   {
       Vector2 velocity = ctx.rb.linearVelocity;
       velocity.x = ctx._snapShotMoveInput * ctx.stats.moveSpeed;
       ctx.rb.linearVelocity = velocity;  // ì§ì ‘ velocity ìˆ˜ì •
   }
   ```
   - velocity ì§ì ‘ ìˆ˜ì • ëŒ€ì‹  force ì‚¬ìš© ê³ ë ¤ í•„ìš”

4. **ê³µê²© ì¤‘ ì´ë™ ì œí•œ ë¶€ì¬**
   ```csharp
   // StateAttackì—ì„œ ì´ë™ ì…ë ¥ ë¬´ì‹œ ë¡œì§ ì—†ìŒ
   ```

### ğŸ’¡ ê°œì„ ì•ˆ
1. **ê³µê²© ì¤‘ ì´ë™ ì œí•œ**
   ```csharp
   class StateAttack : FSMNode
   {
       public override void Update()
       {
           if (ctx._attackRecoveryTimer > 0)
           {
               // ê³µê²© ì¤‘ì—ëŠ” ì´ë™ ì…ë ¥ ë¬´ì‹œ
               Vector2 velocity = ctx.rb.linearVelocity;
               velocity.x = 0;
               ctx.rb.linearVelocity = velocity;
           }
       }
   }
   ```

2. **Ground Check ê°œì„ **
   ```csharp
   bool CheckGrounded()
   {
       int hitCount = Physics2D.OverlapBoxNonAlloc(
           groundCheckPos, groundBoxSize, 0f, _groundResults, layerGround
       );
       return hitCount > 0 && rb.linearVelocity.y <= 0.1f;
   }
   ```

---

## ğŸ“Œ 5. Unity-Engine Best Practices

**ì ìˆ˜: 7.5/10**

### âœ… ì¥ì 
- **Component ìºì‹± ì² ì €**
   ```csharp
   void Awake()
   {
       rb = GetComponent<Rigidbody2D>();
       healthSystem = GetComponent<HealthSystem>();
       attackSystem = GetComponent<AttackSystem>();
   }
   ```

- **SerializeField ì ì ˆí•œ ì‚¬ìš©**
   ```csharp
   [Header("Ground Detection")]
   [SerializeField] private Vector2 groundBoxSize;
   [SerializeField] private float groundDistance;
   ```

- **Time.deltaTime ê¸°ë°˜ ë³´ì •**
   ```csharp
   _attackRecoveryTimer -= Time.deltaTime;
   invincibleTimer -= Time.deltaTime;
   ```

### âš ï¸ ë¬¸ì œì 
1. **ì¼ë¶€ public í•„ë“œ ë…¸ì¶œ**
   ```csharp
   // PlayerBehavior.cs
   public CharacterStats stats;  // SerializeField privateìœ¼ë¡œ ë³€ê²½ í•„ìš”
   public Rigidbody2D rb;
   ```

2. **Magic Number ì¡´ì¬**
   ```csharp
   // PlayerBehavior.cs
   [SerializeField] private float landingVelocityMargin = 0.2f;
   
   // í•˜ì§€ë§Œ ì½”ë“œ ë‚´ì—ì„œ ì§ì ‘ ì‚¬ìš©:
   if (rb.linearVelocity.y <= landingVelocityMargin)
   ```
   - ì¼ë¶€ ìƒìˆ˜ëŠ” SerializeFieldë¡œ ë…¸ì¶œí–ˆìœ¼ë‚˜, ì—¬ì „íˆ í•˜ë“œì½”ë”©ëœ ê°’ë“¤ ì¡´ì¬

3. **Rigidbodyì™€ Transform í˜¼ìš©**
   ```csharp
   // StateMove.cs
   Vector3 scale = ctx.transform.localScale;
   scale.x = /* ... */;
   ctx.transform.localScale = scale;  // Transform ì§ì ‘ ìˆ˜ì •
   
   ctx.rb.linearVelocity = velocity;  // Rigidbody ì‚¬ìš©
   ```
   - ë°©í–¥ ì „í™˜ì€ Transform, ì´ë™ì€ Rigidbody
   - ì¼ê´€ì„± ìˆëŠ” ì ‘ê·¼ í•„ìš”

### ğŸ’¡ ê°œì„ ì•ˆ
1. **Public í•„ë“œ ìº¡ìŠí™”**
   ```csharp
   [SerializeField] private CharacterStats stats;
   [SerializeField] private Rigidbody2D rb;
   
   public CharacterStats Stats => stats;  // readonly ì ‘ê·¼ë§Œ ì œê³µ
   ```

2. **ìƒìˆ˜ ì •ì˜**
   ```csharp
   public static class PhysicsConstants
   {
       public const float LANDING_VELOCITY_THRESHOLD = 0.2f;
       public const float GROUND_CHECK_MARGIN = 0.1f;
   }
   ```

---

## ğŸ“Œ 6. Animation, FSM/BT, Event Flow

**ì ìˆ˜: 8.0/10**

### âœ… ì¥ì  (Best Parts!)
- **FSM êµ¬ì¡°ê°€ ê¹”ë”**
   ```csharp
   public abstract class FSMNode
   {
       public abstract void OnEnter();
       public abstract void Update();
       public abstract void OnExit();
   }
   ```
   - ëª…í™•í•œ ìƒëª…ì£¼ê¸°
   - í™•ì¥ì„± ìš°ìˆ˜

- **BehaviorTree êµ¬í˜„ì´ ìš°ìˆ˜**
   ```csharp
   public interface BTNode
   {
       public enum State { Running, Success, Failure }
       EvaluateResult Evaluate();
   }
   ```
   - Selector, Sequence, Action ë…¸ë“œ ë¶„ë¦¬
   - ë³µì¡í•œ AI ë¡œì§ì„ ì„ ì–¸ì ìœ¼ë¡œ í‘œí˜„

- **Event ê¸°ë°˜ í†µì‹ **
   ```csharp
   public UnityEvent<Vector2> EventHit;
   public UnityEvent EventDeath;
   
   // ì‚¬ìš©
   EventHit?.Invoke(knockbackDirection);
   ```
   - ëŠìŠ¨í•œ ê²°í•©
   - í™•ì¥ ìš©ì´

- **AnimationController ëœë¤/ìˆœì°¨ ì„ íƒ**
   ```csharp
   public enum AnimationSelectType { Sequential, Random }
   [SerializeField] private AnimationSelectType selectType;
   ```
   - ì• ë‹ˆë©”ì´ì…˜ ë‹¤ì–‘ì„± í™•ë³´

### âš ï¸ ë¬¸ì œì 
1. **Animatorì™€ ì½”ë“œ ìƒíƒœ ë™ê¸°í™” ëª…í™•í•˜ì§€ ì•ŠìŒ**
   ```csharp
   ctx.animController.PlayStateAnimation(PlayerState.MOVE);
   ```
   - Animator Controllerì˜ ìƒíƒœì™€ ì½”ë“œì˜ PlayerStateê°€ ì–´ë–»ê²Œ ë§¤í•‘ë˜ëŠ”ì§€ ë¶ˆëª…í™•
   - ì• ë‹ˆë©”ì´ì…˜ ì´ë²¤íŠ¸ ì‚¬ìš© ì—¬ë¶€ ë¶ˆëª…í™•

2. **ê³µê²© ì¤‘ ì›€ì§ì„ ë¬¸ì œ**
   - StateAttackì—ì„œ ì´ë™ ì œí•œ ë¡œì§ ì—†ìŒ
   - Root Motion ì‚¬ìš© ì—¬ë¶€ ë¶ˆëª…í™•

### ğŸ’¡ ê°œì„ ì•ˆ
1. **Animator Parameter Hash ì‚¬ìš©**
   ```csharp
   private static readonly int PARAM_MOVE = Animator.StringToHash("Move");
   private static readonly int PARAM_ATTACK = Animator.StringToHash("Attack");
   
   animator.SetBool(PARAM_MOVE, true);  // ë¬¸ìì—´ ë¹„êµ ì—†ìŒ
   ```

---

## ğŸ“Œ 7. Safety & Error Handling

**ì ìˆ˜: 6.0/10**

### âœ… ì¥ì 
- **ì¼ë¶€ null ì²´í¬**
   ```csharp
   if (hit != null)
   {
       if (hit.TryGetComponent<HealthSystem>(out HealthSystem targetHealthSystem))
   ```

- **TryGetComponent í™œìš©**
   - GetComponent ëŒ€ì‹  ì•ˆì „í•œ ë°©ë²• ì‚¬ìš©

### âš ï¸ ë¬¸ì œì 
1. **Component ì°¸ì¡° null ì²´í¬ ë¶€ì¡±**
   ```csharp
   void Awake()
   {
       rb = GetComponent<Rigidbody2D>();
       animController = GetComponent<AnimationController>();
       // null ì²´í¬ ì—†ìŒ - ì»´í¬ë„ŒíŠ¸ ëˆ„ë½ ì‹œ ëŸ°íƒ€ì„ ì—ëŸ¬
   }
   ```

2. **ê²½ê³„ ì²´í¬ ë¯¸í¡**
   ```csharp
   // ObjectPool.Get(int n) - nì´ ìŒìˆ˜ì´ê±°ë‚˜ ë§¤ìš° í° ê°’ì¼ ê²½ìš° ì²˜ë¦¬ ì—†ìŒ
   public List<T> Get(int n)
   {
       List<T> objs = new List<T>();
       for (int i=0; i<n; i++)  // n ê²€ì¦ ì—†ìŒ
   ```

3. **ì´ˆê¸°í™” ìˆœì„œ ë¬¸ì œ ê°€ëŠ¥ì„±**
   ```csharp
   // Awakeì—ì„œ GetComponent
   // Startì—ì„œ ë‹¤ë¥¸ ì‹œìŠ¤í…œ ì ‘ê·¼
   // - ì´ˆê¸°í™” ìˆœì„œì— ì˜ì¡´ì 
   ```

4. **ì˜ˆì™¸ ì²˜ë¦¬ ë¶€ì¬**
   ```csharp
   // SkillLogic.Init() - ë§¤ê°œë³€ìˆ˜ ê²€ì¦ ì—†ìŒ
   public virtual void Init(
       AttackContainer attack,
       Transform origin,
       // ... ë§ì€ ë§¤ê°œë³€ìˆ˜
   )
   {
       this.attack = attack;  // null ê°€ëŠ¥ì„±
   ```

### ğŸ’¡ ê°œì„ ì•ˆ
1. **Required Component & Null ê²€ì¦**
   ```csharp
   [RequireComponent(typeof(Rigidbody2D))]
   [RequireComponent(typeof(AnimationController))]
   public class PlayerBehavior : MonoBehaviour
   {
       void Awake()
       {
           rb = GetComponent<Rigidbody2D>();
           if (rb == null)
               Logger.Write("Rigidbody2D not found!", "ERROR");
           
           animController = GetComponent<AnimationController>();
           if (animController == null)
               Logger.Write("AnimationController not found!", "ERROR");
       }
   }
   ```

2. **ë§¤ê°œë³€ìˆ˜ ê²€ì¦**
   ```csharp
   public List<T> Get(int n)
   {
       if (n <= 0)
       {
           Logger.Write($"Invalid pool request count: {n}", "WARNING");
           return new List<T>();
       }
       
       List<T> objs = new List<T>(n);  // capacity ì§€ì •
       // ...
   }
   ```

3. **Guard Clauses ì‚¬ìš©**
   ```csharp
   public virtual void TakeDamage(float rawDamage, Vector2 knockbackDirection = default)
   {
       if (isInvincible)
       {
           Logger.Write("Damage ignored - invincible", "DEBUG");
           return;
       }
       
       if (currentHealth <= 0)
       {
           Logger.Write("Damage ignored - already dead", "DEBUG");
           return;
       }
       
       // ì‹¤ì œ ë°ë¯¸ì§€ ì²˜ë¦¬
   }
   ```

---

## ğŸ“Œ 8. Scalability / Extensibility

**ì ìˆ˜: 7.5/10**

### âœ… ì¥ì 
- **ScriptableObject ê¸°ë°˜ ë°ì´í„°**
   ```csharp
   [CreateAssetMenu(fileName = "CharacterStats", menuName = "Stats/Character")]
   public class CharacterStats : ScriptableObject
   ```
   - ìƒˆ ìºë¦­í„° ì¶”ê°€ ì‹œ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”
   - ë°ì´í„° ê¸°ë°˜ í™•ì¥ ê°€ëŠ¥

- **FSM/BTì˜ ë…¸ë“œ ê¸°ë°˜ êµ¬ì¡°**
   - ìƒˆë¡œìš´ ìƒíƒœ/í–‰ë™ ì¶”ê°€ ìš©ì´
   ```csharp
   class StateNewAbility : FSMNode { /* ... */ }
   ```

- **AttackSystemì˜ AttackType enum**
   ```csharp
   public enum AttackType { Melee, Range, Custom }
   ```
   - ìƒˆë¡œìš´ ê³µê²© ìœ í˜• ì¶”ê°€ ê°€ëŠ¥

- **Generic ObjectPool**
   ```csharp
   public class ObjectPool<T> where T : MonoBehaviour
   ```
   - ëª¨ë“  MonoBehaviourì— ì¬ì‚¬ìš© ê°€ëŠ¥

### âš ï¸ ë¬¸ì œì 
1. **Hard-coded State Transitions**
   ```csharp
   switch (currentXState)
   {
       case PlayerState.DEATH:
           break;
       case PlayerState.DAMAGED:
           ChangeState(ref currentXState, PlayerState.IDLE);
           break;
       // ... í•˜ë“œì½”ë”©ëœ ì „ì´ ê·œì¹™
   }
   ```
   - ìƒíƒœ ì „ì´ ê·œì¹™ì´ ì½”ë“œì— ë°•í˜€ ìˆìŒ
   - ìƒˆ ìƒíƒœ ì¶”ê°€ ì‹œ ì—¬ëŸ¬ ê³³ ìˆ˜ì • í•„ìš”

2. **ìŠ¤í‚¬ ì‹œìŠ¤í…œ í™•ì¥ì„± ì œí•œ**
   ```csharp
   // PlayerBehavior.cs
   public void OnSkillW(InputAction.CallbackContext context) { /* ... */ }
   public void OnSkillE(InputAction.CallbackContext context) { /* ... */ }
   ```
   - ìŠ¤í‚¬ì´ ëŠ˜ì–´ë‚˜ë©´ ë©”ì„œë“œë„ ëŠ˜ì–´ë‚¨
   - ìŠ¤í‚¬ ë§¤ë‹ˆì €ë¡œ ì¶”ìƒí™” í•„ìš”

3. **Enemy íƒ€ì…ë³„ ì¤‘ë³µ ì½”ë“œ ìš°ë ¤**
   ```csharp
   // BossAlphaBehavior, EnemyBehavior - ìœ ì‚¬í•œ êµ¬ì¡° ë°˜ë³µ
   ```

### ğŸ’¡ ê°œì„ ì•ˆ
1. **State Transition Table**
   ```csharp
   [Serializable]
   public class StateTransition
   {
       public PlayerState from;
       public PlayerState to;
       public Func<bool> condition;
   }
   
   [SerializeField]
   private List<StateTransition> transitions;
   ```

2. **Skill Manager ë„ì…**
   ```csharp
   public class SkillManager : MonoBehaviour
   {
       [SerializeField] private List<SkillSlot> skillSlots;
       
       public void ExecuteSkill(int slotIndex)
       {
           if (slotIndex < skillSlots.Count)
               skillSlots[slotIndex].Execute();
       }
   }
   ```

3. **Enemy Base Class ê°•í™”**
   ```csharp
   public abstract class EnemyBase : MonoBehaviour
   {
       protected abstract void BuildBehaviorTree();
       protected virtual void OnStateChanged() { }
   }
   ```

---

## ğŸ“Œ 9. Clean Code Practices

**ì ìˆ˜: 7.0/10**

### âœ… ì¥ì 
- **ë„¤ì´ë° ì¼ê´€ì„± ìš°ìˆ˜**
  - í´ë˜ìŠ¤ëª…, ë©”ì„œë“œëª…ì´ ì˜ë¯¸ ì „ë‹¬ë ¥ ë†’ìŒ
  - ì•½ì–´ ì‚¬ìš© ìµœì†Œí™”

- **í´ë” êµ¬ì¡° ì²´ê³„ì **
  ```
  Common/ - ê³µí†µ ì‹œìŠ¤í…œ
  Core/ - í•µì‹¬ í”„ë ˆì„ì›Œí¬
  Player/ Enemy/ - ë„ë©”ì¸ë³„ ë¶„ë¦¬
  Utils/ - ìœ í‹¸ë¦¬í‹°
  ```

- **Logger ìœ í‹¸ë¦¬í‹°**
  ```csharp
  Logger.Write($"Take damaged / finalDamage={finalDamage}");
  ```
  - ë””ë²„ê¹… í¸ì˜ì„±

### âš ï¸ ë¬¸ì œì 
1. **SOLID ì›ì¹™ ì¼ë¶€ ìœ„ë°˜**
   - **SRP ìœ„ë°˜**: PlayerBehaviorê°€ ë„ˆë¬´ ë§ì€ ì±…ì„
   - **OCP ìœ„ë°˜**: ìƒˆ ìƒíƒœ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • í•„ìš”
   - **DIP**: êµ¬ì²´ í´ë˜ìŠ¤ì— ì§ì ‘ ì˜ì¡´

2. **DRY ìœ„ë°˜**
   ```csharp
   // PlayerBehavior, EnemyBehaviorì—ì„œ ìœ ì‚¬í•œ íƒ€ì´ë¨¸ ë¡œì§ ë°˜ë³µ
   _attackRecoveryTimer -= Time.deltaTime;
   _hitRecoveryTimer -= Time.deltaTime;
   ```

3. **ë¶ˆí•„ìš”í•œ public í•„ë“œ**
   ```csharp
   public Rigidbody2D rb;
   public AnimationController animController;
   // private + propertyë¡œ ìº¡ìŠí™” í•„ìš”
   ```

4. **ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë¯¸ì‚¬ìš©**
   - ëª¨ë“  í´ë˜ìŠ¤ê°€ global namespace
   - ì´ë¦„ ì¶©ëŒ ìœ„í—˜

### ğŸ’¡ ê°œì„ ì•ˆ
1. **ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë„ì…**
   ```csharp
   namespace ProjectMagic.Core
   {
       public abstract class FSMNode { }
   }
   
   namespace ProjectMagic.Characters.Player
   {
       public class PlayerBehavior : MonoBehaviour { }
   }
   ```

2. **íƒ€ì´ë¨¸ ìœ í‹¸ë¦¬í‹°**
   ```csharp
   public class CooldownTimer
   {
       private float duration;
       private float remaining;
       
       public bool IsReady => remaining <= 0;
       
       public void Start(float duration)
       {
           this.duration = duration;
           this.remaining = duration;
       }
       
       public void Update(float deltaTime)
       {
           if (remaining > 0)
               remaining -= deltaTime;
       }
   }
   
   // ì‚¬ìš©
   private CooldownTimer attackCooldown = new CooldownTimer();
   attackCooldown.Update(Time.deltaTime);
   ```

3. **Property í™œìš©**
   ```csharp
   public Rigidbody2D Rigidbody => rb;
   public AnimationController AnimController => animController;
   ```

---

## ğŸ“Œ 10. ì¢…í•© í‰ê°€ ë° ìš°ì„ ìˆœìœ„

### ğŸ¯ **ì´ì : 7.0/10**

| í•­ëª© | ì ìˆ˜ | ë¹„ì¤‘ |
|------|------|------|
| Architecture & Design | 7.0 | â­â­â­ |
| Readability & Maintainability | 7.5 | â­â­â­ |
| Performance & Memory | 6.5 | â­â­â­ |
| Gameplay Logic & Stability | 7.0 | â­â­â­ |
| Unity Best Practices | 7.5 | â­â­ |
| Animation & FSM/BT | **8.0** | â­â­â­ |
| Safety & Error Handling | 6.0 | â­â­ |
| Scalability & Extensibility | 7.5 | â­â­â­ |
| Clean Code Practices | 7.0 | â­â­ |

---

### ğŸš¨ **ì¦‰ì‹œ ê°œì„ í•´ì•¼ í•  ë¶€ë¶„ (High Priority)**

#### 1. **ObjectPool.Get() ë²„ê·¸ ìˆ˜ì •** âš ï¸âš ï¸âš ï¸
**ì‹¬ê°ë„: CRITICAL**
```csharp
// í˜„ì¬ ì½”ë“œ (ë²„ê·¸)
else
{
    var obj = GameObject.Instantiate(prefab, Vector3.zero, Quaternion.identity, parent);
    pool.Enqueue(obj);  // âŒ ìƒˆ ê°ì²´ë¥¼ ì¦‰ì‹œ í’€ì— ë°˜í™˜
    return obj;
}

// ìˆ˜ì •
else
{
    return GameObject.Instantiate(prefab, Vector3.zero, Quaternion.identity, parent);
}
```
**ì˜í–¥:** ë©”ëª¨ë¦¬ ëˆ„ìˆ˜, ì˜¤ë¸Œì íŠ¸ ì¤‘ë³µ ì‚¬ìš©, ê²Œì„í”Œë ˆì´ ë²„ê·¸ ë°œìƒ ê°€ëŠ¥

---

#### 2. **Component Null ê²€ì¦ ì¶”ê°€**
**ì‹¬ê°ë„: HIGH**
```csharp
[RequireComponent(typeof(Rigidbody2D))]
[RequireComponent(typeof(HealthSystem))]
[RequireComponent(typeof(AttackSystem))]
public class PlayerBehavior : MonoBehaviour
{
    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        healthSystem = GetComponent<HealthSystem>();
        attackSystem = GetComponent<AttackSystem>();
        
        // ê°œë°œ ì¤‘ ê²€ì¦
        Debug.Assert(rb != null, "Rigidbody2D is required!");
        Debug.Assert(healthSystem != null, "HealthSystem is required!");
    }
}
```
**ì˜í–¥:** ëŸ°íƒ€ì„ ì—ëŸ¬ ì¡°ê¸° ë°œê²¬, ë””ë²„ê¹… ì‹œê°„ ë‹¨ì¶•

---

#### 3. **ë¬¼ë¦¬ ì²˜ë¦¬ë¥¼ FixedUpdateë¡œ ì´ë™**
**ì‹¬ê°ë„: HIGH**
```csharp
// StateMove.cs - í˜„ì¬ëŠ” Update()ì—ì„œ velocity ìˆ˜ì •
// ì´ë¥¼ PlayerBehavior.FixedUpdate()ë¡œ ì´ë™

void FixedUpdate()
{
    if (_hitRecoveryTimer <= 0 && currentXState == PlayerState.MOVE)
    {
        Vector2 velocity = rb.linearVelocity;
        velocity.x = _snapShotMoveInput * stats.moveSpeed;
        rb.linearVelocity = velocity;
    }
}
```
**ì˜í–¥:** ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì•ˆì •ì„± í–¥ìƒ, í”„ë ˆì„ ì˜ì¡´ì„± ì œê±°

---

### ğŸ”§ **ì¤‘ì¥ê¸°ì  ë¦¬íŒ©í† ë§ ì œì•ˆ (Medium Priority)**

#### 1. **PlayerBehavior ì±…ì„ ë¶„ë¦¬**
```csharp
// í˜„ì¬: í•˜ë‚˜ì˜ ê±°ëŒ€í•œ í´ë˜ìŠ¤
PlayerBehavior (419 lines)

// ì œì•ˆ: ì±…ì„ë³„ ë¶„ë¦¬
PlayerController       // ì…ë ¥ ì²˜ë¦¬ + ìƒíƒœ ê´€ë¦¬
PlayerMovement         // ì´ë™ + ë¬¼ë¦¬ ì²˜ë¦¬
PlayerStateMachine     // FSM ë¡œì§
PlayerAnimationBridge  // ì• ë‹ˆë©”ì´ì…˜ ë™ê¸°í™”
```

#### 2. **Skill System ì¶”ìƒí™”**
```csharp
public interface ISkill
{
    string SkillName { get; }
    float Cooldown { get; }
    bool CanExecute();
    void Execute(Transform origin, LayerMask targetMask);
}

public class SkillManager : MonoBehaviour
{
    [SerializeField] private List<ISkill> equippedSkills;
    private Dictionary<KeyCode, int> keyBindings;
    
    public void ExecuteSkill(int slotIndex)
    {
        if (slotIndex < equippedSkills.Count)
        {
            var skill = equippedSkills[slotIndex];
            if (skill.CanExecute())
                skill.Execute(transform, targetLayerMask);
        }
    }
}
```
**ì´ì :** ìŠ¤í‚¬ ì¶”ê°€/ì œê±° ìš©ì´, í•«í‚¤ ì¬ë§¤í•‘ ê°€ëŠ¥, í…ŒìŠ¤íŠ¸ ìš©ì´

#### 3. **ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë„ì… ë° êµ¬ì¡°í™”**
```csharp
namespace ProjectMagic.Core
{
    public abstract class FSMNode { }
    public interface BTNode { }
}

namespace ProjectMagic.Core.Systems
{
    public class HealthSystem { }
    public class AttackSystem { }
}

namespace ProjectMagic.Characters
{
    namespace Player { public class PlayerBehavior { } }
    namespace Enemy { public class EnemyBehavior { } }
}

namespace ProjectMagic.Skills
{
    public abstract class SkillLogic { }
}
```
**ì´ì :** ì½”ë“œ ì¡°ì§í™”, ì´ë¦„ ì¶©ëŒ ë°©ì§€, ê°€ë…ì„± í–¥ìƒ

---

### ğŸ† **Best Parts (ì˜í•œ ì  3ê°€ì§€)**

#### 1. **FSMê³¼ BehaviorTree êµ¬í˜„ í’ˆì§ˆ ìš°ìˆ˜** â­â­â­â­â­
```csharp
// ê¹”ë”í•œ ì¸í„°í˜ì´ìŠ¤
public abstract class FSMNode
{
    public abstract void OnEnter();
    public abstract void Update();
    public abstract void OnExit();
}

// ìœ ì—°í•œ BT êµ¬ì¡°
public interface BTNode
{
    EvaluateResult Evaluate();
}
```
- **ì¥ì :** í™•ì¥ì„± ìš°ìˆ˜, ì½”ë“œ ì¬ì‚¬ìš©ì„± ë†’ìŒ, ê²Œì„ ë¡œì§ ëª…í™•
- **í™œìš©:** ìƒˆë¡œìš´ ìºë¦­í„°/ì  íƒ€ì… ì¶”ê°€ ì‹œ ë…¸ë“œë§Œ êµ¬í˜„í•˜ë©´ ë¨

#### 2. **ScriptableObject ê¸°ë°˜ ë°ì´í„° ì„¤ê³„** â­â­â­â­â­
```csharp
[CreateAssetMenu(fileName = "CharacterStats", menuName = "Stats/Character")]
public class CharacterStats : ScriptableObject
{
    public float maxHealth;
    public float moveSpeed;
    public float jumpForce;
    // ...
}
```
- **ì¥ì :** 
  - ì½”ë“œ ìˆ˜ì • ì—†ì´ ë°¸ëŸ°ì‹± ê°€ëŠ¥
  - ì—¬ëŸ¬ ìºë¦­í„° í”„ë¦¬ì…‹ ê´€ë¦¬ ìš©ì´
  - ë””ìì´ë„ˆ ì¹œí™”ì 
- **íš¨ê³¼:** ê°œë°œ ì†ë„ í–¥ìƒ, ìœ ì§€ë³´ìˆ˜ì„± ìš°ìˆ˜

#### 3. **Event ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©** â­â­â­â­
```csharp
// HealthSystem
public UnityEvent<Vector2> EventHit;
public UnityEvent EventDeath;

// ì‚¬ìš©ì²˜
healthSystem.EventHit.AddListener(ListenerHit);
healthSystem.EventDeath.AddListener(ListenerDeath);
```
- **ì¥ì :**
  - ì‹œìŠ¤í…œ ê°„ ì˜ì¡´ì„± ìµœì†Œí™”
  - ê¸°ëŠ¥ ì¶”ê°€/ì œê±° ìš©ì´ (ì˜ˆ: ì‚¬ìš´ë“œ, íŒŒí‹°í´ ë“±)
  - í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± í–¥ìƒ
- **í™•ì¥ì„±:** ìƒˆë¡œìš´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€ê°€ ììœ ë¡œì›€

---

## ğŸ“‹ **Action Items Checklist**

### Immediate (ì´ë²ˆ ì£¼ ë‚´)
- [ ] ObjectPool.Get() ë²„ê·¸ ìˆ˜ì •
- [ ] Component null ê²€ì¦ ì¶”ê°€ (RequireComponent + Debug.Assert)
- [ ] ë¬¼ë¦¬ ì²˜ë¦¬ FixedUpdate ì´ë™

### Short-term (2ì£¼ ë‚´)
- [ ] í° ë©”ì„œë“œ ë¶„í•´ (BuildStateController ë“±)
- [ ] Physics2D NonAlloc ë²„ì „ ì‚¬ìš©
- [ ] Animator Parameter Hash ì ìš©
- [ ] XML ë¬¸ì„œí™” ì£¼ì„ ì¶”ê°€

### Medium-term (1ê°œì›” ë‚´)
- [ ] PlayerBehavior ì±…ì„ ë¶„ë¦¬ (Movement, StateMachine ë“±)
- [ ] Skill System ì¶”ìƒí™” ë° Manager ë„ì…
- [ ] ë„¤ì„ìŠ¤í˜ì´ìŠ¤ êµ¬ì¡° ì„¤ê³„ ë° ì ìš©
- [ ] íƒ€ì´ë¨¸ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ ì‘ì„±

### Long-term (ë¦¬íŒ©í† ë§)
- [ ] State Transition Table ì‹œìŠ¤í…œ
- [ ] Enemy Base Class êµ¬ì¡° ê°œì„ 
- [ ] Unit Test ì»¤ë²„ë¦¬ì§€ í™•ë³´
- [ ] ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ë° ìµœì í™”

---

## ğŸ’¬ **ì´í‰**

ì „ë°˜ì ìœ¼ë¡œ **ì¤‘ìƒê¸‰ ìˆ˜ì¤€ì˜ ì½”ë“œ í’ˆì§ˆ**ì„ ë³´ì—¬ì£¼ê³  ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ FSM/BehaviorTree êµ¬í˜„ê³¼ ScriptableObject í™œìš©ì€ ëª¨ë²”ì ì´ë©°, ì´ëŠ” í–¥í›„ ê²Œì„ í™•ì¥ì— í° ë„ì›€ì´ ë  ê²ƒì…ë‹ˆë‹¤.

**ì£¼ìš” ê°•ì :**
- ëª…í™•í•œ ì•„í‚¤í…ì²˜ íŒ¨í„´ (FSM, BT)
- ë°ì´í„° ê¸°ë°˜ ì„¤ê³„ (ScriptableObject)
- ì¼ê´€ëœ ì½”ë“œ ìŠ¤íƒ€ì¼
- Event ê¸°ë°˜ ëŠìŠ¨í•œ ê²°í•©

**ê°œì„  í•„ìš” ì˜ì—­:**
- Performance ìµœì í™” (ObjectPool ë²„ê·¸ëŠ” critical)
- Error Handling ê°•í™” (null ì²´í¬, ê²½ê³„ ê²€ì¦)
- ì±…ì„ ë¶„ë¦¬ (ì¼ë¶€ í´ë˜ìŠ¤ê°€ ë„ˆë¬´ ë§ì€ ì—­í• )
- ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë¶€ì¬

**ê¶Œì¥ ì‚¬í•­:**
1. ì¦‰ì‹œ ìˆ˜ì • í•­ëª©ë¶€í„° ì²˜ë¦¬ (íŠ¹íˆ ObjectPool)
2. ë¦¬íŒ©í† ë§ì€ ë‹¨ê³„ì ìœ¼ë¡œ ì§„í–‰
3. í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„± ìŠµê´€ ë“¤ì´ê¸°
4. ì„±ëŠ¥ í”„ë¡œíŒŒì¼ë§ ì •ê¸°ì ìœ¼ë¡œ ì‹¤ì‹œ

ì´ í”„ë¡œì íŠ¸ëŠ” ê²¬ê³ í•œ ê¸°ë°˜ ìœ„ì— ì„¸ì›Œì¡Œìœ¼ë©°, ì œì•ˆëœ ê°œì„ ì‚¬í•­ë“¤ì„ ì ìš©í•œë‹¤ë©´ **ìƒê¸‰ ìˆ˜ì¤€ì˜ Unity í”„ë¡œì íŠ¸**ë¡œ ë°œì „í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

---

**í‰ê°€ì:** GitHub Copilot (Claude Sonnet 4.5)  
**í‰ê°€ ê¸°ì¤€:** Unity C# Code Evaluation Prompt (10ê°œ ë¶€ë¬¸)  
**í‰ê°€ ëŒ€ìƒ:** Assets/Scripts í´ë” í•µì‹¬ ë¡œì§
